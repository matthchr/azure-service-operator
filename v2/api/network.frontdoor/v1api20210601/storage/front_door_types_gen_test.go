// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_FrontDoor_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor, FrontDoorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor runs a test to see if a specific instance of FrontDoor round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor(subject FrontDoor) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor instances for property testing - lazily instantiated by FrontDoorGenerator()
var frontDoorGenerator gopter.Gen

// FrontDoorGenerator returns a generator of FrontDoor instances for property testing.
func FrontDoorGenerator() gopter.Gen {
	if frontDoorGenerator != nil {
		return frontDoorGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFrontDoor(generators)
	frontDoorGenerator = gen.Struct(reflect.TypeOf(FrontDoor{}), generators)

	return frontDoorGenerator
}

// AddRelatedPropertyGeneratorsForFrontDoor is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor(gens map[string]gopter.Gen) {
	gens["Spec"] = FrontDoor_SpecGenerator()
	gens["Status"] = FrontDoor_STATUSGenerator()
}

func Test_FrontDoor_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor_Spec, FrontDoor_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor_Spec runs a test to see if a specific instance of FrontDoor_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor_Spec(subject FrontDoor_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor_Spec instances for property testing - lazily instantiated by FrontDoor_SpecGenerator()
var frontDoor_SpecGenerator gopter.Gen

// FrontDoor_SpecGenerator returns a generator of FrontDoor_Spec instances for property testing.
// We first initialize frontDoor_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoor_SpecGenerator() gopter.Gen {
	if frontDoor_SpecGenerator != nil {
		return frontDoor_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec(generators)
	frontDoor_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec(generators)
	AddRelatedPropertyGeneratorsForFrontDoor_Spec(generators)
	frontDoor_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec{}), generators)

	return frontDoor_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoor_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoor_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoor_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor_Spec(gens map[string]gopter.Gen) {
	gens["BackendPools"] = gen.SliceOf(BackendPoolGenerator())
	gens["BackendPoolsSettings"] = gen.PtrOf(BackendPoolsSettingsGenerator())
	gens["FrontendEndpoints"] = gen.SliceOf(FrontendEndpointGenerator())
	gens["HealthProbeSettings"] = gen.SliceOf(HealthProbeSettingsModelGenerator())
	gens["LoadBalancingSettings"] = gen.SliceOf(LoadBalancingSettingsModelGenerator())
	gens["RoutingRules"] = gen.SliceOf(RoutingRuleGenerator())
}

func Test_FrontDoor_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor_STATUS, FrontDoor_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor_STATUS runs a test to see if a specific instance of FrontDoor_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor_STATUS(subject FrontDoor_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor_STATUS instances for property testing - lazily instantiated by FrontDoor_STATUSGenerator()
var frontDoor_STATUSGenerator gopter.Gen

// FrontDoor_STATUSGenerator returns a generator of FrontDoor_STATUS instances for property testing.
// We first initialize frontDoor_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoor_STATUSGenerator() gopter.Gen {
	if frontDoor_STATUSGenerator != nil {
		return frontDoor_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_STATUS(generators)
	frontDoor_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoor_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontDoor_STATUS(generators)
	frontDoor_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoor_STATUS{}), generators)

	return frontDoor_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoor_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoor_STATUS(gens map[string]gopter.Gen) {
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["ExtendedProperties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["FrontdoorId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoor_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPools"] = gen.SliceOf(BackendPool_STATUSGenerator())
	gens["BackendPoolsSettings"] = gen.PtrOf(BackendPoolsSettings_STATUSGenerator())
	gens["FrontendEndpoints"] = gen.SliceOf(FrontendEndpoint_STATUSGenerator())
	gens["HealthProbeSettings"] = gen.SliceOf(HealthProbeSettingsModel_STATUSGenerator())
	gens["LoadBalancingSettings"] = gen.SliceOf(LoadBalancingSettingsModel_STATUSGenerator())
	gens["RoutingRules"] = gen.SliceOf(RoutingRule_STATUSGenerator())
	gens["RulesEngines"] = gen.SliceOf(RulesEngine_STATUSGenerator())
}

func Test_BackendPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPool, BackendPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPool runs a test to see if a specific instance of BackendPool round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPool(subject BackendPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPool instances for property testing - lazily instantiated by BackendPoolGenerator()
var backendPoolGenerator gopter.Gen

// BackendPoolGenerator returns a generator of BackendPool instances for property testing.
// We first initialize backendPoolGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendPoolGenerator() gopter.Gen {
	if backendPoolGenerator != nil {
		return backendPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool(generators)
	backendPoolGenerator = gen.Struct(reflect.TypeOf(BackendPool{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool(generators)
	AddRelatedPropertyGeneratorsForBackendPool(generators)
	backendPoolGenerator = gen.Struct(reflect.TypeOf(BackendPool{}), generators)

	return backendPoolGenerator
}

// AddIndependentPropertyGeneratorsForBackendPool is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPool(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendPool(gens map[string]gopter.Gen) {
	gens["Backends"] = gen.SliceOf(BackendGenerator())
	gens["HealthProbeSettings"] = gen.PtrOf(SubResourceGenerator())
	gens["LoadBalancingSettings"] = gen.PtrOf(SubResourceGenerator())
}

func Test_BackendPool_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPool_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPool_STATUS, BackendPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPool_STATUS runs a test to see if a specific instance of BackendPool_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPool_STATUS(subject BackendPool_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPool_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPool_STATUS instances for property testing - lazily instantiated by BackendPool_STATUSGenerator()
var backendPool_STATUSGenerator gopter.Gen

// BackendPool_STATUSGenerator returns a generator of BackendPool_STATUS instances for property testing.
func BackendPool_STATUSGenerator() gopter.Gen {
	if backendPool_STATUSGenerator != nil {
		return backendPool_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool_STATUS(generators)
	backendPool_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendPool_STATUS{}), generators)

	return backendPool_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackendPool_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPool_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackendPoolsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolsSettings, BackendPoolsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolsSettings runs a test to see if a specific instance of BackendPoolsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolsSettings(subject BackendPoolsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolsSettings instances for property testing - lazily instantiated by
// BackendPoolsSettingsGenerator()
var backendPoolsSettingsGenerator gopter.Gen

// BackendPoolsSettingsGenerator returns a generator of BackendPoolsSettings instances for property testing.
func BackendPoolsSettingsGenerator() gopter.Gen {
	if backendPoolsSettingsGenerator != nil {
		return backendPoolsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPoolsSettings(generators)
	backendPoolsSettingsGenerator = gen.Struct(reflect.TypeOf(BackendPoolsSettings{}), generators)

	return backendPoolsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForBackendPoolsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPoolsSettings(gens map[string]gopter.Gen) {
	gens["EnforceCertificateNameCheck"] = gen.PtrOf(gen.AlphaString())
	gens["SendRecvTimeoutSeconds"] = gen.PtrOf(gen.Int())
}

func Test_BackendPoolsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolsSettings_STATUS, BackendPoolsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolsSettings_STATUS runs a test to see if a specific instance of BackendPoolsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolsSettings_STATUS(subject BackendPoolsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolsSettings_STATUS instances for property testing - lazily instantiated by
// BackendPoolsSettings_STATUSGenerator()
var backendPoolsSettings_STATUSGenerator gopter.Gen

// BackendPoolsSettings_STATUSGenerator returns a generator of BackendPoolsSettings_STATUS instances for property testing.
func BackendPoolsSettings_STATUSGenerator() gopter.Gen {
	if backendPoolsSettings_STATUSGenerator != nil {
		return backendPoolsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS(generators)
	backendPoolsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendPoolsSettings_STATUS{}), generators)

	return backendPoolsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["EnforceCertificateNameCheck"] = gen.PtrOf(gen.AlphaString())
	gens["SendRecvTimeoutSeconds"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpoint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpoint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpoint, FrontendEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpoint runs a test to see if a specific instance of FrontendEndpoint round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpoint(subject FrontendEndpoint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpoint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpoint instances for property testing - lazily instantiated by FrontendEndpointGenerator()
var frontendEndpointGenerator gopter.Gen

// FrontendEndpointGenerator returns a generator of FrontendEndpoint instances for property testing.
// We first initialize frontendEndpointGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendEndpointGenerator() gopter.Gen {
	if frontendEndpointGenerator != nil {
		return frontendEndpointGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint(generators)
	frontendEndpointGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint(generators)
	AddRelatedPropertyGeneratorsForFrontendEndpoint(generators)
	frontendEndpointGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint{}), generators)

	return frontendEndpointGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpoint is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpoint(gens map[string]gopter.Gen) {
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SessionAffinityEnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["SessionAffinityTtlSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFrontendEndpoint is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendEndpoint(gens map[string]gopter.Gen) {
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_FrontendEndpoint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpoint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpoint_STATUS, FrontendEndpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpoint_STATUS runs a test to see if a specific instance of FrontendEndpoint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpoint_STATUS(subject FrontendEndpoint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpoint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpoint_STATUS instances for property testing - lazily instantiated by
// FrontendEndpoint_STATUSGenerator()
var frontendEndpoint_STATUSGenerator gopter.Gen

// FrontendEndpoint_STATUSGenerator returns a generator of FrontendEndpoint_STATUS instances for property testing.
func FrontendEndpoint_STATUSGenerator() gopter.Gen {
	if frontendEndpoint_STATUSGenerator != nil {
		return frontendEndpoint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS(generators)
	frontendEndpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint_STATUS{}), generators)

	return frontendEndpoint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_HealthProbeSettingsModel_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsModel via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsModel, HealthProbeSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsModel runs a test to see if a specific instance of HealthProbeSettingsModel round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsModel(subject HealthProbeSettingsModel) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsModel
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsModel instances for property testing - lazily instantiated by
// HealthProbeSettingsModelGenerator()
var healthProbeSettingsModelGenerator gopter.Gen

// HealthProbeSettingsModelGenerator returns a generator of HealthProbeSettingsModel instances for property testing.
func HealthProbeSettingsModelGenerator() gopter.Gen {
	if healthProbeSettingsModelGenerator != nil {
		return healthProbeSettingsModelGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel(generators)
	healthProbeSettingsModelGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel{}), generators)

	return healthProbeSettingsModelGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsModel is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsModel(gens map[string]gopter.Gen) {
	gens["EnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["HealthProbeMethod"] = gen.PtrOf(gen.AlphaString())
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_HealthProbeSettingsModel_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsModel_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsModel_STATUS, HealthProbeSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsModel_STATUS runs a test to see if a specific instance of HealthProbeSettingsModel_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsModel_STATUS(subject HealthProbeSettingsModel_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsModel_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsModel_STATUS instances for property testing - lazily instantiated by
// HealthProbeSettingsModel_STATUSGenerator()
var healthProbeSettingsModel_STATUSGenerator gopter.Gen

// HealthProbeSettingsModel_STATUSGenerator returns a generator of HealthProbeSettingsModel_STATUS instances for property testing.
func HealthProbeSettingsModel_STATUSGenerator() gopter.Gen {
	if healthProbeSettingsModel_STATUSGenerator != nil {
		return healthProbeSettingsModel_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS(generators)
	healthProbeSettingsModel_STATUSGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel_STATUS{}), generators)

	return healthProbeSettingsModel_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingSettingsModel_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsModel via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsModel, LoadBalancingSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsModel runs a test to see if a specific instance of LoadBalancingSettingsModel round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsModel(subject LoadBalancingSettingsModel) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsModel
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsModel instances for property testing - lazily instantiated by
// LoadBalancingSettingsModelGenerator()
var loadBalancingSettingsModelGenerator gopter.Gen

// LoadBalancingSettingsModelGenerator returns a generator of LoadBalancingSettingsModel instances for property testing.
func LoadBalancingSettingsModelGenerator() gopter.Gen {
	if loadBalancingSettingsModelGenerator != nil {
		return loadBalancingSettingsModelGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel(generators)
	loadBalancingSettingsModelGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel{}), generators)

	return loadBalancingSettingsModelGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel(gens map[string]gopter.Gen) {
	gens["AdditionalLatencyMilliseconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SampleSize"] = gen.PtrOf(gen.Int())
	gens["SuccessfulSamplesRequired"] = gen.PtrOf(gen.Int())
}

func Test_LoadBalancingSettingsModel_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsModel_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS, LoadBalancingSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS runs a test to see if a specific instance of LoadBalancingSettingsModel_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS(subject LoadBalancingSettingsModel_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsModel_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsModel_STATUS instances for property testing - lazily instantiated by
// LoadBalancingSettingsModel_STATUSGenerator()
var loadBalancingSettingsModel_STATUSGenerator gopter.Gen

// LoadBalancingSettingsModel_STATUSGenerator returns a generator of LoadBalancingSettingsModel_STATUS instances for property testing.
func LoadBalancingSettingsModel_STATUSGenerator() gopter.Gen {
	if loadBalancingSettingsModel_STATUSGenerator != nil {
		return loadBalancingSettingsModel_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS(generators)
	loadBalancingSettingsModel_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel_STATUS{}), generators)

	return loadBalancingSettingsModel_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRule, RoutingRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRule runs a test to see if a specific instance of RoutingRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRule(subject RoutingRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRule instances for property testing - lazily instantiated by RoutingRuleGenerator()
var routingRuleGenerator gopter.Gen

// RoutingRuleGenerator returns a generator of RoutingRule instances for property testing.
// We first initialize routingRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingRuleGenerator() gopter.Gen {
	if routingRuleGenerator != nil {
		return routingRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule(generators)
	routingRuleGenerator = gen.Struct(reflect.TypeOf(RoutingRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule(generators)
	AddRelatedPropertyGeneratorsForRoutingRule(generators)
	routingRuleGenerator = gen.Struct(reflect.TypeOf(RoutingRule{}), generators)

	return routingRuleGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRule(gens map[string]gopter.Gen) {
	gens["AcceptedProtocols"] = gen.SliceOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PatternsToMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingRule(gens map[string]gopter.Gen) {
	gens["FrontendEndpoints"] = gen.SliceOf(SubResourceGenerator())
	gens["RouteConfiguration"] = gen.PtrOf(RouteConfigurationGenerator())
	gens["RulesEngine"] = gen.PtrOf(SubResourceGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_RoutingRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRule_STATUS, RoutingRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRule_STATUS runs a test to see if a specific instance of RoutingRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRule_STATUS(subject RoutingRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRule_STATUS instances for property testing - lazily instantiated by RoutingRule_STATUSGenerator()
var routingRule_STATUSGenerator gopter.Gen

// RoutingRule_STATUSGenerator returns a generator of RoutingRule_STATUS instances for property testing.
func RoutingRule_STATUSGenerator() gopter.Gen {
	if routingRule_STATUSGenerator != nil {
		return routingRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule_STATUS(generators)
	routingRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingRule_STATUS{}), generators)

	return routingRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRule_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RulesEngine_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngine_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngine_STATUS, RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngine_STATUS runs a test to see if a specific instance of RulesEngine_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngine_STATUS(subject RulesEngine_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngine_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngine_STATUS instances for property testing - lazily instantiated by RulesEngine_STATUSGenerator()
var rulesEngine_STATUSGenerator gopter.Gen

// RulesEngine_STATUSGenerator returns a generator of RulesEngine_STATUS instances for property testing.
func RulesEngine_STATUSGenerator() gopter.Gen {
	if rulesEngine_STATUSGenerator != nil {
		return rulesEngine_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngine_STATUS(generators)
	rulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngine_STATUS{}), generators)

	return rulesEngine_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngine_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_Backend_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Backend via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackend, BackendGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackend runs a test to see if a specific instance of Backend round trips to JSON and back losslessly
func RunJSONSerializationTestForBackend(subject Backend) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Backend
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Backend instances for property testing - lazily instantiated by BackendGenerator()
var backendGenerator gopter.Gen

// BackendGenerator returns a generator of Backend instances for property testing.
func BackendGenerator() gopter.Gen {
	if backendGenerator != nil {
		return backendGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackend(generators)
	backendGenerator = gen.Struct(reflect.TypeOf(Backend{}), generators)

	return backendGenerator
}

// AddIndependentPropertyGeneratorsForBackend is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackend(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["BackendHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpointProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpointProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink, FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of FrontendEndpointProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink(subject FrontendEndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpointProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily
// instantiated by FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator()
var frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink instances for property testing.
func FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLink{}), generators)

	return frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator
}

func Test_RouteConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfiguration, RouteConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfiguration runs a test to see if a specific instance of RouteConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfiguration(subject RouteConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfiguration instances for property testing - lazily instantiated by RouteConfigurationGenerator()
var routeConfigurationGenerator gopter.Gen

// RouteConfigurationGenerator returns a generator of RouteConfiguration instances for property testing.
func RouteConfigurationGenerator() gopter.Gen {
	if routeConfigurationGenerator != nil {
		return routeConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRouteConfiguration(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(RouteConfiguration{}), map[string]gopter.Gen{propName: propGen}))
	}
	routeConfigurationGenerator = gen.OneGenOf(gens...)

	return routeConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForRouteConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfiguration(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureFrontDoorModelsFrontdoorForwarding"] = ForwardingConfigurationGenerator().Map(func(it ForwardingConfiguration) *ForwardingConfiguration {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureFrontDoorModelsFrontdoorRedirect"] = RedirectConfigurationGenerator().Map(func(it RedirectConfiguration) *RedirectConfiguration {
		return &it
	}) // generate one case for OneOf type
}

func Test_RoutingRuleProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRuleProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink, RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of RoutingRuleProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink(subject RoutingRuleProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRuleProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily
// instantiated by RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator()
var routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink instances for property testing.
func RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(RoutingRuleProperties_WebApplicationFirewallPolicyLink{}), generators)

	return routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

func Test_ForwardingConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardingConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardingConfiguration, ForwardingConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardingConfiguration runs a test to see if a specific instance of ForwardingConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardingConfiguration(subject ForwardingConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardingConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardingConfiguration instances for property testing - lazily instantiated by
// ForwardingConfigurationGenerator()
var forwardingConfigurationGenerator gopter.Gen

// ForwardingConfigurationGenerator returns a generator of ForwardingConfiguration instances for property testing.
// We first initialize forwardingConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ForwardingConfigurationGenerator() gopter.Gen {
	if forwardingConfigurationGenerator != nil {
		return forwardingConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration(generators)
	forwardingConfigurationGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration(generators)
	AddRelatedPropertyGeneratorsForForwardingConfiguration(generators)
	forwardingConfigurationGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration{}), generators)

	return forwardingConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForForwardingConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardingConfiguration(gens map[string]gopter.Gen) {
	gens["CustomForwardingPath"] = gen.PtrOf(gen.AlphaString())
	gens["ForwardingProtocol"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForForwardingConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForForwardingConfiguration(gens map[string]gopter.Gen) {
	gens["BackendPool"] = gen.PtrOf(SubResourceGenerator())
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationGenerator())
}

func Test_RedirectConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RedirectConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRedirectConfiguration, RedirectConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRedirectConfiguration runs a test to see if a specific instance of RedirectConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForRedirectConfiguration(subject RedirectConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RedirectConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RedirectConfiguration instances for property testing - lazily instantiated by
// RedirectConfigurationGenerator()
var redirectConfigurationGenerator gopter.Gen

// RedirectConfigurationGenerator returns a generator of RedirectConfiguration instances for property testing.
func RedirectConfigurationGenerator() gopter.Gen {
	if redirectConfigurationGenerator != nil {
		return redirectConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRedirectConfiguration(generators)
	redirectConfigurationGenerator = gen.Struct(reflect.TypeOf(RedirectConfiguration{}), generators)

	return redirectConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForRedirectConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRedirectConfiguration(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHost"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
	gens["RedirectProtocol"] = gen.PtrOf(gen.AlphaString())
	gens["RedirectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_CacheConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration runs a test to see if a specific instance of CacheConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration(subject CacheConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration instances for property testing - lazily instantiated by CacheConfigurationGenerator()
var cacheConfigurationGenerator gopter.Gen

// CacheConfigurationGenerator returns a generator of CacheConfiguration instances for property testing.
func CacheConfigurationGenerator() gopter.Gen {
	if cacheConfigurationGenerator != nil {
		return cacheConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration(generators)
	cacheConfigurationGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration{}), generators)

	return cacheConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration(gens map[string]gopter.Gen) {
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["DynamicCompression"] = gen.PtrOf(gen.AlphaString())
	gens["QueryParameterStripDirective"] = gen.PtrOf(gen.AlphaString())
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
}
