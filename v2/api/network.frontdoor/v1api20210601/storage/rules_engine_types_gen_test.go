// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_RulesEngine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngine, RulesEngineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngine runs a test to see if a specific instance of RulesEngine round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngine(subject RulesEngine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngine instances for property testing - lazily instantiated by RulesEngineGenerator()
var rulesEngineGenerator gopter.Gen

// RulesEngineGenerator returns a generator of RulesEngine instances for property testing.
func RulesEngineGenerator() gopter.Gen {
	if rulesEngineGenerator != nil {
		return rulesEngineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngine(generators)
	rulesEngineGenerator = gen.Struct(reflect.TypeOf(RulesEngine{}), generators)

	return rulesEngineGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngine(gens map[string]gopter.Gen) {
	gens["Spec"] = FrontDoors_RulesEngine_SpecGenerator()
	gens["Status"] = FrontDoors_RulesEngine_STATUSGenerator()
}

func Test_FrontDoors_RulesEngine_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoors_RulesEngine_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoors_RulesEngine_Spec, FrontDoors_RulesEngine_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoors_RulesEngine_Spec runs a test to see if a specific instance of FrontDoors_RulesEngine_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoors_RulesEngine_Spec(subject FrontDoors_RulesEngine_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoors_RulesEngine_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoors_RulesEngine_Spec instances for property testing - lazily instantiated by
// FrontDoors_RulesEngine_SpecGenerator()
var frontDoors_RulesEngine_SpecGenerator gopter.Gen

// FrontDoors_RulesEngine_SpecGenerator returns a generator of FrontDoors_RulesEngine_Spec instances for property testing.
// We first initialize frontDoors_RulesEngine_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoors_RulesEngine_SpecGenerator() gopter.Gen {
	if frontDoors_RulesEngine_SpecGenerator != nil {
		return frontDoors_RulesEngine_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	frontDoors_RulesEngine_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	frontDoors_RulesEngine_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_Spec{}), generators)

	return frontDoors_RulesEngine_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(RulesEngineRuleGenerator())
}

func Test_FrontDoors_RulesEngine_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoors_RulesEngine_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS, FrontDoors_RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS runs a test to see if a specific instance of FrontDoors_RulesEngine_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS(subject FrontDoors_RulesEngine_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoors_RulesEngine_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoors_RulesEngine_STATUS instances for property testing - lazily instantiated by
// FrontDoors_RulesEngine_STATUSGenerator()
var frontDoors_RulesEngine_STATUSGenerator gopter.Gen

// FrontDoors_RulesEngine_STATUSGenerator returns a generator of FrontDoors_RulesEngine_STATUS instances for property testing.
// We first initialize frontDoors_RulesEngine_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoors_RulesEngine_STATUSGenerator() gopter.Gen {
	if frontDoors_RulesEngine_STATUSGenerator != nil {
		return frontDoors_RulesEngine_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	frontDoors_RulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	frontDoors_RulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_STATUS{}), generators)

	return frontDoors_RulesEngine_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(RulesEngineRule_STATUSGenerator())
}

func Test_RulesEngineRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineRule, RulesEngineRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineRule runs a test to see if a specific instance of RulesEngineRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineRule(subject RulesEngineRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineRule instances for property testing - lazily instantiated by RulesEngineRuleGenerator()
var rulesEngineRuleGenerator gopter.Gen

// RulesEngineRuleGenerator returns a generator of RulesEngineRule instances for property testing.
// We first initialize rulesEngineRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RulesEngineRuleGenerator() gopter.Gen {
	if rulesEngineRuleGenerator != nil {
		return rulesEngineRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule(generators)
	rulesEngineRuleGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule(generators)
	AddRelatedPropertyGeneratorsForRulesEngineRule(generators)
	rulesEngineRuleGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule{}), generators)

	return rulesEngineRuleGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineRule(gens map[string]gopter.Gen) {
	gens["MatchProcessingBehavior"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForRulesEngineRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(RulesEngineActionGenerator())
	gens["MatchConditions"] = gen.SliceOf(RulesEngineMatchConditionGenerator())
}

func Test_RulesEngineRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineRule_STATUS, RulesEngineRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineRule_STATUS runs a test to see if a specific instance of RulesEngineRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineRule_STATUS(subject RulesEngineRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineRule_STATUS instances for property testing - lazily instantiated by
// RulesEngineRule_STATUSGenerator()
var rulesEngineRule_STATUSGenerator gopter.Gen

// RulesEngineRule_STATUSGenerator returns a generator of RulesEngineRule_STATUS instances for property testing.
// We first initialize rulesEngineRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RulesEngineRule_STATUSGenerator() gopter.Gen {
	if rulesEngineRule_STATUSGenerator != nil {
		return rulesEngineRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	rulesEngineRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	rulesEngineRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule_STATUS{}), generators)

	return rulesEngineRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(gens map[string]gopter.Gen) {
	gens["MatchProcessingBehavior"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(RulesEngineAction_STATUSGenerator())
	gens["MatchConditions"] = gen.SliceOf(RulesEngineMatchCondition_STATUSGenerator())
}

func Test_RulesEngineAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineAction, RulesEngineActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineAction runs a test to see if a specific instance of RulesEngineAction round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineAction(subject RulesEngineAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineAction instances for property testing - lazily instantiated by RulesEngineActionGenerator()
var rulesEngineActionGenerator gopter.Gen

// RulesEngineActionGenerator returns a generator of RulesEngineAction instances for property testing.
func RulesEngineActionGenerator() gopter.Gen {
	if rulesEngineActionGenerator != nil {
		return rulesEngineActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngineAction(generators)
	rulesEngineActionGenerator = gen.Struct(reflect.TypeOf(RulesEngineAction{}), generators)

	return rulesEngineActionGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngineAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineAction(gens map[string]gopter.Gen) {
	gens["RequestHeaderActions"] = gen.SliceOf(HeaderActionGenerator())
	gens["ResponseHeaderActions"] = gen.SliceOf(HeaderActionGenerator())
	gens["RouteConfigurationOverride"] = gen.PtrOf(RouteConfigurationGenerator())
}

func Test_RulesEngineAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineAction_STATUS, RulesEngineAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineAction_STATUS runs a test to see if a specific instance of RulesEngineAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineAction_STATUS(subject RulesEngineAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineAction_STATUS instances for property testing - lazily instantiated by
// RulesEngineAction_STATUSGenerator()
var rulesEngineAction_STATUSGenerator gopter.Gen

// RulesEngineAction_STATUSGenerator returns a generator of RulesEngineAction_STATUS instances for property testing.
func RulesEngineAction_STATUSGenerator() gopter.Gen {
	if rulesEngineAction_STATUSGenerator != nil {
		return rulesEngineAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS(generators)
	rulesEngineAction_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineAction_STATUS{}), generators)

	return rulesEngineAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS(gens map[string]gopter.Gen) {
	gens["RequestHeaderActions"] = gen.SliceOf(HeaderAction_STATUSGenerator())
	gens["ResponseHeaderActions"] = gen.SliceOf(HeaderAction_STATUSGenerator())
	gens["RouteConfigurationOverride"] = gen.PtrOf(RouteConfiguration_STATUSGenerator())
}

func Test_RulesEngineMatchCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineMatchCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineMatchCondition, RulesEngineMatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineMatchCondition runs a test to see if a specific instance of RulesEngineMatchCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineMatchCondition(subject RulesEngineMatchCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineMatchCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineMatchCondition instances for property testing - lazily instantiated by
// RulesEngineMatchConditionGenerator()
var rulesEngineMatchConditionGenerator gopter.Gen

// RulesEngineMatchConditionGenerator returns a generator of RulesEngineMatchCondition instances for property testing.
func RulesEngineMatchConditionGenerator() gopter.Gen {
	if rulesEngineMatchConditionGenerator != nil {
		return rulesEngineMatchConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineMatchCondition(generators)
	rulesEngineMatchConditionGenerator = gen.Struct(reflect.TypeOf(RulesEngineMatchCondition{}), generators)

	return rulesEngineMatchConditionGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineMatchCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineMatchCondition(gens map[string]gopter.Gen) {
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["RulesEngineMatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["RulesEngineMatchVariable"] = gen.PtrOf(gen.AlphaString())
	gens["RulesEngineOperator"] = gen.PtrOf(gen.AlphaString())
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.AlphaString())
}

func Test_RulesEngineMatchCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineMatchCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineMatchCondition_STATUS, RulesEngineMatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineMatchCondition_STATUS runs a test to see if a specific instance of RulesEngineMatchCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineMatchCondition_STATUS(subject RulesEngineMatchCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineMatchCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineMatchCondition_STATUS instances for property testing - lazily instantiated by
// RulesEngineMatchCondition_STATUSGenerator()
var rulesEngineMatchCondition_STATUSGenerator gopter.Gen

// RulesEngineMatchCondition_STATUSGenerator returns a generator of RulesEngineMatchCondition_STATUS instances for property testing.
func RulesEngineMatchCondition_STATUSGenerator() gopter.Gen {
	if rulesEngineMatchCondition_STATUSGenerator != nil {
		return rulesEngineMatchCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS(generators)
	rulesEngineMatchCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineMatchCondition_STATUS{}), generators)

	return rulesEngineMatchCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS(gens map[string]gopter.Gen) {
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["RulesEngineMatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["RulesEngineMatchVariable"] = gen.PtrOf(gen.AlphaString())
	gens["RulesEngineOperator"] = gen.PtrOf(gen.AlphaString())
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.AlphaString())
}

func Test_HeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderAction, HeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderAction runs a test to see if a specific instance of HeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderAction(subject HeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderAction instances for property testing - lazily instantiated by HeaderActionGenerator()
var headerActionGenerator gopter.Gen

// HeaderActionGenerator returns a generator of HeaderAction instances for property testing.
func HeaderActionGenerator() gopter.Gen {
	if headerActionGenerator != nil {
		return headerActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderAction(generators)
	headerActionGenerator = gen.Struct(reflect.TypeOf(HeaderAction{}), generators)

	return headerActionGenerator
}

// AddIndependentPropertyGeneratorsForHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderAction(gens map[string]gopter.Gen) {
	gens["HeaderActionType"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HeaderAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderAction_STATUS, HeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderAction_STATUS runs a test to see if a specific instance of HeaderAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderAction_STATUS(subject HeaderAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderAction_STATUS instances for property testing - lazily instantiated by
// HeaderAction_STATUSGenerator()
var headerAction_STATUSGenerator gopter.Gen

// HeaderAction_STATUSGenerator returns a generator of HeaderAction_STATUS instances for property testing.
func HeaderAction_STATUSGenerator() gopter.Gen {
	if headerAction_STATUSGenerator != nil {
		return headerAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderAction_STATUS(generators)
	headerAction_STATUSGenerator = gen.Struct(reflect.TypeOf(HeaderAction_STATUS{}), generators)

	return headerAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHeaderAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["HeaderActionType"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_RouteConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfiguration_STATUS, RouteConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfiguration_STATUS runs a test to see if a specific instance of RouteConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfiguration_STATUS(subject RouteConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfiguration_STATUS instances for property testing - lazily instantiated by
// RouteConfiguration_STATUSGenerator()
var routeConfiguration_STATUSGenerator gopter.Gen

// RouteConfiguration_STATUSGenerator returns a generator of RouteConfiguration_STATUS instances for property testing.
func RouteConfiguration_STATUSGenerator() gopter.Gen {
	if routeConfiguration_STATUSGenerator != nil {
		return routeConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(RouteConfiguration_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	routeConfiguration_STATUSGenerator = gen.OneGenOf(gens...)

	return routeConfiguration_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureFrontDoorModelsFrontdoorForwarding"] = ForwardingConfiguration_STATUSGenerator().Map(func(it ForwardingConfiguration_STATUS) *ForwardingConfiguration_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureFrontDoorModelsFrontdoorRedirect"] = RedirectConfiguration_STATUSGenerator().Map(func(it RedirectConfiguration_STATUS) *RedirectConfiguration_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_ForwardingConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardingConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardingConfiguration_STATUS, ForwardingConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardingConfiguration_STATUS runs a test to see if a specific instance of ForwardingConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardingConfiguration_STATUS(subject ForwardingConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardingConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardingConfiguration_STATUS instances for property testing - lazily instantiated by
// ForwardingConfiguration_STATUSGenerator()
var forwardingConfiguration_STATUSGenerator gopter.Gen

// ForwardingConfiguration_STATUSGenerator returns a generator of ForwardingConfiguration_STATUS instances for property testing.
// We first initialize forwardingConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ForwardingConfiguration_STATUSGenerator() gopter.Gen {
	if forwardingConfiguration_STATUSGenerator != nil {
		return forwardingConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	forwardingConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	forwardingConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_STATUS{}), generators)

	return forwardingConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomForwardingPath"] = gen.PtrOf(gen.AlphaString())
	gens["ForwardingProtocol"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPool"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfiguration_STATUSGenerator())
}

func Test_RedirectConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RedirectConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRedirectConfiguration_STATUS, RedirectConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRedirectConfiguration_STATUS runs a test to see if a specific instance of RedirectConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRedirectConfiguration_STATUS(subject RedirectConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RedirectConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RedirectConfiguration_STATUS instances for property testing - lazily instantiated by
// RedirectConfiguration_STATUSGenerator()
var redirectConfiguration_STATUSGenerator gopter.Gen

// RedirectConfiguration_STATUSGenerator returns a generator of RedirectConfiguration_STATUS instances for property testing.
func RedirectConfiguration_STATUSGenerator() gopter.Gen {
	if redirectConfiguration_STATUSGenerator != nil {
		return redirectConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS(generators)
	redirectConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(RedirectConfiguration_STATUS{}), generators)

	return redirectConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHost"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
	gens["RedirectProtocol"] = gen.PtrOf(gen.AlphaString())
	gens["RedirectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_CacheConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration_STATUS, CacheConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration_STATUS runs a test to see if a specific instance of CacheConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration_STATUS(subject CacheConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration_STATUS instances for property testing - lazily instantiated by
// CacheConfiguration_STATUSGenerator()
var cacheConfiguration_STATUSGenerator gopter.Gen

// CacheConfiguration_STATUSGenerator returns a generator of CacheConfiguration_STATUS instances for property testing.
func CacheConfiguration_STATUSGenerator() gopter.Gen {
	if cacheConfiguration_STATUSGenerator != nil {
		return cacheConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(generators)
	cacheConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration_STATUS{}), generators)

	return cacheConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["DynamicCompression"] = gen.PtrOf(gen.AlphaString())
	gens["QueryParameterStripDirective"] = gen.PtrOf(gen.AlphaString())
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
