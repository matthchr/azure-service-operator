// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"fmt"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20210601/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2021-06-01/frontdoor.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}
type FrontDoor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FrontDoor_Spec   `json:"spec,omitempty"`
	Status            FrontDoor_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &FrontDoor{}

// GetConditions returns the conditions of the resource
func (door *FrontDoor) GetConditions() conditions.Conditions {
	return door.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (door *FrontDoor) SetConditions(conditions conditions.Conditions) {
	door.Status.Conditions = conditions
}

var _ conversion.Convertible = &FrontDoor{}

// ConvertFrom populates our FrontDoor from the provided hub FrontDoor
func (door *FrontDoor) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210601s.FrontDoor)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20210601/storage/FrontDoor but received %T instead", hub)
	}

	return door.AssignProperties_From_FrontDoor(source)
}

// ConvertTo populates the provided hub FrontDoor from our FrontDoor
func (door *FrontDoor) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210601s.FrontDoor)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20210601/storage/FrontDoor but received %T instead", hub)
	}

	return door.AssignProperties_To_FrontDoor(destination)
}

// +kubebuilder:webhook:path=/mutate-network-frontdoor-azure-com-v1api20210601-frontdoor,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=frontdoors,verbs=create;update,versions=v1api20210601,name=default.v1api20210601.frontdoors.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &FrontDoor{}

// Default applies defaults to the FrontDoor resource
func (door *FrontDoor) Default() {
	door.defaultImpl()
	var temp any = door
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (door *FrontDoor) defaultAzureName() {
	if door.Spec.AzureName == "" {
		door.Spec.AzureName = door.Name
	}
}

// defaultImpl applies the code generated defaults to the FrontDoor resource
func (door *FrontDoor) defaultImpl() { door.defaultAzureName() }

var _ genruntime.ImportableResource = &FrontDoor{}

// InitializeSpec initializes the spec for this resource from the given status
func (door *FrontDoor) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*FrontDoor_STATUS); ok {
		return door.Spec.Initialize_From_FrontDoor_STATUS(s)
	}

	return fmt.Errorf("expected Status of type FrontDoor_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &FrontDoor{}

// AzureName returns the Azure name of the resource
func (door *FrontDoor) AzureName() string {
	return door.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-06-01"
func (door FrontDoor) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (door *FrontDoor) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (door *FrontDoor) GetSpec() genruntime.ConvertibleSpec {
	return &door.Spec
}

// GetStatus returns the status of this resource
func (door *FrontDoor) GetStatus() genruntime.ConvertibleStatus {
	return &door.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (door *FrontDoor) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/frontDoors"
func (door *FrontDoor) GetType() string {
	return "Microsoft.Network/frontDoors"
}

// NewEmptyStatus returns a new empty (blank) status
func (door *FrontDoor) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &FrontDoor_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (door *FrontDoor) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(door.Spec)
	return door.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (door *FrontDoor) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*FrontDoor_STATUS); ok {
		door.Status = *st
		return nil
	}

	// Convert status to required version
	var st FrontDoor_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	door.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-frontdoor-azure-com-v1api20210601-frontdoor,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=frontdoors,verbs=create;update,versions=v1api20210601,name=validate.v1api20210601.frontdoors.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &FrontDoor{}

// ValidateCreate validates the creation of the resource
func (door *FrontDoor) ValidateCreate() (admission.Warnings, error) {
	validations := door.createValidations()
	var temp any = door
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (door *FrontDoor) ValidateDelete() (admission.Warnings, error) {
	validations := door.deleteValidations()
	var temp any = door
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (door *FrontDoor) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := door.updateValidations()
	var temp any = door
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (door *FrontDoor) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){door.validateResourceReferences, door.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (door *FrontDoor) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (door *FrontDoor) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return door.validateResourceReferences()
		},
		door.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return door.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (door *FrontDoor) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(door)
}

// validateResourceReferences validates all resource references
func (door *FrontDoor) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&door.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (door *FrontDoor) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*FrontDoor)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, door)
}

// AssignProperties_From_FrontDoor populates our FrontDoor from the provided source FrontDoor
func (door *FrontDoor) AssignProperties_From_FrontDoor(source *v20210601s.FrontDoor) error {

	// ObjectMeta
	door.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec FrontDoor_Spec
	err := spec.AssignProperties_From_FrontDoor_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FrontDoor_Spec() to populate field Spec")
	}
	door.Spec = spec

	// Status
	var status FrontDoor_STATUS
	err = status.AssignProperties_From_FrontDoor_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FrontDoor_STATUS() to populate field Status")
	}
	door.Status = status

	// No error
	return nil
}

// AssignProperties_To_FrontDoor populates the provided destination FrontDoor from our FrontDoor
func (door *FrontDoor) AssignProperties_To_FrontDoor(destination *v20210601s.FrontDoor) error {

	// ObjectMeta
	destination.ObjectMeta = *door.ObjectMeta.DeepCopy()

	// Spec
	var spec v20210601s.FrontDoor_Spec
	err := door.Spec.AssignProperties_To_FrontDoor_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FrontDoor_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20210601s.FrontDoor_STATUS
	err = door.Status.AssignProperties_To_FrontDoor_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FrontDoor_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (door *FrontDoor) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: door.Spec.OriginalVersion(),
		Kind:    "FrontDoor",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2021-06-01/frontdoor.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}
type FrontDoorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FrontDoor `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-06-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-06-01")

type FrontDoor_Spec struct {
	// +kubebuilder:validation:MaxLength=64
	// +kubebuilder:validation:MinLength=5
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]+([-a-zA-Z0-9]?[a-zA-Z0-9])*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BackendPools: Backend pools available to routing rules.
	BackendPools []BackendPool `json:"backendPools,omitempty"`

	// BackendPoolsSettings: Settings for all backendPools
	BackendPoolsSettings *BackendPoolsSettings `json:"backendPoolsSettings,omitempty"`

	// EnabledState: Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *FrontDoorProperties_EnabledState `json:"enabledState,omitempty"`

	// FriendlyName: A friendly name for the frontDoor
	FriendlyName *string `json:"friendlyName,omitempty"`

	// FrontendEndpoints: Frontend endpoints available to routing rules.
	FrontendEndpoints []FrontendEndpoint `json:"frontendEndpoints,omitempty"`

	// HealthProbeSettings: Health probe settings associated with this Front Door instance.
	HealthProbeSettings []HealthProbeSettingsModel `json:"healthProbeSettings,omitempty"`

	// LoadBalancingSettings: Load balancing settings associated with this Front Door instance.
	LoadBalancingSettings []LoadBalancingSettingsModel `json:"loadBalancingSettings,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// RoutingRules: Routing rules associated with this Front Door.
	RoutingRules []RoutingRule `json:"routingRules,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontDoor_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (door *FrontDoor_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if door == nil {
		return nil, nil
	}
	result := &FrontDoor_Spec_ARM{}

	// Set property "Location":
	if door.Location != nil {
		location := *door.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if door.BackendPools != nil ||
		door.BackendPoolsSettings != nil ||
		door.EnabledState != nil ||
		door.FriendlyName != nil ||
		door.FrontendEndpoints != nil ||
		door.HealthProbeSettings != nil ||
		door.LoadBalancingSettings != nil ||
		door.RoutingRules != nil {
		result.Properties = &FrontDoorProperties_ARM{}
	}
	for _, item := range door.BackendPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendPools = append(result.Properties.BackendPools, *item_ARM.(*BackendPool_ARM))
	}
	if door.BackendPoolsSettings != nil {
		backendPoolsSettings_ARM, err := (*door.BackendPoolsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendPoolsSettings := *backendPoolsSettings_ARM.(*BackendPoolsSettings_ARM)
		result.Properties.BackendPoolsSettings = &backendPoolsSettings
	}
	if door.EnabledState != nil {
		enabledState := *door.EnabledState
		result.Properties.EnabledState = &enabledState
	}
	if door.FriendlyName != nil {
		friendlyName := *door.FriendlyName
		result.Properties.FriendlyName = &friendlyName
	}
	for _, item := range door.FrontendEndpoints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendEndpoints = append(result.Properties.FrontendEndpoints, *item_ARM.(*FrontendEndpoint_ARM))
	}
	for _, item := range door.HealthProbeSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.HealthProbeSettings = append(result.Properties.HealthProbeSettings, *item_ARM.(*HealthProbeSettingsModel_ARM))
	}
	for _, item := range door.LoadBalancingSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancingSettings = append(result.Properties.LoadBalancingSettings, *item_ARM.(*LoadBalancingSettingsModel_ARM))
	}
	for _, item := range door.RoutingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.RoutingRules = append(result.Properties.RoutingRules, *item_ARM.(*RoutingRule_ARM))
	}

	// Set property "Tags":
	if door.Tags != nil {
		result.Tags = make(map[string]string, len(door.Tags))
		for key, value := range door.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (door *FrontDoor_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontDoor_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (door *FrontDoor_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontDoor_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontDoor_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	door.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "BackendPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendPools {
			var item1 BackendPool
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.BackendPools = append(door.BackendPools, item1)
		}
	}

	// Set property "BackendPoolsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPoolsSettings != nil {
			var backendPoolsSettings1 BackendPoolsSettings
			err := backendPoolsSettings1.PopulateFromARM(owner, *typedInput.Properties.BackendPoolsSettings)
			if err != nil {
				return err
			}
			backendPoolsSettings := backendPoolsSettings1
			door.BackendPoolsSettings = &backendPoolsSettings
		}
	}

	// Set property "EnabledState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledState != nil {
			enabledState := *typedInput.Properties.EnabledState
			door.EnabledState = &enabledState
		}
	}

	// Set property "FriendlyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FriendlyName != nil {
			friendlyName := *typedInput.Properties.FriendlyName
			door.FriendlyName = &friendlyName
		}
	}

	// Set property "FrontendEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendEndpoints {
			var item1 FrontendEndpoint
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.FrontendEndpoints = append(door.FrontendEndpoints, item1)
		}
	}

	// Set property "HealthProbeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HealthProbeSettings {
			var item1 HealthProbeSettingsModel
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.HealthProbeSettings = append(door.HealthProbeSettings, item1)
		}
	}

	// Set property "LoadBalancingSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingSettings {
			var item1 LoadBalancingSettingsModel
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.LoadBalancingSettings = append(door.LoadBalancingSettings, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		door.Location = &location
	}

	// Set property "Owner":
	door.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "RoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRules {
			var item1 RoutingRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.RoutingRules = append(door.RoutingRules, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		door.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			door.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &FrontDoor_Spec{}

// ConvertSpecFrom populates our FrontDoor_Spec from the provided source
func (door *FrontDoor_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210601s.FrontDoor_Spec)
	if ok {
		// Populate our instance from source
		return door.AssignProperties_From_FrontDoor_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.FrontDoor_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = door.AssignProperties_From_FrontDoor_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our FrontDoor_Spec
func (door *FrontDoor_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210601s.FrontDoor_Spec)
	if ok {
		// Populate destination from our instance
		return door.AssignProperties_To_FrontDoor_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.FrontDoor_Spec{}
	err := door.AssignProperties_To_FrontDoor_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_FrontDoor_Spec populates our FrontDoor_Spec from the provided source FrontDoor_Spec
func (door *FrontDoor_Spec) AssignProperties_From_FrontDoor_Spec(source *v20210601s.FrontDoor_Spec) error {

	// AzureName
	door.AzureName = source.AzureName

	// BackendPools
	if source.BackendPools != nil {
		backendPoolList := make([]BackendPool, len(source.BackendPools))
		for backendPoolIndex, backendPoolItem := range source.BackendPools {
			// Shadow the loop variable to avoid aliasing
			backendPoolItem := backendPoolItem
			var backendPool BackendPool
			err := backendPool.AssignProperties_From_BackendPool(&backendPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendPool() to populate field BackendPools")
			}
			backendPoolList[backendPoolIndex] = backendPool
		}
		door.BackendPools = backendPoolList
	} else {
		door.BackendPools = nil
	}

	// BackendPoolsSettings
	if source.BackendPoolsSettings != nil {
		var backendPoolsSetting BackendPoolsSettings
		err := backendPoolsSetting.AssignProperties_From_BackendPoolsSettings(source.BackendPoolsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendPoolsSettings() to populate field BackendPoolsSettings")
		}
		door.BackendPoolsSettings = &backendPoolsSetting
	} else {
		door.BackendPoolsSettings = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := FrontDoorProperties_EnabledState(*source.EnabledState)
		door.EnabledState = &enabledState
	} else {
		door.EnabledState = nil
	}

	// FriendlyName
	door.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// FrontendEndpoints
	if source.FrontendEndpoints != nil {
		frontendEndpointList := make([]FrontendEndpoint, len(source.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range source.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint FrontendEndpoint
			err := frontendEndpoint.AssignProperties_From_FrontendEndpoint(&frontendEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendEndpoint() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		door.FrontendEndpoints = frontendEndpointList
	} else {
		door.FrontendEndpoints = nil
	}

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		healthProbeSettingList := make([]HealthProbeSettingsModel, len(source.HealthProbeSettings))
		for healthProbeSettingIndex, healthProbeSettingItem := range source.HealthProbeSettings {
			// Shadow the loop variable to avoid aliasing
			healthProbeSettingItem := healthProbeSettingItem
			var healthProbeSetting HealthProbeSettingsModel
			err := healthProbeSetting.AssignProperties_From_HealthProbeSettingsModel(&healthProbeSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HealthProbeSettingsModel() to populate field HealthProbeSettings")
			}
			healthProbeSettingList[healthProbeSettingIndex] = healthProbeSetting
		}
		door.HealthProbeSettings = healthProbeSettingList
	} else {
		door.HealthProbeSettings = nil
	}

	// LoadBalancingSettings
	if source.LoadBalancingSettings != nil {
		loadBalancingSettingList := make([]LoadBalancingSettingsModel, len(source.LoadBalancingSettings))
		for loadBalancingSettingIndex, loadBalancingSettingItem := range source.LoadBalancingSettings {
			// Shadow the loop variable to avoid aliasing
			loadBalancingSettingItem := loadBalancingSettingItem
			var loadBalancingSetting LoadBalancingSettingsModel
			err := loadBalancingSetting.AssignProperties_From_LoadBalancingSettingsModel(&loadBalancingSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingSettingsModel() to populate field LoadBalancingSettings")
			}
			loadBalancingSettingList[loadBalancingSettingIndex] = loadBalancingSetting
		}
		door.LoadBalancingSettings = loadBalancingSettingList
	} else {
		door.LoadBalancingSettings = nil
	}

	// Location
	door.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		door.Owner = &owner
	} else {
		door.Owner = nil
	}

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]RoutingRule, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule RoutingRule
			err := routingRule.AssignProperties_From_RoutingRule(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RoutingRule() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		door.RoutingRules = routingRuleList
	} else {
		door.RoutingRules = nil
	}

	// Tags
	door.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_FrontDoor_Spec populates the provided destination FrontDoor_Spec from our FrontDoor_Spec
func (door *FrontDoor_Spec) AssignProperties_To_FrontDoor_Spec(destination *v20210601s.FrontDoor_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = door.AzureName

	// BackendPools
	if door.BackendPools != nil {
		backendPoolList := make([]v20210601s.BackendPool, len(door.BackendPools))
		for backendPoolIndex, backendPoolItem := range door.BackendPools {
			// Shadow the loop variable to avoid aliasing
			backendPoolItem := backendPoolItem
			var backendPool v20210601s.BackendPool
			err := backendPoolItem.AssignProperties_To_BackendPool(&backendPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendPool() to populate field BackendPools")
			}
			backendPoolList[backendPoolIndex] = backendPool
		}
		destination.BackendPools = backendPoolList
	} else {
		destination.BackendPools = nil
	}

	// BackendPoolsSettings
	if door.BackendPoolsSettings != nil {
		var backendPoolsSetting v20210601s.BackendPoolsSettings
		err := door.BackendPoolsSettings.AssignProperties_To_BackendPoolsSettings(&backendPoolsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendPoolsSettings() to populate field BackendPoolsSettings")
		}
		destination.BackendPoolsSettings = &backendPoolsSetting
	} else {
		destination.BackendPoolsSettings = nil
	}

	// EnabledState
	if door.EnabledState != nil {
		enabledState := string(*door.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(door.FriendlyName)

	// FrontendEndpoints
	if door.FrontendEndpoints != nil {
		frontendEndpointList := make([]v20210601s.FrontendEndpoint, len(door.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range door.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint v20210601s.FrontendEndpoint
			err := frontendEndpointItem.AssignProperties_To_FrontendEndpoint(&frontendEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendEndpoint() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		destination.FrontendEndpoints = frontendEndpointList
	} else {
		destination.FrontendEndpoints = nil
	}

	// HealthProbeSettings
	if door.HealthProbeSettings != nil {
		healthProbeSettingList := make([]v20210601s.HealthProbeSettingsModel, len(door.HealthProbeSettings))
		for healthProbeSettingIndex, healthProbeSettingItem := range door.HealthProbeSettings {
			// Shadow the loop variable to avoid aliasing
			healthProbeSettingItem := healthProbeSettingItem
			var healthProbeSetting v20210601s.HealthProbeSettingsModel
			err := healthProbeSettingItem.AssignProperties_To_HealthProbeSettingsModel(&healthProbeSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HealthProbeSettingsModel() to populate field HealthProbeSettings")
			}
			healthProbeSettingList[healthProbeSettingIndex] = healthProbeSetting
		}
		destination.HealthProbeSettings = healthProbeSettingList
	} else {
		destination.HealthProbeSettings = nil
	}

	// LoadBalancingSettings
	if door.LoadBalancingSettings != nil {
		loadBalancingSettingList := make([]v20210601s.LoadBalancingSettingsModel, len(door.LoadBalancingSettings))
		for loadBalancingSettingIndex, loadBalancingSettingItem := range door.LoadBalancingSettings {
			// Shadow the loop variable to avoid aliasing
			loadBalancingSettingItem := loadBalancingSettingItem
			var loadBalancingSetting v20210601s.LoadBalancingSettingsModel
			err := loadBalancingSettingItem.AssignProperties_To_LoadBalancingSettingsModel(&loadBalancingSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingSettingsModel() to populate field LoadBalancingSettings")
			}
			loadBalancingSettingList[loadBalancingSettingIndex] = loadBalancingSetting
		}
		destination.LoadBalancingSettings = loadBalancingSettingList
	} else {
		destination.LoadBalancingSettings = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(door.Location)

	// OriginalVersion
	destination.OriginalVersion = door.OriginalVersion()

	// Owner
	if door.Owner != nil {
		owner := door.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RoutingRules
	if door.RoutingRules != nil {
		routingRuleList := make([]v20210601s.RoutingRule, len(door.RoutingRules))
		for routingRuleIndex, routingRuleItem := range door.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule v20210601s.RoutingRule
			err := routingRuleItem.AssignProperties_To_RoutingRule(&routingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RoutingRule() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		destination.RoutingRules = routingRuleList
	} else {
		destination.RoutingRules = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(door.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FrontDoor_STATUS populates our FrontDoor_Spec from the provided source FrontDoor_STATUS
func (door *FrontDoor_Spec) Initialize_From_FrontDoor_STATUS(source *FrontDoor_STATUS) error {

	// BackendPools
	if source.BackendPools != nil {
		backendPoolList := make([]BackendPool, len(source.BackendPools))
		for backendPoolIndex, backendPoolItem := range source.BackendPools {
			// Shadow the loop variable to avoid aliasing
			backendPoolItem := backendPoolItem
			var backendPool BackendPool
			err := backendPool.Initialize_From_BackendPool_STATUS(&backendPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_BackendPool_STATUS() to populate field BackendPools")
			}
			backendPoolList[backendPoolIndex] = backendPool
		}
		door.BackendPools = backendPoolList
	} else {
		door.BackendPools = nil
	}

	// BackendPoolsSettings
	if source.BackendPoolsSettings != nil {
		var backendPoolsSetting BackendPoolsSettings
		err := backendPoolsSetting.Initialize_From_BackendPoolsSettings_STATUS(source.BackendPoolsSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendPoolsSettings_STATUS() to populate field BackendPoolsSettings")
		}
		door.BackendPoolsSettings = &backendPoolsSetting
	} else {
		door.BackendPoolsSettings = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := FrontDoorProperties_EnabledState(*source.EnabledState)
		door.EnabledState = &enabledState
	} else {
		door.EnabledState = nil
	}

	// FriendlyName
	door.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// FrontendEndpoints
	if source.FrontendEndpoints != nil {
		frontendEndpointList := make([]FrontendEndpoint, len(source.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range source.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint FrontendEndpoint
			err := frontendEndpoint.Initialize_From_FrontendEndpoint_STATUS(&frontendEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_FrontendEndpoint_STATUS() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		door.FrontendEndpoints = frontendEndpointList
	} else {
		door.FrontendEndpoints = nil
	}

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		healthProbeSettingList := make([]HealthProbeSettingsModel, len(source.HealthProbeSettings))
		for healthProbeSettingIndex, healthProbeSettingItem := range source.HealthProbeSettings {
			// Shadow the loop variable to avoid aliasing
			healthProbeSettingItem := healthProbeSettingItem
			var healthProbeSetting HealthProbeSettingsModel
			err := healthProbeSetting.Initialize_From_HealthProbeSettingsModel_STATUS(&healthProbeSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_HealthProbeSettingsModel_STATUS() to populate field HealthProbeSettings")
			}
			healthProbeSettingList[healthProbeSettingIndex] = healthProbeSetting
		}
		door.HealthProbeSettings = healthProbeSettingList
	} else {
		door.HealthProbeSettings = nil
	}

	// LoadBalancingSettings
	if source.LoadBalancingSettings != nil {
		loadBalancingSettingList := make([]LoadBalancingSettingsModel, len(source.LoadBalancingSettings))
		for loadBalancingSettingIndex, loadBalancingSettingItem := range source.LoadBalancingSettings {
			// Shadow the loop variable to avoid aliasing
			loadBalancingSettingItem := loadBalancingSettingItem
			var loadBalancingSetting LoadBalancingSettingsModel
			err := loadBalancingSetting.Initialize_From_LoadBalancingSettingsModel_STATUS(&loadBalancingSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_LoadBalancingSettingsModel_STATUS() to populate field LoadBalancingSettings")
			}
			loadBalancingSettingList[loadBalancingSettingIndex] = loadBalancingSetting
		}
		door.LoadBalancingSettings = loadBalancingSettingList
	} else {
		door.LoadBalancingSettings = nil
	}

	// Location
	door.Location = genruntime.ClonePointerToString(source.Location)

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]RoutingRule, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule RoutingRule
			err := routingRule.Initialize_From_RoutingRule_STATUS(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_RoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		door.RoutingRules = routingRuleList
	} else {
		door.RoutingRules = nil
	}

	// Tags
	door.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (door *FrontDoor_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (door *FrontDoor_Spec) SetAzureName(azureName string) { door.AzureName = azureName }

// Front Door represents a collection of backend endpoints to route traffic to along with rules that specify how traffic is
// sent there.
type FrontDoor_STATUS struct {
	// BackendPools: Backend pools available to routing rules.
	BackendPools []BackendPool_STATUS `json:"backendPools,omitempty"`

	// BackendPoolsSettings: Settings for all backendPools
	BackendPoolsSettings *BackendPoolsSettings_STATUS `json:"backendPoolsSettings,omitempty"`

	// Cname: The host that each frontendEndpoint must CNAME to.
	Cname *string `json:"cname,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// EnabledState: Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *FrontDoorProperties_EnabledState_STATUS `json:"enabledState,omitempty"`

	// ExtendedProperties: Key-Value pair representing additional properties for frontdoor.
	ExtendedProperties map[string]string `json:"extendedProperties,omitempty"`

	// FriendlyName: A friendly name for the frontDoor
	FriendlyName *string `json:"friendlyName,omitempty"`

	// FrontdoorId: The Id of the frontdoor.
	FrontdoorId *string `json:"frontdoorId,omitempty"`

	// FrontendEndpoints: Frontend endpoints available to routing rules.
	FrontendEndpoints []FrontendEndpoint_STATUS `json:"frontendEndpoints,omitempty"`

	// HealthProbeSettings: Health probe settings associated with this Front Door instance.
	HealthProbeSettings []HealthProbeSettingsModel_STATUS `json:"healthProbeSettings,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// LoadBalancingSettings: Load balancing settings associated with this Front Door instance.
	LoadBalancingSettings []LoadBalancingSettingsModel_STATUS `json:"loadBalancingSettings,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: Provisioning state of the Front Door.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ResourceState: Resource status of the Front Door.
	ResourceState *ResourceState_STATUS `json:"resourceState,omitempty"`

	// RoutingRules: Routing rules associated with this Front Door.
	RoutingRules []RoutingRule_STATUS `json:"routingRules,omitempty"`

	// RulesEngines: Rules Engine Configurations available to routing rules.
	RulesEngines []RulesEngine_STATUS `json:"rulesEngines,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &FrontDoor_STATUS{}

// ConvertStatusFrom populates our FrontDoor_STATUS from the provided source
func (door *FrontDoor_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210601s.FrontDoor_STATUS)
	if ok {
		// Populate our instance from source
		return door.AssignProperties_From_FrontDoor_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.FrontDoor_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = door.AssignProperties_From_FrontDoor_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our FrontDoor_STATUS
func (door *FrontDoor_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210601s.FrontDoor_STATUS)
	if ok {
		// Populate destination from our instance
		return door.AssignProperties_To_FrontDoor_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.FrontDoor_STATUS{}
	err := door.AssignProperties_To_FrontDoor_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &FrontDoor_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (door *FrontDoor_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontDoor_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (door *FrontDoor_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontDoor_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontDoor_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackendPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendPools {
			var item1 BackendPool_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.BackendPools = append(door.BackendPools, item1)
		}
	}

	// Set property "BackendPoolsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPoolsSettings != nil {
			var backendPoolsSettings1 BackendPoolsSettings_STATUS
			err := backendPoolsSettings1.PopulateFromARM(owner, *typedInput.Properties.BackendPoolsSettings)
			if err != nil {
				return err
			}
			backendPoolsSettings := backendPoolsSettings1
			door.BackendPoolsSettings = &backendPoolsSettings
		}
	}

	// Set property "Cname":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Cname != nil {
			cname := *typedInput.Properties.Cname
			door.Cname = &cname
		}
	}

	// no assignment for property "Conditions"

	// Set property "EnabledState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledState != nil {
			enabledState := *typedInput.Properties.EnabledState
			door.EnabledState = &enabledState
		}
	}

	// Set property "ExtendedProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtendedProperties != nil {
			door.ExtendedProperties = make(map[string]string, len(typedInput.Properties.ExtendedProperties))
			for key, value := range typedInput.Properties.ExtendedProperties {
				door.ExtendedProperties[key] = value
			}
		}
	}

	// Set property "FriendlyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FriendlyName != nil {
			friendlyName := *typedInput.Properties.FriendlyName
			door.FriendlyName = &friendlyName
		}
	}

	// Set property "FrontdoorId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontdoorId != nil {
			frontdoorId := *typedInput.Properties.FrontdoorId
			door.FrontdoorId = &frontdoorId
		}
	}

	// Set property "FrontendEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendEndpoints {
			var item1 FrontendEndpoint_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.FrontendEndpoints = append(door.FrontendEndpoints, item1)
		}
	}

	// Set property "HealthProbeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HealthProbeSettings {
			var item1 HealthProbeSettingsModel_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.HealthProbeSettings = append(door.HealthProbeSettings, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		door.Id = &id
	}

	// Set property "LoadBalancingSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingSettings {
			var item1 LoadBalancingSettingsModel_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.LoadBalancingSettings = append(door.LoadBalancingSettings, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		door.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		door.Name = &name
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			door.ProvisioningState = &provisioningState
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			door.ResourceState = &resourceState
		}
	}

	// Set property "RoutingRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRules {
			var item1 RoutingRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.RoutingRules = append(door.RoutingRules, item1)
		}
	}

	// Set property "RulesEngines":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RulesEngines {
			var item1 RulesEngine_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			door.RulesEngines = append(door.RulesEngines, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		door.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			door.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		door.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_FrontDoor_STATUS populates our FrontDoor_STATUS from the provided source FrontDoor_STATUS
func (door *FrontDoor_STATUS) AssignProperties_From_FrontDoor_STATUS(source *v20210601s.FrontDoor_STATUS) error {

	// BackendPools
	if source.BackendPools != nil {
		backendPoolList := make([]BackendPool_STATUS, len(source.BackendPools))
		for backendPoolIndex, backendPoolItem := range source.BackendPools {
			// Shadow the loop variable to avoid aliasing
			backendPoolItem := backendPoolItem
			var backendPool BackendPool_STATUS
			err := backendPool.AssignProperties_From_BackendPool_STATUS(&backendPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackendPool_STATUS() to populate field BackendPools")
			}
			backendPoolList[backendPoolIndex] = backendPool
		}
		door.BackendPools = backendPoolList
	} else {
		door.BackendPools = nil
	}

	// BackendPoolsSettings
	if source.BackendPoolsSettings != nil {
		var backendPoolsSetting BackendPoolsSettings_STATUS
		err := backendPoolsSetting.AssignProperties_From_BackendPoolsSettings_STATUS(source.BackendPoolsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendPoolsSettings_STATUS() to populate field BackendPoolsSettings")
		}
		door.BackendPoolsSettings = &backendPoolsSetting
	} else {
		door.BackendPoolsSettings = nil
	}

	// Cname
	door.Cname = genruntime.ClonePointerToString(source.Cname)

	// Conditions
	door.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := FrontDoorProperties_EnabledState_STATUS(*source.EnabledState)
		door.EnabledState = &enabledState
	} else {
		door.EnabledState = nil
	}

	// ExtendedProperties
	door.ExtendedProperties = genruntime.CloneMapOfStringToString(source.ExtendedProperties)

	// FriendlyName
	door.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// FrontdoorId
	door.FrontdoorId = genruntime.ClonePointerToString(source.FrontdoorId)

	// FrontendEndpoints
	if source.FrontendEndpoints != nil {
		frontendEndpointList := make([]FrontendEndpoint_STATUS, len(source.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range source.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint FrontendEndpoint_STATUS
			err := frontendEndpoint.AssignProperties_From_FrontendEndpoint_STATUS(&frontendEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendEndpoint_STATUS() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		door.FrontendEndpoints = frontendEndpointList
	} else {
		door.FrontendEndpoints = nil
	}

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		healthProbeSettingList := make([]HealthProbeSettingsModel_STATUS, len(source.HealthProbeSettings))
		for healthProbeSettingIndex, healthProbeSettingItem := range source.HealthProbeSettings {
			// Shadow the loop variable to avoid aliasing
			healthProbeSettingItem := healthProbeSettingItem
			var healthProbeSetting HealthProbeSettingsModel_STATUS
			err := healthProbeSetting.AssignProperties_From_HealthProbeSettingsModel_STATUS(&healthProbeSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HealthProbeSettingsModel_STATUS() to populate field HealthProbeSettings")
			}
			healthProbeSettingList[healthProbeSettingIndex] = healthProbeSetting
		}
		door.HealthProbeSettings = healthProbeSettingList
	} else {
		door.HealthProbeSettings = nil
	}

	// Id
	door.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancingSettings
	if source.LoadBalancingSettings != nil {
		loadBalancingSettingList := make([]LoadBalancingSettingsModel_STATUS, len(source.LoadBalancingSettings))
		for loadBalancingSettingIndex, loadBalancingSettingItem := range source.LoadBalancingSettings {
			// Shadow the loop variable to avoid aliasing
			loadBalancingSettingItem := loadBalancingSettingItem
			var loadBalancingSetting LoadBalancingSettingsModel_STATUS
			err := loadBalancingSetting.AssignProperties_From_LoadBalancingSettingsModel_STATUS(&loadBalancingSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_LoadBalancingSettingsModel_STATUS() to populate field LoadBalancingSettings")
			}
			loadBalancingSettingList[loadBalancingSettingIndex] = loadBalancingSetting
		}
		door.LoadBalancingSettings = loadBalancingSettingList
	} else {
		door.LoadBalancingSettings = nil
	}

	// Location
	door.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	door.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	door.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ResourceState
	if source.ResourceState != nil {
		resourceState := ResourceState_STATUS(*source.ResourceState)
		door.ResourceState = &resourceState
	} else {
		door.ResourceState = nil
	}

	// RoutingRules
	if source.RoutingRules != nil {
		routingRuleList := make([]RoutingRule_STATUS, len(source.RoutingRules))
		for routingRuleIndex, routingRuleItem := range source.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule RoutingRule_STATUS
			err := routingRule.AssignProperties_From_RoutingRule_STATUS(&routingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		door.RoutingRules = routingRuleList
	} else {
		door.RoutingRules = nil
	}

	// RulesEngines
	if source.RulesEngines != nil {
		rulesEngineList := make([]RulesEngine_STATUS, len(source.RulesEngines))
		for rulesEngineIndex, rulesEngineItem := range source.RulesEngines {
			// Shadow the loop variable to avoid aliasing
			rulesEngineItem := rulesEngineItem
			var rulesEngine RulesEngine_STATUS
			err := rulesEngine.AssignProperties_From_RulesEngine_STATUS(&rulesEngineItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RulesEngine_STATUS() to populate field RulesEngines")
			}
			rulesEngineList[rulesEngineIndex] = rulesEngine
		}
		door.RulesEngines = rulesEngineList
	} else {
		door.RulesEngines = nil
	}

	// Tags
	door.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	door.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_FrontDoor_STATUS populates the provided destination FrontDoor_STATUS from our FrontDoor_STATUS
func (door *FrontDoor_STATUS) AssignProperties_To_FrontDoor_STATUS(destination *v20210601s.FrontDoor_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPools
	if door.BackendPools != nil {
		backendPoolList := make([]v20210601s.BackendPool_STATUS, len(door.BackendPools))
		for backendPoolIndex, backendPoolItem := range door.BackendPools {
			// Shadow the loop variable to avoid aliasing
			backendPoolItem := backendPoolItem
			var backendPool v20210601s.BackendPool_STATUS
			err := backendPoolItem.AssignProperties_To_BackendPool_STATUS(&backendPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackendPool_STATUS() to populate field BackendPools")
			}
			backendPoolList[backendPoolIndex] = backendPool
		}
		destination.BackendPools = backendPoolList
	} else {
		destination.BackendPools = nil
	}

	// BackendPoolsSettings
	if door.BackendPoolsSettings != nil {
		var backendPoolsSetting v20210601s.BackendPoolsSettings_STATUS
		err := door.BackendPoolsSettings.AssignProperties_To_BackendPoolsSettings_STATUS(&backendPoolsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendPoolsSettings_STATUS() to populate field BackendPoolsSettings")
		}
		destination.BackendPoolsSettings = &backendPoolsSetting
	} else {
		destination.BackendPoolsSettings = nil
	}

	// Cname
	destination.Cname = genruntime.ClonePointerToString(door.Cname)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(door.Conditions)

	// EnabledState
	if door.EnabledState != nil {
		enabledState := string(*door.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// ExtendedProperties
	destination.ExtendedProperties = genruntime.CloneMapOfStringToString(door.ExtendedProperties)

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(door.FriendlyName)

	// FrontdoorId
	destination.FrontdoorId = genruntime.ClonePointerToString(door.FrontdoorId)

	// FrontendEndpoints
	if door.FrontendEndpoints != nil {
		frontendEndpointList := make([]v20210601s.FrontendEndpoint_STATUS, len(door.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range door.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint v20210601s.FrontendEndpoint_STATUS
			err := frontendEndpointItem.AssignProperties_To_FrontendEndpoint_STATUS(&frontendEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendEndpoint_STATUS() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		destination.FrontendEndpoints = frontendEndpointList
	} else {
		destination.FrontendEndpoints = nil
	}

	// HealthProbeSettings
	if door.HealthProbeSettings != nil {
		healthProbeSettingList := make([]v20210601s.HealthProbeSettingsModel_STATUS, len(door.HealthProbeSettings))
		for healthProbeSettingIndex, healthProbeSettingItem := range door.HealthProbeSettings {
			// Shadow the loop variable to avoid aliasing
			healthProbeSettingItem := healthProbeSettingItem
			var healthProbeSetting v20210601s.HealthProbeSettingsModel_STATUS
			err := healthProbeSettingItem.AssignProperties_To_HealthProbeSettingsModel_STATUS(&healthProbeSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HealthProbeSettingsModel_STATUS() to populate field HealthProbeSettings")
			}
			healthProbeSettingList[healthProbeSettingIndex] = healthProbeSetting
		}
		destination.HealthProbeSettings = healthProbeSettingList
	} else {
		destination.HealthProbeSettings = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(door.Id)

	// LoadBalancingSettings
	if door.LoadBalancingSettings != nil {
		loadBalancingSettingList := make([]v20210601s.LoadBalancingSettingsModel_STATUS, len(door.LoadBalancingSettings))
		for loadBalancingSettingIndex, loadBalancingSettingItem := range door.LoadBalancingSettings {
			// Shadow the loop variable to avoid aliasing
			loadBalancingSettingItem := loadBalancingSettingItem
			var loadBalancingSetting v20210601s.LoadBalancingSettingsModel_STATUS
			err := loadBalancingSettingItem.AssignProperties_To_LoadBalancingSettingsModel_STATUS(&loadBalancingSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_LoadBalancingSettingsModel_STATUS() to populate field LoadBalancingSettings")
			}
			loadBalancingSettingList[loadBalancingSettingIndex] = loadBalancingSetting
		}
		destination.LoadBalancingSettings = loadBalancingSettingList
	} else {
		destination.LoadBalancingSettings = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(door.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(door.Name)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(door.ProvisioningState)

	// ResourceState
	if door.ResourceState != nil {
		resourceState := string(*door.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// RoutingRules
	if door.RoutingRules != nil {
		routingRuleList := make([]v20210601s.RoutingRule_STATUS, len(door.RoutingRules))
		for routingRuleIndex, routingRuleItem := range door.RoutingRules {
			// Shadow the loop variable to avoid aliasing
			routingRuleItem := routingRuleItem
			var routingRule v20210601s.RoutingRule_STATUS
			err := routingRuleItem.AssignProperties_To_RoutingRule_STATUS(&routingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RoutingRule_STATUS() to populate field RoutingRules")
			}
			routingRuleList[routingRuleIndex] = routingRule
		}
		destination.RoutingRules = routingRuleList
	} else {
		destination.RoutingRules = nil
	}

	// RulesEngines
	if door.RulesEngines != nil {
		rulesEngineList := make([]v20210601s.RulesEngine_STATUS, len(door.RulesEngines))
		for rulesEngineIndex, rulesEngineItem := range door.RulesEngines {
			// Shadow the loop variable to avoid aliasing
			rulesEngineItem := rulesEngineItem
			var rulesEngine v20210601s.RulesEngine_STATUS
			err := rulesEngineItem.AssignProperties_To_RulesEngine_STATUS(&rulesEngine)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RulesEngine_STATUS() to populate field RulesEngines")
			}
			rulesEngineList[rulesEngineIndex] = rulesEngine
		}
		destination.RulesEngines = rulesEngineList
	} else {
		destination.RulesEngines = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(door.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(door.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A backend pool is a collection of backends that can be routed to.
type BackendPool struct {
	// Backends: The set of backends for this pool
	Backends []Backend `json:"backends,omitempty"`

	// HealthProbeSettings: L7 health probe settings for a backend pool
	HealthProbeSettings *SubResource `json:"healthProbeSettings,omitempty"`

	// LoadBalancingSettings: Load balancing settings for a backend pool
	LoadBalancingSettings *SubResource `json:"loadBalancingSettings,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendPool{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *BackendPool) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &BackendPool_ARM{}

	// Set property "Name":
	if pool.Name != nil {
		name := *pool.Name
		result.Name = &name
	}

	// Set property "Properties":
	if pool.Backends != nil ||
		pool.HealthProbeSettings != nil ||
		pool.LoadBalancingSettings != nil {
		result.Properties = &BackendPoolProperties_ARM{}
	}
	for _, item := range pool.Backends {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Backends = append(result.Properties.Backends, *item_ARM.(*Backend_ARM))
	}
	if pool.HealthProbeSettings != nil {
		healthProbeSettings_ARM, err := (*pool.HealthProbeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbeSettings := *healthProbeSettings_ARM.(*SubResource_ARM)
		result.Properties.HealthProbeSettings = &healthProbeSettings
	}
	if pool.LoadBalancingSettings != nil {
		loadBalancingSettings_ARM, err := (*pool.LoadBalancingSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancingSettings := *loadBalancingSettings_ARM.(*SubResource_ARM)
		result.Properties.LoadBalancingSettings = &loadBalancingSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendPool) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendPool_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendPool) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendPool_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendPool_ARM, got %T", armInput)
	}

	// Set property "Backends":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Backends {
			var item1 Backend
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			pool.Backends = append(pool.Backends, item1)
		}
	}

	// Set property "HealthProbeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeSettings != nil {
			var healthProbeSettings1 SubResource
			err := healthProbeSettings1.PopulateFromARM(owner, *typedInput.Properties.HealthProbeSettings)
			if err != nil {
				return err
			}
			healthProbeSettings := healthProbeSettings1
			pool.HealthProbeSettings = &healthProbeSettings
		}
	}

	// Set property "LoadBalancingSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadBalancingSettings != nil {
			var loadBalancingSettings1 SubResource
			err := loadBalancingSettings1.PopulateFromARM(owner, *typedInput.Properties.LoadBalancingSettings)
			if err != nil {
				return err
			}
			loadBalancingSettings := loadBalancingSettings1
			pool.LoadBalancingSettings = &loadBalancingSettings
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPool populates our BackendPool from the provided source BackendPool
func (pool *BackendPool) AssignProperties_From_BackendPool(source *v20210601s.BackendPool) error {

	// Backends
	if source.Backends != nil {
		backendList := make([]Backend, len(source.Backends))
		for backendIndex, backendItem := range source.Backends {
			// Shadow the loop variable to avoid aliasing
			backendItem := backendItem
			var backend Backend
			err := backend.AssignProperties_From_Backend(&backendItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Backend() to populate field Backends")
			}
			backendList[backendIndex] = backend
		}
		pool.Backends = backendList
	} else {
		pool.Backends = nil
	}

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting SubResource
		err := healthProbeSetting.AssignProperties_From_SubResource(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HealthProbeSettings")
		}
		pool.HealthProbeSettings = &healthProbeSetting
	} else {
		pool.HealthProbeSettings = nil
	}

	// LoadBalancingSettings
	if source.LoadBalancingSettings != nil {
		var loadBalancingSetting SubResource
		err := loadBalancingSetting.AssignProperties_From_SubResource(source.LoadBalancingSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancingSettings")
		}
		pool.LoadBalancingSettings = &loadBalancingSetting
	} else {
		pool.LoadBalancingSettings = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_BackendPool populates the provided destination BackendPool from our BackendPool
func (pool *BackendPool) AssignProperties_To_BackendPool(destination *v20210601s.BackendPool) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Backends
	if pool.Backends != nil {
		backendList := make([]v20210601s.Backend, len(pool.Backends))
		for backendIndex, backendItem := range pool.Backends {
			// Shadow the loop variable to avoid aliasing
			backendItem := backendItem
			var backend v20210601s.Backend
			err := backendItem.AssignProperties_To_Backend(&backend)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Backend() to populate field Backends")
			}
			backendList[backendIndex] = backend
		}
		destination.Backends = backendList
	} else {
		destination.Backends = nil
	}

	// HealthProbeSettings
	if pool.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.SubResource
		err := pool.HealthProbeSettings.AssignProperties_To_SubResource(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// LoadBalancingSettings
	if pool.LoadBalancingSettings != nil {
		var loadBalancingSetting v20210601s.SubResource
		err := pool.LoadBalancingSettings.AssignProperties_To_SubResource(&loadBalancingSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancingSettings")
		}
		destination.LoadBalancingSettings = &loadBalancingSetting
	} else {
		destination.LoadBalancingSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendPool_STATUS populates our BackendPool from the provided source BackendPool_STATUS
func (pool *BackendPool) Initialize_From_BackendPool_STATUS(source *BackendPool_STATUS) error {

	// No error
	return nil
}

// A backend pool is a collection of backends that can be routed to.
type BackendPool_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendPool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendPool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendPool_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendPool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendPool_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendPool_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPool_STATUS populates our BackendPool_STATUS from the provided source BackendPool_STATUS
func (pool *BackendPool_STATUS) AssignProperties_From_BackendPool_STATUS(source *v20210601s.BackendPool_STATUS) error {

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_BackendPool_STATUS populates the provided destination BackendPool_STATUS from our BackendPool_STATUS
func (pool *BackendPool_STATUS) AssignProperties_To_BackendPool_STATUS(destination *v20210601s.BackendPool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings that apply to all backend pools.
type BackendPoolsSettings struct {
	// EnforceCertificateNameCheck: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect
	// on non-HTTPS requests.
	EnforceCertificateNameCheck *BackendPoolsSettings_EnforceCertificateNameCheck `json:"enforceCertificateNameCheck,omitempty"`

	// +kubebuilder:validation:Minimum=16
	// SendRecvTimeoutSeconds: Send and receive timeout on forwarding request to the backend. When timeout is reached, the
	// request fails and returns.
	SendRecvTimeoutSeconds *int `json:"sendRecvTimeoutSeconds,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendPoolsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *BackendPoolsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &BackendPoolsSettings_ARM{}

	// Set property "EnforceCertificateNameCheck":
	if settings.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := *settings.EnforceCertificateNameCheck
		result.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	}

	// Set property "SendRecvTimeoutSeconds":
	if settings.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSeconds := *settings.SendRecvTimeoutSeconds
		result.SendRecvTimeoutSeconds = &sendRecvTimeoutSeconds
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *BackendPoolsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendPoolsSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *BackendPoolsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendPoolsSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendPoolsSettings_ARM, got %T", armInput)
	}

	// Set property "EnforceCertificateNameCheck":
	if typedInput.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := *typedInput.EnforceCertificateNameCheck
		settings.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	}

	// Set property "SendRecvTimeoutSeconds":
	if typedInput.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSeconds := *typedInput.SendRecvTimeoutSeconds
		settings.SendRecvTimeoutSeconds = &sendRecvTimeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPoolsSettings populates our BackendPoolsSettings from the provided source BackendPoolsSettings
func (settings *BackendPoolsSettings) AssignProperties_From_BackendPoolsSettings(source *v20210601s.BackendPoolsSettings) error {

	// EnforceCertificateNameCheck
	if source.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := BackendPoolsSettings_EnforceCertificateNameCheck(*source.EnforceCertificateNameCheck)
		settings.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	} else {
		settings.EnforceCertificateNameCheck = nil
	}

	// SendRecvTimeoutSeconds
	if source.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSecond := *source.SendRecvTimeoutSeconds
		settings.SendRecvTimeoutSeconds = &sendRecvTimeoutSecond
	} else {
		settings.SendRecvTimeoutSeconds = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendPoolsSettings populates the provided destination BackendPoolsSettings from our BackendPoolsSettings
func (settings *BackendPoolsSettings) AssignProperties_To_BackendPoolsSettings(destination *v20210601s.BackendPoolsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnforceCertificateNameCheck
	if settings.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := string(*settings.EnforceCertificateNameCheck)
		destination.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	} else {
		destination.EnforceCertificateNameCheck = nil
	}

	// SendRecvTimeoutSeconds
	if settings.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSecond := *settings.SendRecvTimeoutSeconds
		destination.SendRecvTimeoutSeconds = &sendRecvTimeoutSecond
	} else {
		destination.SendRecvTimeoutSeconds = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendPoolsSettings_STATUS populates our BackendPoolsSettings from the provided source BackendPoolsSettings_STATUS
func (settings *BackendPoolsSettings) Initialize_From_BackendPoolsSettings_STATUS(source *BackendPoolsSettings_STATUS) error {

	// EnforceCertificateNameCheck
	if source.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := BackendPoolsSettings_EnforceCertificateNameCheck(*source.EnforceCertificateNameCheck)
		settings.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	} else {
		settings.EnforceCertificateNameCheck = nil
	}

	// SendRecvTimeoutSeconds
	if source.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSecond := *source.SendRecvTimeoutSeconds
		settings.SendRecvTimeoutSeconds = &sendRecvTimeoutSecond
	} else {
		settings.SendRecvTimeoutSeconds = nil
	}

	// No error
	return nil
}

// Settings that apply to all backend pools.
type BackendPoolsSettings_STATUS struct {
	// EnforceCertificateNameCheck: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect
	// on non-HTTPS requests.
	EnforceCertificateNameCheck *BackendPoolsSettings_EnforceCertificateNameCheck_STATUS `json:"enforceCertificateNameCheck,omitempty"`

	// SendRecvTimeoutSeconds: Send and receive timeout on forwarding request to the backend. When timeout is reached, the
	// request fails and returns.
	SendRecvTimeoutSeconds *int `json:"sendRecvTimeoutSeconds,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendPoolsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *BackendPoolsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendPoolsSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *BackendPoolsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendPoolsSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendPoolsSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "EnforceCertificateNameCheck":
	if typedInput.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := *typedInput.EnforceCertificateNameCheck
		settings.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	}

	// Set property "SendRecvTimeoutSeconds":
	if typedInput.SendRecvTimeoutSeconds != nil {
		sendRecvTimeoutSeconds := *typedInput.SendRecvTimeoutSeconds
		settings.SendRecvTimeoutSeconds = &sendRecvTimeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPoolsSettings_STATUS populates our BackendPoolsSettings_STATUS from the provided source BackendPoolsSettings_STATUS
func (settings *BackendPoolsSettings_STATUS) AssignProperties_From_BackendPoolsSettings_STATUS(source *v20210601s.BackendPoolsSettings_STATUS) error {

	// EnforceCertificateNameCheck
	if source.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := BackendPoolsSettings_EnforceCertificateNameCheck_STATUS(*source.EnforceCertificateNameCheck)
		settings.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	} else {
		settings.EnforceCertificateNameCheck = nil
	}

	// SendRecvTimeoutSeconds
	settings.SendRecvTimeoutSeconds = genruntime.ClonePointerToInt(source.SendRecvTimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_BackendPoolsSettings_STATUS populates the provided destination BackendPoolsSettings_STATUS from our BackendPoolsSettings_STATUS
func (settings *BackendPoolsSettings_STATUS) AssignProperties_To_BackendPoolsSettings_STATUS(destination *v20210601s.BackendPoolsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnforceCertificateNameCheck
	if settings.EnforceCertificateNameCheck != nil {
		enforceCertificateNameCheck := string(*settings.EnforceCertificateNameCheck)
		destination.EnforceCertificateNameCheck = &enforceCertificateNameCheck
	} else {
		destination.EnforceCertificateNameCheck = nil
	}

	// SendRecvTimeoutSeconds
	destination.SendRecvTimeoutSeconds = genruntime.ClonePointerToInt(settings.SendRecvTimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type FrontDoorProperties_EnabledState string

const (
	FrontDoorProperties_EnabledState_Disabled = FrontDoorProperties_EnabledState("Disabled")
	FrontDoorProperties_EnabledState_Enabled  = FrontDoorProperties_EnabledState("Enabled")
)

type FrontDoorProperties_EnabledState_STATUS string

const (
	FrontDoorProperties_EnabledState_STATUS_Disabled = FrontDoorProperties_EnabledState_STATUS("Disabled")
	FrontDoorProperties_EnabledState_STATUS_Enabled  = FrontDoorProperties_EnabledState_STATUS("Enabled")
)

// A frontend endpoint used for routing.
type FrontendEndpoint struct {
	// HostName: The host name of the frontendEndpoint. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// SessionAffinityEnabledState: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
	SessionAffinityEnabledState *FrontendEndpointProperties_SessionAffinityEnabledState `json:"sessionAffinityEnabledState,omitempty"`

	// SessionAffinityTtlSeconds: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if
	// applicable.
	SessionAffinityTtlSeconds *int `json:"sessionAffinityTtlSeconds,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for each host (if applicable)
	WebApplicationFirewallPolicyLink *FrontendEndpointProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontendEndpoint{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *FrontendEndpoint) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &FrontendEndpoint_ARM{}

	// Set property "Name":
	if endpoint.Name != nil {
		name := *endpoint.Name
		result.Name = &name
	}

	// Set property "Properties":
	if endpoint.HostName != nil ||
		endpoint.SessionAffinityEnabledState != nil ||
		endpoint.SessionAffinityTtlSeconds != nil ||
		endpoint.WebApplicationFirewallPolicyLink != nil {
		result.Properties = &FrontendEndpointProperties_ARM{}
	}
	if endpoint.HostName != nil {
		hostName := *endpoint.HostName
		result.Properties.HostName = &hostName
	}
	if endpoint.SessionAffinityEnabledState != nil {
		sessionAffinityEnabledState := *endpoint.SessionAffinityEnabledState
		result.Properties.SessionAffinityEnabledState = &sessionAffinityEnabledState
	}
	if endpoint.SessionAffinityTtlSeconds != nil {
		sessionAffinityTtlSeconds := *endpoint.SessionAffinityTtlSeconds
		result.Properties.SessionAffinityTtlSeconds = &sessionAffinityTtlSeconds
	}
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		webApplicationFirewallPolicyLink_ARM, err := (*endpoint.WebApplicationFirewallPolicyLink).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webApplicationFirewallPolicyLink := *webApplicationFirewallPolicyLink_ARM.(*FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM)
		result.Properties.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *FrontendEndpoint) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendEndpoint_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *FrontendEndpoint) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendEndpoint_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendEndpoint_ARM, got %T", armInput)
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			endpoint.HostName = &hostName
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "SessionAffinityEnabledState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SessionAffinityEnabledState != nil {
			sessionAffinityEnabledState := *typedInput.Properties.SessionAffinityEnabledState
			endpoint.SessionAffinityEnabledState = &sessionAffinityEnabledState
		}
	}

	// Set property "SessionAffinityTtlSeconds":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SessionAffinityTtlSeconds != nil {
			sessionAffinityTtlSeconds := *typedInput.Properties.SessionAffinityTtlSeconds
			endpoint.SessionAffinityTtlSeconds = &sessionAffinityTtlSeconds
		}
	}

	// Set property "WebApplicationFirewallPolicyLink":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 FrontendEndpointProperties_WebApplicationFirewallPolicyLink
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendEndpoint populates our FrontendEndpoint from the provided source FrontendEndpoint
func (endpoint *FrontendEndpoint) AssignProperties_From_FrontendEndpoint(source *v20210601s.FrontendEndpoint) error {

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// SessionAffinityEnabledState
	if source.SessionAffinityEnabledState != nil {
		sessionAffinityEnabledState := FrontendEndpointProperties_SessionAffinityEnabledState(*source.SessionAffinityEnabledState)
		endpoint.SessionAffinityEnabledState = &sessionAffinityEnabledState
	} else {
		endpoint.SessionAffinityEnabledState = nil
	}

	// SessionAffinityTtlSeconds
	endpoint.SessionAffinityTtlSeconds = genruntime.ClonePointerToInt(source.SessionAffinityTtlSeconds)

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink FrontendEndpointProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FrontendEndpoint populates the provided destination FrontendEndpoint from our FrontendEndpoint
func (endpoint *FrontendEndpoint) AssignProperties_To_FrontendEndpoint(destination *v20210601s.FrontendEndpoint) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// SessionAffinityEnabledState
	if endpoint.SessionAffinityEnabledState != nil {
		sessionAffinityEnabledState := string(*endpoint.SessionAffinityEnabledState)
		destination.SessionAffinityEnabledState = &sessionAffinityEnabledState
	} else {
		destination.SessionAffinityEnabledState = nil
	}

	// SessionAffinityTtlSeconds
	destination.SessionAffinityTtlSeconds = genruntime.ClonePointerToInt(endpoint.SessionAffinityTtlSeconds)

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.FrontendEndpointProperties_WebApplicationFirewallPolicyLink
		err := endpoint.WebApplicationFirewallPolicyLink.AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FrontendEndpoint_STATUS populates our FrontendEndpoint from the provided source FrontendEndpoint_STATUS
func (endpoint *FrontendEndpoint) Initialize_From_FrontendEndpoint_STATUS(source *FrontendEndpoint_STATUS) error {

	// No error
	return nil
}

// A frontend endpoint used for routing.
type FrontendEndpoint_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *FrontendEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendEndpoint_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *FrontendEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendEndpoint_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendEndpoint_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendEndpoint_STATUS populates our FrontendEndpoint_STATUS from the provided source FrontendEndpoint_STATUS
func (endpoint *FrontendEndpoint_STATUS) AssignProperties_From_FrontendEndpoint_STATUS(source *v20210601s.FrontendEndpoint_STATUS) error {

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_FrontendEndpoint_STATUS populates the provided destination FrontendEndpoint_STATUS from our FrontendEndpoint_STATUS
func (endpoint *FrontendEndpoint_STATUS) AssignProperties_To_FrontendEndpoint_STATUS(destination *v20210601s.FrontendEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Load balancing settings for a backend pool
type HealthProbeSettingsModel struct {
	// EnabledState: Whether to enable health probes to be made against backends defined under backendPools. Health probes can
	// only be disabled if there is a single enabled backend in single enabled backend pool.
	EnabledState *HealthProbeSettingsProperties_EnabledState `json:"enabledState,omitempty"`

	// HealthProbeMethod: Configures which HTTP method to use to probe the backends defined under backendPools.
	HealthProbeMethod *HealthProbeSettingsProperties_HealthProbeMethod `json:"healthProbeMethod,omitempty"`

	// IntervalInSeconds: The number of seconds between health probes.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// Path: The path to use for the health probe. Default is /
	Path *string `json:"path,omitempty"`

	// Protocol: Protocol scheme to use for this probe
	Protocol *HealthProbeSettingsProperties_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &HealthProbeSettingsModel{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (model *HealthProbeSettingsModel) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if model == nil {
		return nil, nil
	}
	result := &HealthProbeSettingsModel_ARM{}

	// Set property "Name":
	if model.Name != nil {
		name := *model.Name
		result.Name = &name
	}

	// Set property "Properties":
	if model.EnabledState != nil ||
		model.HealthProbeMethod != nil ||
		model.IntervalInSeconds != nil ||
		model.Path != nil ||
		model.Protocol != nil {
		result.Properties = &HealthProbeSettingsProperties_ARM{}
	}
	if model.EnabledState != nil {
		enabledState := *model.EnabledState
		result.Properties.EnabledState = &enabledState
	}
	if model.HealthProbeMethod != nil {
		healthProbeMethod := *model.HealthProbeMethod
		result.Properties.HealthProbeMethod = &healthProbeMethod
	}
	if model.IntervalInSeconds != nil {
		intervalInSeconds := *model.IntervalInSeconds
		result.Properties.IntervalInSeconds = &intervalInSeconds
	}
	if model.Path != nil {
		path := *model.Path
		result.Properties.Path = &path
	}
	if model.Protocol != nil {
		protocol := *model.Protocol
		result.Properties.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *HealthProbeSettingsModel) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HealthProbeSettingsModel_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *HealthProbeSettingsModel) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HealthProbeSettingsModel_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HealthProbeSettingsModel_ARM, got %T", armInput)
	}

	// Set property "EnabledState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledState != nil {
			enabledState := *typedInput.Properties.EnabledState
			model.EnabledState = &enabledState
		}
	}

	// Set property "HealthProbeMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeMethod != nil {
			healthProbeMethod := *typedInput.Properties.HealthProbeMethod
			model.HealthProbeMethod = &healthProbeMethod
		}
	}

	// Set property "IntervalInSeconds":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			model.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		model.Name = &name
	}

	// Set property "Path":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Path != nil {
			path := *typedInput.Properties.Path
			model.Path = &path
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			model.Protocol = &protocol
		}
	}

	// No error
	return nil
}

// AssignProperties_From_HealthProbeSettingsModel populates our HealthProbeSettingsModel from the provided source HealthProbeSettingsModel
func (model *HealthProbeSettingsModel) AssignProperties_From_HealthProbeSettingsModel(source *v20210601s.HealthProbeSettingsModel) error {

	// EnabledState
	if source.EnabledState != nil {
		enabledState := HealthProbeSettingsProperties_EnabledState(*source.EnabledState)
		model.EnabledState = &enabledState
	} else {
		model.EnabledState = nil
	}

	// HealthProbeMethod
	if source.HealthProbeMethod != nil {
		healthProbeMethod := HealthProbeSettingsProperties_HealthProbeMethod(*source.HealthProbeMethod)
		model.HealthProbeMethod = &healthProbeMethod
	} else {
		model.HealthProbeMethod = nil
	}

	// IntervalInSeconds
	model.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Name
	model.Name = genruntime.ClonePointerToString(source.Name)

	// Path
	model.Path = genruntime.ClonePointerToString(source.Path)

	// Protocol
	if source.Protocol != nil {
		protocol := HealthProbeSettingsProperties_Protocol(*source.Protocol)
		model.Protocol = &protocol
	} else {
		model.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeSettingsModel populates the provided destination HealthProbeSettingsModel from our HealthProbeSettingsModel
func (model *HealthProbeSettingsModel) AssignProperties_To_HealthProbeSettingsModel(destination *v20210601s.HealthProbeSettingsModel) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnabledState
	if model.EnabledState != nil {
		enabledState := string(*model.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// HealthProbeMethod
	if model.HealthProbeMethod != nil {
		healthProbeMethod := string(*model.HealthProbeMethod)
		destination.HealthProbeMethod = &healthProbeMethod
	} else {
		destination.HealthProbeMethod = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(model.IntervalInSeconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(model.Name)

	// Path
	destination.Path = genruntime.ClonePointerToString(model.Path)

	// Protocol
	if model.Protocol != nil {
		protocol := string(*model.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HealthProbeSettingsModel_STATUS populates our HealthProbeSettingsModel from the provided source HealthProbeSettingsModel_STATUS
func (model *HealthProbeSettingsModel) Initialize_From_HealthProbeSettingsModel_STATUS(source *HealthProbeSettingsModel_STATUS) error {

	// No error
	return nil
}

// Load balancing settings for a backend pool
type HealthProbeSettingsModel_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &HealthProbeSettingsModel_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *HealthProbeSettingsModel_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HealthProbeSettingsModel_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *HealthProbeSettingsModel_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HealthProbeSettingsModel_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HealthProbeSettingsModel_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		model.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_HealthProbeSettingsModel_STATUS populates our HealthProbeSettingsModel_STATUS from the provided source HealthProbeSettingsModel_STATUS
func (model *HealthProbeSettingsModel_STATUS) AssignProperties_From_HealthProbeSettingsModel_STATUS(source *v20210601s.HealthProbeSettingsModel_STATUS) error {

	// Id
	model.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_HealthProbeSettingsModel_STATUS populates the provided destination HealthProbeSettingsModel_STATUS from our HealthProbeSettingsModel_STATUS
func (model *HealthProbeSettingsModel_STATUS) AssignProperties_To_HealthProbeSettingsModel_STATUS(destination *v20210601s.HealthProbeSettingsModel_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(model.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Load balancing settings for a backend pool
type LoadBalancingSettingsModel struct {
	// AdditionalLatencyMilliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
	AdditionalLatencyMilliseconds *int `json:"additionalLatencyMilliseconds,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// SampleSize: The number of samples to consider for load balancing decisions
	SampleSize *int `json:"sampleSize,omitempty"`

	// SuccessfulSamplesRequired: The number of samples within the sample period that must succeed
	SuccessfulSamplesRequired *int `json:"successfulSamplesRequired,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancingSettingsModel{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (model *LoadBalancingSettingsModel) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if model == nil {
		return nil, nil
	}
	result := &LoadBalancingSettingsModel_ARM{}

	// Set property "Name":
	if model.Name != nil {
		name := *model.Name
		result.Name = &name
	}

	// Set property "Properties":
	if model.AdditionalLatencyMilliseconds != nil ||
		model.SampleSize != nil ||
		model.SuccessfulSamplesRequired != nil {
		result.Properties = &LoadBalancingSettingsProperties_ARM{}
	}
	if model.AdditionalLatencyMilliseconds != nil {
		additionalLatencyMilliseconds := *model.AdditionalLatencyMilliseconds
		result.Properties.AdditionalLatencyMilliseconds = &additionalLatencyMilliseconds
	}
	if model.SampleSize != nil {
		sampleSize := *model.SampleSize
		result.Properties.SampleSize = &sampleSize
	}
	if model.SuccessfulSamplesRequired != nil {
		successfulSamplesRequired := *model.SuccessfulSamplesRequired
		result.Properties.SuccessfulSamplesRequired = &successfulSamplesRequired
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *LoadBalancingSettingsModel) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingSettingsModel_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *LoadBalancingSettingsModel) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingSettingsModel_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingSettingsModel_ARM, got %T", armInput)
	}

	// Set property "AdditionalLatencyMilliseconds":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalLatencyMilliseconds != nil {
			additionalLatencyMilliseconds := *typedInput.Properties.AdditionalLatencyMilliseconds
			model.AdditionalLatencyMilliseconds = &additionalLatencyMilliseconds
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		model.Name = &name
	}

	// Set property "SampleSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SampleSize != nil {
			sampleSize := *typedInput.Properties.SampleSize
			model.SampleSize = &sampleSize
		}
	}

	// Set property "SuccessfulSamplesRequired":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuccessfulSamplesRequired != nil {
			successfulSamplesRequired := *typedInput.Properties.SuccessfulSamplesRequired
			model.SuccessfulSamplesRequired = &successfulSamplesRequired
		}
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancingSettingsModel populates our LoadBalancingSettingsModel from the provided source LoadBalancingSettingsModel
func (model *LoadBalancingSettingsModel) AssignProperties_From_LoadBalancingSettingsModel(source *v20210601s.LoadBalancingSettingsModel) error {

	// AdditionalLatencyMilliseconds
	model.AdditionalLatencyMilliseconds = genruntime.ClonePointerToInt(source.AdditionalLatencyMilliseconds)

	// Name
	model.Name = genruntime.ClonePointerToString(source.Name)

	// SampleSize
	model.SampleSize = genruntime.ClonePointerToInt(source.SampleSize)

	// SuccessfulSamplesRequired
	model.SuccessfulSamplesRequired = genruntime.ClonePointerToInt(source.SuccessfulSamplesRequired)

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingSettingsModel populates the provided destination LoadBalancingSettingsModel from our LoadBalancingSettingsModel
func (model *LoadBalancingSettingsModel) AssignProperties_To_LoadBalancingSettingsModel(destination *v20210601s.LoadBalancingSettingsModel) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalLatencyMilliseconds
	destination.AdditionalLatencyMilliseconds = genruntime.ClonePointerToInt(model.AdditionalLatencyMilliseconds)

	// Name
	destination.Name = genruntime.ClonePointerToString(model.Name)

	// SampleSize
	destination.SampleSize = genruntime.ClonePointerToInt(model.SampleSize)

	// SuccessfulSamplesRequired
	destination.SuccessfulSamplesRequired = genruntime.ClonePointerToInt(model.SuccessfulSamplesRequired)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LoadBalancingSettingsModel_STATUS populates our LoadBalancingSettingsModel from the provided source LoadBalancingSettingsModel_STATUS
func (model *LoadBalancingSettingsModel) Initialize_From_LoadBalancingSettingsModel_STATUS(source *LoadBalancingSettingsModel_STATUS) error {

	// No error
	return nil
}

// Load balancing settings for a backend pool
type LoadBalancingSettingsModel_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancingSettingsModel_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (model *LoadBalancingSettingsModel_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingSettingsModel_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (model *LoadBalancingSettingsModel_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingSettingsModel_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingSettingsModel_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		model.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_LoadBalancingSettingsModel_STATUS populates our LoadBalancingSettingsModel_STATUS from the provided source LoadBalancingSettingsModel_STATUS
func (model *LoadBalancingSettingsModel_STATUS) AssignProperties_From_LoadBalancingSettingsModel_STATUS(source *v20210601s.LoadBalancingSettingsModel_STATUS) error {

	// Id
	model.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_LoadBalancingSettingsModel_STATUS populates the provided destination LoadBalancingSettingsModel_STATUS from our LoadBalancingSettingsModel_STATUS
func (model *LoadBalancingSettingsModel_STATUS) AssignProperties_To_LoadBalancingSettingsModel_STATUS(destination *v20210601s.LoadBalancingSettingsModel_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(model.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceState_STATUS string

const (
	ResourceState_STATUS_Creating  = ResourceState_STATUS("Creating")
	ResourceState_STATUS_Deleting  = ResourceState_STATUS("Deleting")
	ResourceState_STATUS_Disabled  = ResourceState_STATUS("Disabled")
	ResourceState_STATUS_Disabling = ResourceState_STATUS("Disabling")
	ResourceState_STATUS_Enabled   = ResourceState_STATUS("Enabled")
	ResourceState_STATUS_Enabling  = ResourceState_STATUS("Enabling")
	ResourceState_STATUS_Migrated  = ResourceState_STATUS("Migrated")
	ResourceState_STATUS_Migrating = ResourceState_STATUS("Migrating")
)

// A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
type RoutingRule struct {
	// AcceptedProtocols: Protocol schemes to match for this rule
	AcceptedProtocols []RoutingRuleProperties_AcceptedProtocols `json:"acceptedProtocols,omitempty"`

	// EnabledState: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *RoutingRuleProperties_EnabledState `json:"enabledState,omitempty"`

	// FrontendEndpoints: Frontend endpoints associated with this rule
	FrontendEndpoints []SubResource `json:"frontendEndpoints,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PatternsToMatch: The route patterns of the rule.
	PatternsToMatch []string `json:"patternsToMatch,omitempty"`

	// RouteConfiguration: A reference to the routing configuration.
	RouteConfiguration *RouteConfiguration `json:"routeConfiguration,omitempty"`

	// RulesEngine: A reference to a specific Rules Engine Configuration to apply to this route.
	RulesEngine *SubResource `json:"rulesEngine,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for each routing rule (if applicable)
	WebApplicationFirewallPolicyLink *RoutingRuleProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *RoutingRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &RoutingRule_ARM{}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Properties":
	if rule.AcceptedProtocols != nil ||
		rule.EnabledState != nil ||
		rule.FrontendEndpoints != nil ||
		rule.PatternsToMatch != nil ||
		rule.RouteConfiguration != nil ||
		rule.RulesEngine != nil ||
		rule.WebApplicationFirewallPolicyLink != nil {
		result.Properties = &RoutingRuleProperties_ARM{}
	}
	for _, item := range rule.AcceptedProtocols {
		result.Properties.AcceptedProtocols = append(result.Properties.AcceptedProtocols, item)
	}
	if rule.EnabledState != nil {
		enabledState := *rule.EnabledState
		result.Properties.EnabledState = &enabledState
	}
	for _, item := range rule.FrontendEndpoints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendEndpoints = append(result.Properties.FrontendEndpoints, *item_ARM.(*SubResource_ARM))
	}
	for _, item := range rule.PatternsToMatch {
		result.Properties.PatternsToMatch = append(result.Properties.PatternsToMatch, item)
	}
	if rule.RouteConfiguration != nil {
		routeConfiguration_ARM, err := (*rule.RouteConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routeConfiguration := *routeConfiguration_ARM.(*RouteConfiguration_ARM)
		result.Properties.RouteConfiguration = &routeConfiguration
	}
	if rule.RulesEngine != nil {
		rulesEngine_ARM, err := (*rule.RulesEngine).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rulesEngine := *rulesEngine_ARM.(*SubResource_ARM)
		result.Properties.RulesEngine = &rulesEngine
	}
	if rule.WebApplicationFirewallPolicyLink != nil {
		webApplicationFirewallPolicyLink_ARM, err := (*rule.WebApplicationFirewallPolicyLink).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webApplicationFirewallPolicyLink := *webApplicationFirewallPolicyLink_ARM.(*RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM)
		result.Properties.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RoutingRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RoutingRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RoutingRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RoutingRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RoutingRule_ARM, got %T", armInput)
	}

	// Set property "AcceptedProtocols":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AcceptedProtocols {
			rule.AcceptedProtocols = append(rule.AcceptedProtocols, item)
		}
	}

	// Set property "EnabledState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnabledState != nil {
			enabledState := *typedInput.Properties.EnabledState
			rule.EnabledState = &enabledState
		}
	}

	// Set property "FrontendEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendEndpoints {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.FrontendEndpoints = append(rule.FrontendEndpoints, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "PatternsToMatch":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PatternsToMatch {
			rule.PatternsToMatch = append(rule.PatternsToMatch, item)
		}
	}

	// Set property "RouteConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RouteConfiguration != nil {
			var routeConfiguration1 RouteConfiguration
			err := routeConfiguration1.PopulateFromARM(owner, *typedInput.Properties.RouteConfiguration)
			if err != nil {
				return err
			}
			routeConfiguration := routeConfiguration1
			rule.RouteConfiguration = &routeConfiguration
		}
	}

	// Set property "RulesEngine":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RulesEngine != nil {
			var rulesEngine1 SubResource
			err := rulesEngine1.PopulateFromARM(owner, *typedInput.Properties.RulesEngine)
			if err != nil {
				return err
			}
			rulesEngine := rulesEngine1
			rule.RulesEngine = &rulesEngine
		}
	}

	// Set property "WebApplicationFirewallPolicyLink":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 RoutingRuleProperties_WebApplicationFirewallPolicyLink
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			rule.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingRule populates our RoutingRule from the provided source RoutingRule
func (rule *RoutingRule) AssignProperties_From_RoutingRule(source *v20210601s.RoutingRule) error {

	// AcceptedProtocols
	if source.AcceptedProtocols != nil {
		acceptedProtocolList := make([]RoutingRuleProperties_AcceptedProtocols, len(source.AcceptedProtocols))
		for acceptedProtocolIndex, acceptedProtocolItem := range source.AcceptedProtocols {
			// Shadow the loop variable to avoid aliasing
			acceptedProtocolItem := acceptedProtocolItem
			acceptedProtocolList[acceptedProtocolIndex] = RoutingRuleProperties_AcceptedProtocols(acceptedProtocolItem)
		}
		rule.AcceptedProtocols = acceptedProtocolList
	} else {
		rule.AcceptedProtocols = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := RoutingRuleProperties_EnabledState(*source.EnabledState)
		rule.EnabledState = &enabledState
	} else {
		rule.EnabledState = nil
	}

	// FrontendEndpoints
	if source.FrontendEndpoints != nil {
		frontendEndpointList := make([]SubResource, len(source.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range source.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint SubResource
			err := frontendEndpoint.AssignProperties_From_SubResource(&frontendEndpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		rule.FrontendEndpoints = frontendEndpointList
	} else {
		rule.FrontendEndpoints = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// PatternsToMatch
	rule.PatternsToMatch = genruntime.CloneSliceOfString(source.PatternsToMatch)

	// RouteConfiguration
	if source.RouteConfiguration != nil {
		var routeConfiguration RouteConfiguration
		err := routeConfiguration.AssignProperties_From_RouteConfiguration(source.RouteConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfiguration() to populate field RouteConfiguration")
		}
		rule.RouteConfiguration = &routeConfiguration
	} else {
		rule.RouteConfiguration = nil
	}

	// RulesEngine
	if source.RulesEngine != nil {
		var rulesEngine SubResource
		err := rulesEngine.AssignProperties_From_SubResource(source.RulesEngine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field RulesEngine")
		}
		rule.RulesEngine = &rulesEngine
	} else {
		rule.RulesEngine = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink RoutingRuleProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		rule.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		rule.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingRule populates the provided destination RoutingRule from our RoutingRule
func (rule *RoutingRule) AssignProperties_To_RoutingRule(destination *v20210601s.RoutingRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcceptedProtocols
	if rule.AcceptedProtocols != nil {
		acceptedProtocolList := make([]string, len(rule.AcceptedProtocols))
		for acceptedProtocolIndex, acceptedProtocolItem := range rule.AcceptedProtocols {
			// Shadow the loop variable to avoid aliasing
			acceptedProtocolItem := acceptedProtocolItem
			acceptedProtocolList[acceptedProtocolIndex] = string(acceptedProtocolItem)
		}
		destination.AcceptedProtocols = acceptedProtocolList
	} else {
		destination.AcceptedProtocols = nil
	}

	// EnabledState
	if rule.EnabledState != nil {
		enabledState := string(*rule.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// FrontendEndpoints
	if rule.FrontendEndpoints != nil {
		frontendEndpointList := make([]v20210601s.SubResource, len(rule.FrontendEndpoints))
		for frontendEndpointIndex, frontendEndpointItem := range rule.FrontendEndpoints {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointItem := frontendEndpointItem
			var frontendEndpoint v20210601s.SubResource
			err := frontendEndpointItem.AssignProperties_To_SubResource(&frontendEndpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FrontendEndpoints")
			}
			frontendEndpointList[frontendEndpointIndex] = frontendEndpoint
		}
		destination.FrontendEndpoints = frontendEndpointList
	} else {
		destination.FrontendEndpoints = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// PatternsToMatch
	destination.PatternsToMatch = genruntime.CloneSliceOfString(rule.PatternsToMatch)

	// RouteConfiguration
	if rule.RouteConfiguration != nil {
		var routeConfiguration v20210601s.RouteConfiguration
		err := rule.RouteConfiguration.AssignProperties_To_RouteConfiguration(&routeConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfiguration() to populate field RouteConfiguration")
		}
		destination.RouteConfiguration = &routeConfiguration
	} else {
		destination.RouteConfiguration = nil
	}

	// RulesEngine
	if rule.RulesEngine != nil {
		var rulesEngine v20210601s.SubResource
		err := rule.RulesEngine.AssignProperties_To_SubResource(&rulesEngine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field RulesEngine")
		}
		destination.RulesEngine = &rulesEngine
	} else {
		destination.RulesEngine = nil
	}

	// WebApplicationFirewallPolicyLink
	if rule.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.RoutingRuleProperties_WebApplicationFirewallPolicyLink
		err := rule.WebApplicationFirewallPolicyLink.AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingRule_STATUS populates our RoutingRule from the provided source RoutingRule_STATUS
func (rule *RoutingRule) Initialize_From_RoutingRule_STATUS(source *RoutingRule_STATUS) error {

	// No error
	return nil
}

// A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
type RoutingRule_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RoutingRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RoutingRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RoutingRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RoutingRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RoutingRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingRule_STATUS populates our RoutingRule_STATUS from the provided source RoutingRule_STATUS
func (rule *RoutingRule_STATUS) AssignProperties_From_RoutingRule_STATUS(source *v20210601s.RoutingRule_STATUS) error {

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_RoutingRule_STATUS populates the provided destination RoutingRule_STATUS from our RoutingRule_STATUS
func (rule *RoutingRule_STATUS) AssignProperties_To_RoutingRule_STATUS(destination *v20210601s.RoutingRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and
// response.
type RulesEngine_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &RulesEngine_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (engine *RulesEngine_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RulesEngine_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (engine *RulesEngine_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RulesEngine_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RulesEngine_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		engine.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_RulesEngine_STATUS populates our RulesEngine_STATUS from the provided source RulesEngine_STATUS
func (engine *RulesEngine_STATUS) AssignProperties_From_RulesEngine_STATUS(source *v20210601s.RulesEngine_STATUS) error {

	// Id
	engine.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_RulesEngine_STATUS populates the provided destination RulesEngine_STATUS from our RulesEngine_STATUS
func (engine *RulesEngine_STATUS) AssignProperties_To_RulesEngine_STATUS(destination *v20210601s.RulesEngine_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(engine.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend address of a frontDoor load balancer.
type Backend struct {
	// Address: Location of the backend (IP address or FQDN)
	Address *string `json:"address,omitempty"`

	// BackendHostHeader: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to
	// the incoming host.
	BackendHostHeader *string `json:"backendHostHeader,omitempty"`

	// EnabledState: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
	EnabledState *Backend_EnabledState `json:"enabledState,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpPort: The HTTP TCP port number. Must be between 1 and 65535.
	HttpPort *int `json:"httpPort,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpsPort: The HTTPS TCP port number. Must be between 1 and 65535.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// +kubebuilder:validation:Maximum=5
	// +kubebuilder:validation:Minimum=1
	// Priority: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower
	// priority backend is healthy.
	Priority *int `json:"priority,omitempty"`

	// PrivateLinkAlias: The Alias of the Private Link resource. Populating this optional field indicates that this backend is
	// 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// PrivateLinkApprovalMessage: A custom message to be included in the approval request to connect to the Private Link
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocation: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// PrivateLinkResourceReference: The Resource Id of the Private Link resource. Populating this optional field indicates
	// that this backend is 'Private'
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`

	// +kubebuilder:validation:Maximum=1000
	// +kubebuilder:validation:Minimum=1
	// Weight: Weight of this endpoint for load balancing purposes.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &Backend{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (backend *Backend) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if backend == nil {
		return nil, nil
	}
	result := &Backend_ARM{}

	// Set property "Address":
	if backend.Address != nil {
		address := *backend.Address
		result.Address = &address
	}

	// Set property "BackendHostHeader":
	if backend.BackendHostHeader != nil {
		backendHostHeader := *backend.BackendHostHeader
		result.BackendHostHeader = &backendHostHeader
	}

	// Set property "EnabledState":
	if backend.EnabledState != nil {
		enabledState := *backend.EnabledState
		result.EnabledState = &enabledState
	}

	// Set property "HttpPort":
	if backend.HttpPort != nil {
		httpPort := *backend.HttpPort
		result.HttpPort = &httpPort
	}

	// Set property "HttpsPort":
	if backend.HttpsPort != nil {
		httpsPort := *backend.HttpsPort
		result.HttpsPort = &httpsPort
	}

	// Set property "Priority":
	if backend.Priority != nil {
		priority := *backend.Priority
		result.Priority = &priority
	}

	// Set property "PrivateLinkAlias":
	if backend.PrivateLinkAlias != nil {
		privateLinkAlias := *backend.PrivateLinkAlias
		result.PrivateLinkAlias = &privateLinkAlias
	}

	// Set property "PrivateLinkApprovalMessage":
	if backend.PrivateLinkApprovalMessage != nil {
		privateLinkApprovalMessage := *backend.PrivateLinkApprovalMessage
		result.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
	}

	// Set property "PrivateLinkLocation":
	if backend.PrivateLinkLocation != nil {
		privateLinkLocation := *backend.PrivateLinkLocation
		result.PrivateLinkLocation = &privateLinkLocation
	}

	// Set property "PrivateLinkResourceId":
	if backend.PrivateLinkResourceReference != nil {
		privateLinkResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*backend.PrivateLinkResourceReference)
		if err != nil {
			return nil, err
		}
		privateLinkResourceReference := privateLinkResourceReferenceARMID
		result.PrivateLinkResourceId = &privateLinkResourceReference
	}

	// Set property "Weight":
	if backend.Weight != nil {
		weight := *backend.Weight
		result.Weight = &weight
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backend *Backend) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Backend_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backend *Backend) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Backend_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Backend_ARM, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		backend.Address = &address
	}

	// Set property "BackendHostHeader":
	if typedInput.BackendHostHeader != nil {
		backendHostHeader := *typedInput.BackendHostHeader
		backend.BackendHostHeader = &backendHostHeader
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		backend.EnabledState = &enabledState
	}

	// Set property "HttpPort":
	if typedInput.HttpPort != nil {
		httpPort := *typedInput.HttpPort
		backend.HttpPort = &httpPort
	}

	// Set property "HttpsPort":
	if typedInput.HttpsPort != nil {
		httpsPort := *typedInput.HttpsPort
		backend.HttpsPort = &httpsPort
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		backend.Priority = &priority
	}

	// Set property "PrivateLinkAlias":
	if typedInput.PrivateLinkAlias != nil {
		privateLinkAlias := *typedInput.PrivateLinkAlias
		backend.PrivateLinkAlias = &privateLinkAlias
	}

	// Set property "PrivateLinkApprovalMessage":
	if typedInput.PrivateLinkApprovalMessage != nil {
		privateLinkApprovalMessage := *typedInput.PrivateLinkApprovalMessage
		backend.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
	}

	// Set property "PrivateLinkLocation":
	if typedInput.PrivateLinkLocation != nil {
		privateLinkLocation := *typedInput.PrivateLinkLocation
		backend.PrivateLinkLocation = &privateLinkLocation
	}

	// no assignment for property "PrivateLinkResourceReference"

	// Set property "Weight":
	if typedInput.Weight != nil {
		weight := *typedInput.Weight
		backend.Weight = &weight
	}

	// No error
	return nil
}

// AssignProperties_From_Backend populates our Backend from the provided source Backend
func (backend *Backend) AssignProperties_From_Backend(source *v20210601s.Backend) error {

	// Address
	backend.Address = genruntime.ClonePointerToString(source.Address)

	// BackendHostHeader
	backend.BackendHostHeader = genruntime.ClonePointerToString(source.BackendHostHeader)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := Backend_EnabledState(*source.EnabledState)
		backend.EnabledState = &enabledState
	} else {
		backend.EnabledState = nil
	}

	// HttpPort
	if source.HttpPort != nil {
		httpPort := *source.HttpPort
		backend.HttpPort = &httpPort
	} else {
		backend.HttpPort = nil
	}

	// HttpsPort
	if source.HttpsPort != nil {
		httpsPort := *source.HttpsPort
		backend.HttpsPort = &httpsPort
	} else {
		backend.HttpsPort = nil
	}

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		backend.Priority = &priority
	} else {
		backend.Priority = nil
	}

	// PrivateLinkAlias
	backend.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	backend.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	backend.PrivateLinkLocation = genruntime.ClonePointerToString(source.PrivateLinkLocation)

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		backend.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		backend.PrivateLinkResourceReference = nil
	}

	// Weight
	if source.Weight != nil {
		weight := *source.Weight
		backend.Weight = &weight
	} else {
		backend.Weight = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Backend populates the provided destination Backend from our Backend
func (backend *Backend) AssignProperties_To_Backend(destination *v20210601s.Backend) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(backend.Address)

	// BackendHostHeader
	destination.BackendHostHeader = genruntime.ClonePointerToString(backend.BackendHostHeader)

	// EnabledState
	if backend.EnabledState != nil {
		enabledState := string(*backend.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// HttpPort
	if backend.HttpPort != nil {
		httpPort := *backend.HttpPort
		destination.HttpPort = &httpPort
	} else {
		destination.HttpPort = nil
	}

	// HttpsPort
	if backend.HttpsPort != nil {
		httpsPort := *backend.HttpsPort
		destination.HttpsPort = &httpsPort
	} else {
		destination.HttpsPort = nil
	}

	// Priority
	if backend.Priority != nil {
		priority := *backend.Priority
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(backend.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(backend.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	destination.PrivateLinkLocation = genruntime.ClonePointerToString(backend.PrivateLinkLocation)

	// PrivateLinkResourceReference
	if backend.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := backend.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// Weight
	if backend.Weight != nil {
		weight := *backend.Weight
		destination.Weight = &weight
	} else {
		destination.Weight = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type BackendPoolsSettings_EnforceCertificateNameCheck string

const (
	BackendPoolsSettings_EnforceCertificateNameCheck_Disabled = BackendPoolsSettings_EnforceCertificateNameCheck("Disabled")
	BackendPoolsSettings_EnforceCertificateNameCheck_Enabled  = BackendPoolsSettings_EnforceCertificateNameCheck("Enabled")
)

type BackendPoolsSettings_EnforceCertificateNameCheck_STATUS string

const (
	BackendPoolsSettings_EnforceCertificateNameCheck_STATUS_Disabled = BackendPoolsSettings_EnforceCertificateNameCheck_STATUS("Disabled")
	BackendPoolsSettings_EnforceCertificateNameCheck_STATUS_Enabled  = BackendPoolsSettings_EnforceCertificateNameCheck_STATUS("Enabled")
)

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type FrontendEndpointProperties_SessionAffinityEnabledState string

const (
	FrontendEndpointProperties_SessionAffinityEnabledState_Disabled = FrontendEndpointProperties_SessionAffinityEnabledState("Disabled")
	FrontendEndpointProperties_SessionAffinityEnabledState_Enabled  = FrontendEndpointProperties_SessionAffinityEnabledState("Enabled")
)

type FrontendEndpointProperties_WebApplicationFirewallPolicyLink struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontendEndpointProperties_WebApplicationFirewallPolicyLink{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (link *FrontendEndpointProperties_WebApplicationFirewallPolicyLink) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if link == nil {
		return nil, nil
	}
	result := &FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM{}

	// Set property "Id":
	if link.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*link.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *FrontendEndpointProperties_WebApplicationFirewallPolicyLink) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *FrontendEndpointProperties_WebApplicationFirewallPolicyLink) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink populates our FrontendEndpointProperties_WebApplicationFirewallPolicyLink from the provided source FrontendEndpointProperties_WebApplicationFirewallPolicyLink
func (link *FrontendEndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(source *v20210601s.FrontendEndpointProperties_WebApplicationFirewallPolicyLink) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink populates the provided destination FrontendEndpointProperties_WebApplicationFirewallPolicyLink from our FrontendEndpointProperties_WebApplicationFirewallPolicyLink
func (link *FrontendEndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(destination *v20210601s.FrontendEndpointProperties_WebApplicationFirewallPolicyLink) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if link.Reference != nil {
		reference := link.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type HealthProbeSettingsProperties_EnabledState string

const (
	HealthProbeSettingsProperties_EnabledState_Disabled = HealthProbeSettingsProperties_EnabledState("Disabled")
	HealthProbeSettingsProperties_EnabledState_Enabled  = HealthProbeSettingsProperties_EnabledState("Enabled")
)

// +kubebuilder:validation:Enum={"GET","HEAD"}
type HealthProbeSettingsProperties_HealthProbeMethod string

const (
	HealthProbeSettingsProperties_HealthProbeMethod_GET  = HealthProbeSettingsProperties_HealthProbeMethod("GET")
	HealthProbeSettingsProperties_HealthProbeMethod_HEAD = HealthProbeSettingsProperties_HealthProbeMethod("HEAD")
)

// +kubebuilder:validation:Enum={"Http","Https"}
type HealthProbeSettingsProperties_Protocol string

const (
	HealthProbeSettingsProperties_Protocol_Http  = HealthProbeSettingsProperties_Protocol("Http")
	HealthProbeSettingsProperties_Protocol_Https = HealthProbeSettingsProperties_Protocol("Https")
)

type RouteConfiguration struct {
	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding: Mutually exclusive with all other properties
	MicrosoftAzureFrontDoorModelsFrontdoorForwarding *ForwardingConfiguration `json:"microsoftAzureFrontDoorModelsFrontdoorForwardingConfiguration,omitempty"`

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect: Mutually exclusive with all other properties
	MicrosoftAzureFrontDoorModelsFrontdoorRedirect *RedirectConfiguration `json:"microsoftAzureFrontDoorModelsFrontdoorRedirectConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &RouteConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *RouteConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &RouteConfiguration_ARM{}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorForwarding":
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		microsoftAzureFrontDoorModelsFrontdoorForwarding_ARM, err := (*configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		microsoftAzureFrontDoorModelsFrontdoorForwarding := *microsoftAzureFrontDoorModelsFrontdoorForwarding_ARM.(*ForwardingConfiguration_ARM)
		result.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorRedirect":
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		microsoftAzureFrontDoorModelsFrontdoorRedirect_ARM, err := (*configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		microsoftAzureFrontDoorModelsFrontdoorRedirect := *microsoftAzureFrontDoorModelsFrontdoorRedirect_ARM.(*RedirectConfiguration_ARM)
		result.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *RouteConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RouteConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *RouteConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RouteConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RouteConfiguration_ARM, got %T", armInput)
	}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorForwarding":
	if typedInput.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding1 ForwardingConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorForwarding1.PopulateFromARM(owner, *typedInput.MicrosoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return err
		}
		microsoftAzureFrontDoorModelsFrontdoorForwarding := microsoftAzureFrontDoorModelsFrontdoorForwarding1
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorRedirect":
	if typedInput.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect1 RedirectConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorRedirect1.PopulateFromARM(owner, *typedInput.MicrosoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return err
		}
		microsoftAzureFrontDoorModelsFrontdoorRedirect := microsoftAzureFrontDoorModelsFrontdoorRedirect1
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfiguration populates our RouteConfiguration from the provided source RouteConfiguration
func (configuration *RouteConfiguration) AssignProperties_From_RouteConfiguration(source *v20210601s.RouteConfiguration) error {

	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding
	if source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding ForwardingConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorForwarding.AssignProperties_From_ForwardingConfiguration(source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ForwardingConfiguration() to populate field MicrosoftAzureFrontDoorModelsFrontdoorForwarding")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = nil
	}

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect
	if source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect RedirectConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorRedirect.AssignProperties_From_RedirectConfiguration(source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RedirectConfiguration() to populate field MicrosoftAzureFrontDoorModelsFrontdoorRedirect")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfiguration populates the provided destination RouteConfiguration from our RouteConfiguration
func (configuration *RouteConfiguration) AssignProperties_To_RouteConfiguration(destination *v20210601s.RouteConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding v20210601s.ForwardingConfiguration
		err := configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding.AssignProperties_To_ForwardingConfiguration(&microsoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ForwardingConfiguration() to populate field MicrosoftAzureFrontDoorModelsFrontdoorForwarding")
		}
		destination.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	} else {
		destination.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = nil
	}

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect v20210601s.RedirectConfiguration
		err := configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect.AssignProperties_To_RedirectConfiguration(&microsoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RedirectConfiguration() to populate field MicrosoftAzureFrontDoorModelsFrontdoorRedirect")
		}
		destination.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	} else {
		destination.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RouteConfiguration_STATUS populates our RouteConfiguration from the provided source RouteConfiguration_STATUS
func (configuration *RouteConfiguration) Initialize_From_RouteConfiguration_STATUS(source *RouteConfiguration_STATUS) error {

	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding
	if source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding ForwardingConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorForwarding.Initialize_From_ForwardingConfiguration_STATUS(source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ForwardingConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorForwarding")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = nil
	}

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect
	if source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect RedirectConfiguration
		err := microsoftAzureFrontDoorModelsFrontdoorRedirect.Initialize_From_RedirectConfiguration_STATUS(source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RedirectConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorRedirect")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Http","Https"}
type RoutingRuleProperties_AcceptedProtocols string

const (
	RoutingRuleProperties_AcceptedProtocols_Http  = RoutingRuleProperties_AcceptedProtocols("Http")
	RoutingRuleProperties_AcceptedProtocols_Https = RoutingRuleProperties_AcceptedProtocols("Https")
)

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type RoutingRuleProperties_EnabledState string

const (
	RoutingRuleProperties_EnabledState_Disabled = RoutingRuleProperties_EnabledState("Disabled")
	RoutingRuleProperties_EnabledState_Enabled  = RoutingRuleProperties_EnabledState("Enabled")
)

type RoutingRuleProperties_WebApplicationFirewallPolicyLink struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingRuleProperties_WebApplicationFirewallPolicyLink{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (link *RoutingRuleProperties_WebApplicationFirewallPolicyLink) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if link == nil {
		return nil, nil
	}
	result := &RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM{}

	// Set property "Id":
	if link.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*link.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *RoutingRuleProperties_WebApplicationFirewallPolicyLink) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *RoutingRuleProperties_WebApplicationFirewallPolicyLink) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink populates our RoutingRuleProperties_WebApplicationFirewallPolicyLink from the provided source RoutingRuleProperties_WebApplicationFirewallPolicyLink
func (link *RoutingRuleProperties_WebApplicationFirewallPolicyLink) AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink(source *v20210601s.RoutingRuleProperties_WebApplicationFirewallPolicyLink) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink populates the provided destination RoutingRuleProperties_WebApplicationFirewallPolicyLink from our RoutingRuleProperties_WebApplicationFirewallPolicyLink
func (link *RoutingRuleProperties_WebApplicationFirewallPolicyLink) AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink(destination *v20210601s.RoutingRuleProperties_WebApplicationFirewallPolicyLink) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if link.Reference != nil {
		reference := link.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Reference to another subresource.
type SubResource struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &SubResource_ARM{}

	// Set property "Id":
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SubResource_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_SubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignProperties_From_SubResource(source *v20210601s.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignProperties_To_SubResource(destination *v20210601s.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SubResource_STATUS populates our SubResource from the provided source SubResource_STATUS
func (resource *SubResource) Initialize_From_SubResource_STATUS(source *SubResource_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type Backend_EnabledState string

const (
	Backend_EnabledState_Disabled = Backend_EnabledState("Disabled")
	Backend_EnabledState_Enabled  = Backend_EnabledState("Enabled")
)

type ForwardingConfiguration struct {
	// BackendPool: A reference to the BackendPool which this rule routes to.
	BackendPool *SubResource `json:"backendPool,omitempty"`

	// CacheConfiguration: The caching configuration associated with this rule.
	CacheConfiguration *CacheConfiguration `json:"cacheConfiguration,omitempty"`

	// CustomForwardingPath: A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming
	// path.
	CustomForwardingPath *string `json:"customForwardingPath,omitempty"`

	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *ForwardingConfiguration_ForwardingProtocol `json:"forwardingProtocol,omitempty"`

	// +kubebuilder:validation:Required
	OdataType *ForwardingConfiguration_OdataType `json:"@odata.type,omitempty"`
}

var _ genruntime.ARMTransformer = &ForwardingConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ForwardingConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &ForwardingConfiguration_ARM{}

	// Set property "BackendPool":
	if configuration.BackendPool != nil {
		backendPool_ARM, err := (*configuration.BackendPool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		backendPool := *backendPool_ARM.(*SubResource_ARM)
		result.BackendPool = &backendPool
	}

	// Set property "CacheConfiguration":
	if configuration.CacheConfiguration != nil {
		cacheConfiguration_ARM, err := (*configuration.CacheConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheConfiguration := *cacheConfiguration_ARM.(*CacheConfiguration_ARM)
		result.CacheConfiguration = &cacheConfiguration
	}

	// Set property "CustomForwardingPath":
	if configuration.CustomForwardingPath != nil {
		customForwardingPath := *configuration.CustomForwardingPath
		result.CustomForwardingPath = &customForwardingPath
	}

	// Set property "ForwardingProtocol":
	if configuration.ForwardingProtocol != nil {
		forwardingProtocol := *configuration.ForwardingProtocol
		result.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OdataType":
	if configuration.OdataType != nil {
		result.OdataType = *configuration.OdataType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ForwardingConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ForwardingConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ForwardingConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ForwardingConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ForwardingConfiguration_ARM, got %T", armInput)
	}

	// Set property "BackendPool":
	if typedInput.BackendPool != nil {
		var backendPool1 SubResource
		err := backendPool1.PopulateFromARM(owner, *typedInput.BackendPool)
		if err != nil {
			return err
		}
		backendPool := backendPool1
		configuration.BackendPool = &backendPool
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		configuration.CacheConfiguration = &cacheConfiguration
	}

	// Set property "CustomForwardingPath":
	if typedInput.CustomForwardingPath != nil {
		customForwardingPath := *typedInput.CustomForwardingPath
		configuration.CustomForwardingPath = &customForwardingPath
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		forwardingProtocol := *typedInput.ForwardingProtocol
		configuration.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OdataType":
	configuration.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_ForwardingConfiguration populates our ForwardingConfiguration from the provided source ForwardingConfiguration
func (configuration *ForwardingConfiguration) AssignProperties_From_ForwardingConfiguration(source *v20210601s.ForwardingConfiguration) error {

	// BackendPool
	if source.BackendPool != nil {
		var backendPool SubResource
		err := backendPool.AssignProperties_From_SubResource(source.BackendPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BackendPool")
		}
		configuration.BackendPool = &backendPool
	} else {
		configuration.BackendPool = nil
	}

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration() to populate field CacheConfiguration")
		}
		configuration.CacheConfiguration = &cacheConfiguration
	} else {
		configuration.CacheConfiguration = nil
	}

	// CustomForwardingPath
	configuration.CustomForwardingPath = genruntime.ClonePointerToString(source.CustomForwardingPath)

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := ForwardingConfiguration_ForwardingProtocol(*source.ForwardingProtocol)
		configuration.ForwardingProtocol = &forwardingProtocol
	} else {
		configuration.ForwardingProtocol = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := ForwardingConfiguration_OdataType(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ForwardingConfiguration populates the provided destination ForwardingConfiguration from our ForwardingConfiguration
func (configuration *ForwardingConfiguration) AssignProperties_To_ForwardingConfiguration(destination *v20210601s.ForwardingConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPool
	if configuration.BackendPool != nil {
		var backendPool v20210601s.SubResource
		err := configuration.BackendPool.AssignProperties_To_SubResource(&backendPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BackendPool")
		}
		destination.BackendPool = &backendPool
	} else {
		destination.BackendPool = nil
	}

	// CacheConfiguration
	if configuration.CacheConfiguration != nil {
		var cacheConfiguration v20210601s.CacheConfiguration
		err := configuration.CacheConfiguration.AssignProperties_To_CacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// CustomForwardingPath
	destination.CustomForwardingPath = genruntime.ClonePointerToString(configuration.CustomForwardingPath)

	// ForwardingProtocol
	if configuration.ForwardingProtocol != nil {
		forwardingProtocol := string(*configuration.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OdataType
	if configuration.OdataType != nil {
		odataType := string(*configuration.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ForwardingConfiguration_STATUS populates our ForwardingConfiguration from the provided source ForwardingConfiguration_STATUS
func (configuration *ForwardingConfiguration) Initialize_From_ForwardingConfiguration_STATUS(source *ForwardingConfiguration_STATUS) error {

	// BackendPool
	if source.BackendPool != nil {
		var backendPool SubResource
		err := backendPool.Initialize_From_SubResource_STATUS(source.BackendPool)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field BackendPool")
		}
		configuration.BackendPool = &backendPool
	} else {
		configuration.BackendPool = nil
	}

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.Initialize_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		configuration.CacheConfiguration = &cacheConfiguration
	} else {
		configuration.CacheConfiguration = nil
	}

	// CustomForwardingPath
	configuration.CustomForwardingPath = genruntime.ClonePointerToString(source.CustomForwardingPath)

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := ForwardingConfiguration_ForwardingProtocol(*source.ForwardingProtocol)
		configuration.ForwardingProtocol = &forwardingProtocol
	} else {
		configuration.ForwardingProtocol = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := ForwardingConfiguration_OdataType(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// No error
	return nil
}

type RedirectConfiguration struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHost: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHost *string `json:"customHost,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// The first ? and & will be added automatically so do not include them in the front, but do separate multiple query
	// strings with &.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// +kubebuilder:validation:Required
	OdataType *RedirectConfiguration_OdataType `json:"@odata.type,omitempty"`

	// RedirectProtocol: The protocol of the destination to where the traffic is redirected
	RedirectProtocol *RedirectConfiguration_RedirectProtocol `json:"redirectProtocol,omitempty"`

	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *RedirectConfiguration_RedirectType `json:"redirectType,omitempty"`
}

var _ genruntime.ARMTransformer = &RedirectConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *RedirectConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &RedirectConfiguration_ARM{}

	// Set property "CustomFragment":
	if configuration.CustomFragment != nil {
		customFragment := *configuration.CustomFragment
		result.CustomFragment = &customFragment
	}

	// Set property "CustomHost":
	if configuration.CustomHost != nil {
		customHost := *configuration.CustomHost
		result.CustomHost = &customHost
	}

	// Set property "CustomPath":
	if configuration.CustomPath != nil {
		customPath := *configuration.CustomPath
		result.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if configuration.CustomQueryString != nil {
		customQueryString := *configuration.CustomQueryString
		result.CustomQueryString = &customQueryString
	}

	// Set property "OdataType":
	if configuration.OdataType != nil {
		result.OdataType = *configuration.OdataType
	}

	// Set property "RedirectProtocol":
	if configuration.RedirectProtocol != nil {
		redirectProtocol := *configuration.RedirectProtocol
		result.RedirectProtocol = &redirectProtocol
	}

	// Set property "RedirectType":
	if configuration.RedirectType != nil {
		redirectType := *configuration.RedirectType
		result.RedirectType = &redirectType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *RedirectConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RedirectConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *RedirectConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RedirectConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RedirectConfiguration_ARM, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		configuration.CustomFragment = &customFragment
	}

	// Set property "CustomHost":
	if typedInput.CustomHost != nil {
		customHost := *typedInput.CustomHost
		configuration.CustomHost = &customHost
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		configuration.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		configuration.CustomQueryString = &customQueryString
	}

	// Set property "OdataType":
	configuration.OdataType = &typedInput.OdataType

	// Set property "RedirectProtocol":
	if typedInput.RedirectProtocol != nil {
		redirectProtocol := *typedInput.RedirectProtocol
		configuration.RedirectProtocol = &redirectProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		redirectType := *typedInput.RedirectType
		configuration.RedirectType = &redirectType
	}

	// No error
	return nil
}

// AssignProperties_From_RedirectConfiguration populates our RedirectConfiguration from the provided source RedirectConfiguration
func (configuration *RedirectConfiguration) AssignProperties_From_RedirectConfiguration(source *v20210601s.RedirectConfiguration) error {

	// CustomFragment
	configuration.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHost
	configuration.CustomHost = genruntime.ClonePointerToString(source.CustomHost)

	// CustomPath
	configuration.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	configuration.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// OdataType
	if source.OdataType != nil {
		odataType := RedirectConfiguration_OdataType(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// RedirectProtocol
	if source.RedirectProtocol != nil {
		redirectProtocol := RedirectConfiguration_RedirectProtocol(*source.RedirectProtocol)
		configuration.RedirectProtocol = &redirectProtocol
	} else {
		configuration.RedirectProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := RedirectConfiguration_RedirectType(*source.RedirectType)
		configuration.RedirectType = &redirectType
	} else {
		configuration.RedirectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RedirectConfiguration populates the provided destination RedirectConfiguration from our RedirectConfiguration
func (configuration *RedirectConfiguration) AssignProperties_To_RedirectConfiguration(destination *v20210601s.RedirectConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(configuration.CustomFragment)

	// CustomHost
	destination.CustomHost = genruntime.ClonePointerToString(configuration.CustomHost)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(configuration.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(configuration.CustomQueryString)

	// OdataType
	if configuration.OdataType != nil {
		odataType := string(*configuration.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// RedirectProtocol
	if configuration.RedirectProtocol != nil {
		redirectProtocol := string(*configuration.RedirectProtocol)
		destination.RedirectProtocol = &redirectProtocol
	} else {
		destination.RedirectProtocol = nil
	}

	// RedirectType
	if configuration.RedirectType != nil {
		redirectType := string(*configuration.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RedirectConfiguration_STATUS populates our RedirectConfiguration from the provided source RedirectConfiguration_STATUS
func (configuration *RedirectConfiguration) Initialize_From_RedirectConfiguration_STATUS(source *RedirectConfiguration_STATUS) error {

	// CustomFragment
	configuration.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHost
	configuration.CustomHost = genruntime.ClonePointerToString(source.CustomHost)

	// CustomPath
	configuration.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	configuration.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// OdataType
	if source.OdataType != nil {
		odataType := RedirectConfiguration_OdataType(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// RedirectProtocol
	if source.RedirectProtocol != nil {
		redirectProtocol := RedirectConfiguration_RedirectProtocol(*source.RedirectProtocol)
		configuration.RedirectProtocol = &redirectProtocol
	} else {
		configuration.RedirectProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := RedirectConfiguration_RedirectType(*source.RedirectType)
		configuration.RedirectType = &redirectType
	} else {
		configuration.RedirectType = nil
	}

	// No error
	return nil
}

type RouteConfiguration_STATUS struct {
	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding: Mutually exclusive with all other properties
	MicrosoftAzureFrontDoorModelsFrontdoorForwarding *ForwardingConfiguration_STATUS `json:"microsoftAzureFrontDoorModelsFrontdoorForwardingConfiguration,omitempty"`

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect: Mutually exclusive with all other properties
	MicrosoftAzureFrontDoorModelsFrontdoorRedirect *RedirectConfiguration_STATUS `json:"microsoftAzureFrontDoorModelsFrontdoorRedirectConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &RouteConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *RouteConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RouteConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *RouteConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RouteConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RouteConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorForwarding":
	if typedInput.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding1 ForwardingConfiguration_STATUS
		err := microsoftAzureFrontDoorModelsFrontdoorForwarding1.PopulateFromARM(owner, *typedInput.MicrosoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return err
		}
		microsoftAzureFrontDoorModelsFrontdoorForwarding := microsoftAzureFrontDoorModelsFrontdoorForwarding1
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	}

	// Set property "MicrosoftAzureFrontDoorModelsFrontdoorRedirect":
	if typedInput.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect1 RedirectConfiguration_STATUS
		err := microsoftAzureFrontDoorModelsFrontdoorRedirect1.PopulateFromARM(owner, *typedInput.MicrosoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return err
		}
		microsoftAzureFrontDoorModelsFrontdoorRedirect := microsoftAzureFrontDoorModelsFrontdoorRedirect1
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfiguration_STATUS populates our RouteConfiguration_STATUS from the provided source RouteConfiguration_STATUS
func (configuration *RouteConfiguration_STATUS) AssignProperties_From_RouteConfiguration_STATUS(source *v20210601s.RouteConfiguration_STATUS) error {

	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding
	if source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding ForwardingConfiguration_STATUS
		err := microsoftAzureFrontDoorModelsFrontdoorForwarding.AssignProperties_From_ForwardingConfiguration_STATUS(source.MicrosoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ForwardingConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorForwarding")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = nil
	}

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect
	if source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect RedirectConfiguration_STATUS
		err := microsoftAzureFrontDoorModelsFrontdoorRedirect.AssignProperties_From_RedirectConfiguration_STATUS(source.MicrosoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RedirectConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorRedirect")
		}
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	} else {
		configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfiguration_STATUS populates the provided destination RouteConfiguration_STATUS from our RouteConfiguration_STATUS
func (configuration *RouteConfiguration_STATUS) AssignProperties_To_RouteConfiguration_STATUS(destination *v20210601s.RouteConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MicrosoftAzureFrontDoorModelsFrontdoorForwarding
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding != nil {
		var microsoftAzureFrontDoorModelsFrontdoorForwarding v20210601s.ForwardingConfiguration_STATUS
		err := configuration.MicrosoftAzureFrontDoorModelsFrontdoorForwarding.AssignProperties_To_ForwardingConfiguration_STATUS(&microsoftAzureFrontDoorModelsFrontdoorForwarding)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ForwardingConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorForwarding")
		}
		destination.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = &microsoftAzureFrontDoorModelsFrontdoorForwarding
	} else {
		destination.MicrosoftAzureFrontDoorModelsFrontdoorForwarding = nil
	}

	// MicrosoftAzureFrontDoorModelsFrontdoorRedirect
	if configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect != nil {
		var microsoftAzureFrontDoorModelsFrontdoorRedirect v20210601s.RedirectConfiguration_STATUS
		err := configuration.MicrosoftAzureFrontDoorModelsFrontdoorRedirect.AssignProperties_To_RedirectConfiguration_STATUS(&microsoftAzureFrontDoorModelsFrontdoorRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RedirectConfiguration_STATUS() to populate field MicrosoftAzureFrontDoorModelsFrontdoorRedirect")
		}
		destination.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = &microsoftAzureFrontDoorModelsFrontdoorRedirect
	} else {
		destination.MicrosoftAzureFrontDoorModelsFrontdoorRedirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Reference to another subresource.
type SubResource_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SubResource_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_From_SubResource_STATUS(source *v20210601s.SubResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_To_SubResource_STATUS(destination *v20210601s.SubResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration struct {
	// CacheDuration: The duration for which the content needs to be cached. Allowed format is in ISO 8601 format
	// (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than a year
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// DynamicCompression: Whether to use dynamic compression for cached content
	DynamicCompression *CacheConfiguration_DynamicCompression `json:"dynamicCompression,omitempty"`

	// QueryParameterStripDirective: Treatment of URL query terms when forming the cache key.
	QueryParameterStripDirective *CacheConfiguration_QueryParameterStripDirective `json:"queryParameterStripDirective,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *CacheConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &CacheConfiguration_ARM{}

	// Set property "CacheDuration":
	if configuration.CacheDuration != nil {
		cacheDuration := *configuration.CacheDuration
		result.CacheDuration = &cacheDuration
	}

	// Set property "DynamicCompression":
	if configuration.DynamicCompression != nil {
		dynamicCompression := *configuration.DynamicCompression
		result.DynamicCompression = &dynamicCompression
	}

	// Set property "QueryParameterStripDirective":
	if configuration.QueryParameterStripDirective != nil {
		queryParameterStripDirective := *configuration.QueryParameterStripDirective
		result.QueryParameterStripDirective = &queryParameterStripDirective
	}

	// Set property "QueryParameters":
	if configuration.QueryParameters != nil {
		queryParameters := *configuration.QueryParameters
		result.QueryParameters = &queryParameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheConfiguration_ARM, got %T", armInput)
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "DynamicCompression":
	if typedInput.DynamicCompression != nil {
		dynamicCompression := *typedInput.DynamicCompression
		configuration.DynamicCompression = &dynamicCompression
	}

	// Set property "QueryParameterStripDirective":
	if typedInput.QueryParameterStripDirective != nil {
		queryParameterStripDirective := *typedInput.QueryParameterStripDirective
		configuration.QueryParameterStripDirective = &queryParameterStripDirective
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_From_CacheConfiguration(source *v20210601s.CacheConfiguration) error {

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// DynamicCompression
	if source.DynamicCompression != nil {
		dynamicCompression := CacheConfiguration_DynamicCompression(*source.DynamicCompression)
		configuration.DynamicCompression = &dynamicCompression
	} else {
		configuration.DynamicCompression = nil
	}

	// QueryParameterStripDirective
	if source.QueryParameterStripDirective != nil {
		queryParameterStripDirective := CacheConfiguration_QueryParameterStripDirective(*source.QueryParameterStripDirective)
		configuration.QueryParameterStripDirective = &queryParameterStripDirective
	} else {
		configuration.QueryParameterStripDirective = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_To_CacheConfiguration(destination *v20210601s.CacheConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// DynamicCompression
	if configuration.DynamicCompression != nil {
		dynamicCompression := string(*configuration.DynamicCompression)
		destination.DynamicCompression = &dynamicCompression
	} else {
		destination.DynamicCompression = nil
	}

	// QueryParameterStripDirective
	if configuration.QueryParameterStripDirective != nil {
		queryParameterStripDirective := string(*configuration.QueryParameterStripDirective)
		destination.QueryParameterStripDirective = &queryParameterStripDirective
	} else {
		destination.QueryParameterStripDirective = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheConfiguration_STATUS populates our CacheConfiguration from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration) Initialize_From_CacheConfiguration_STATUS(source *CacheConfiguration_STATUS) error {

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// DynamicCompression
	if source.DynamicCompression != nil {
		dynamicCompression := CacheConfiguration_DynamicCompression(*source.DynamicCompression)
		configuration.DynamicCompression = &dynamicCompression
	} else {
		configuration.DynamicCompression = nil
	}

	// QueryParameterStripDirective
	if source.QueryParameterStripDirective != nil {
		queryParameterStripDirective := CacheConfiguration_QueryParameterStripDirective(*source.QueryParameterStripDirective)
		configuration.QueryParameterStripDirective = &queryParameterStripDirective
	} else {
		configuration.QueryParameterStripDirective = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HttpOnly","HttpsOnly","MatchRequest"}
type ForwardingConfiguration_ForwardingProtocol string

const (
	ForwardingConfiguration_ForwardingProtocol_HttpOnly     = ForwardingConfiguration_ForwardingProtocol("HttpOnly")
	ForwardingConfiguration_ForwardingProtocol_HttpsOnly    = ForwardingConfiguration_ForwardingProtocol("HttpsOnly")
	ForwardingConfiguration_ForwardingProtocol_MatchRequest = ForwardingConfiguration_ForwardingProtocol("MatchRequest")
)

// +kubebuilder:validation:Enum={"#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration"}
type ForwardingConfiguration_OdataType string

const ForwardingConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorForwardingConfiguration = ForwardingConfiguration_OdataType("#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration")

type ForwardingConfiguration_STATUS struct {
	// BackendPool: A reference to the BackendPool which this rule routes to.
	BackendPool *SubResource_STATUS `json:"backendPool,omitempty"`

	// CacheConfiguration: The caching configuration associated with this rule.
	CacheConfiguration *CacheConfiguration_STATUS `json:"cacheConfiguration,omitempty"`

	// CustomForwardingPath: A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming
	// path.
	CustomForwardingPath *string `json:"customForwardingPath,omitempty"`

	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *ForwardingConfiguration_ForwardingProtocol_STATUS `json:"forwardingProtocol,omitempty"`
	OdataType          *ForwardingConfiguration_OdataType_STATUS          `json:"@odata.type,omitempty"`
}

var _ genruntime.FromARMConverter = &ForwardingConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ForwardingConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ForwardingConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ForwardingConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ForwardingConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ForwardingConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackendPool":
	if typedInput.BackendPool != nil {
		var backendPool1 SubResource_STATUS
		err := backendPool1.PopulateFromARM(owner, *typedInput.BackendPool)
		if err != nil {
			return err
		}
		backendPool := backendPool1
		configuration.BackendPool = &backendPool
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration_STATUS
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		configuration.CacheConfiguration = &cacheConfiguration
	}

	// Set property "CustomForwardingPath":
	if typedInput.CustomForwardingPath != nil {
		customForwardingPath := *typedInput.CustomForwardingPath
		configuration.CustomForwardingPath = &customForwardingPath
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		forwardingProtocol := *typedInput.ForwardingProtocol
		configuration.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OdataType":
	configuration.OdataType = &typedInput.OdataType

	// No error
	return nil
}

// AssignProperties_From_ForwardingConfiguration_STATUS populates our ForwardingConfiguration_STATUS from the provided source ForwardingConfiguration_STATUS
func (configuration *ForwardingConfiguration_STATUS) AssignProperties_From_ForwardingConfiguration_STATUS(source *v20210601s.ForwardingConfiguration_STATUS) error {

	// BackendPool
	if source.BackendPool != nil {
		var backendPool SubResource_STATUS
		err := backendPool.AssignProperties_From_SubResource_STATUS(source.BackendPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BackendPool")
		}
		configuration.BackendPool = &backendPool
	} else {
		configuration.BackendPool = nil
	}

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration_STATUS
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		configuration.CacheConfiguration = &cacheConfiguration
	} else {
		configuration.CacheConfiguration = nil
	}

	// CustomForwardingPath
	configuration.CustomForwardingPath = genruntime.ClonePointerToString(source.CustomForwardingPath)

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := ForwardingConfiguration_ForwardingProtocol_STATUS(*source.ForwardingProtocol)
		configuration.ForwardingProtocol = &forwardingProtocol
	} else {
		configuration.ForwardingProtocol = nil
	}

	// OdataType
	if source.OdataType != nil {
		odataType := ForwardingConfiguration_OdataType_STATUS(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ForwardingConfiguration_STATUS populates the provided destination ForwardingConfiguration_STATUS from our ForwardingConfiguration_STATUS
func (configuration *ForwardingConfiguration_STATUS) AssignProperties_To_ForwardingConfiguration_STATUS(destination *v20210601s.ForwardingConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPool
	if configuration.BackendPool != nil {
		var backendPool v20210601s.SubResource_STATUS
		err := configuration.BackendPool.AssignProperties_To_SubResource_STATUS(&backendPool)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BackendPool")
		}
		destination.BackendPool = &backendPool
	} else {
		destination.BackendPool = nil
	}

	// CacheConfiguration
	if configuration.CacheConfiguration != nil {
		var cacheConfiguration v20210601s.CacheConfiguration_STATUS
		err := configuration.CacheConfiguration.AssignProperties_To_CacheConfiguration_STATUS(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// CustomForwardingPath
	destination.CustomForwardingPath = genruntime.ClonePointerToString(configuration.CustomForwardingPath)

	// ForwardingProtocol
	if configuration.ForwardingProtocol != nil {
		forwardingProtocol := string(*configuration.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OdataType
	if configuration.OdataType != nil {
		odataType := string(*configuration.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration"}
type RedirectConfiguration_OdataType string

const RedirectConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorRedirectConfiguration = RedirectConfiguration_OdataType("#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration")

// +kubebuilder:validation:Enum={"HttpOnly","HttpsOnly","MatchRequest"}
type RedirectConfiguration_RedirectProtocol string

const (
	RedirectConfiguration_RedirectProtocol_HttpOnly     = RedirectConfiguration_RedirectProtocol("HttpOnly")
	RedirectConfiguration_RedirectProtocol_HttpsOnly    = RedirectConfiguration_RedirectProtocol("HttpsOnly")
	RedirectConfiguration_RedirectProtocol_MatchRequest = RedirectConfiguration_RedirectProtocol("MatchRequest")
)

// +kubebuilder:validation:Enum={"Found","Moved","PermanentRedirect","TemporaryRedirect"}
type RedirectConfiguration_RedirectType string

const (
	RedirectConfiguration_RedirectType_Found             = RedirectConfiguration_RedirectType("Found")
	RedirectConfiguration_RedirectType_Moved             = RedirectConfiguration_RedirectType("Moved")
	RedirectConfiguration_RedirectType_PermanentRedirect = RedirectConfiguration_RedirectType("PermanentRedirect")
	RedirectConfiguration_RedirectType_TemporaryRedirect = RedirectConfiguration_RedirectType("TemporaryRedirect")
)

type RedirectConfiguration_STATUS struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHost: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHost *string `json:"customHost,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// The first ? and & will be added automatically so do not include them in the front, but do separate multiple query
	// strings with &.
	CustomQueryString *string                                 `json:"customQueryString,omitempty"`
	OdataType         *RedirectConfiguration_OdataType_STATUS `json:"@odata.type,omitempty"`

	// RedirectProtocol: The protocol of the destination to where the traffic is redirected
	RedirectProtocol *RedirectConfiguration_RedirectProtocol_STATUS `json:"redirectProtocol,omitempty"`

	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *RedirectConfiguration_RedirectType_STATUS `json:"redirectType,omitempty"`
}

var _ genruntime.FromARMConverter = &RedirectConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *RedirectConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RedirectConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *RedirectConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RedirectConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RedirectConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		configuration.CustomFragment = &customFragment
	}

	// Set property "CustomHost":
	if typedInput.CustomHost != nil {
		customHost := *typedInput.CustomHost
		configuration.CustomHost = &customHost
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		configuration.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		configuration.CustomQueryString = &customQueryString
	}

	// Set property "OdataType":
	configuration.OdataType = &typedInput.OdataType

	// Set property "RedirectProtocol":
	if typedInput.RedirectProtocol != nil {
		redirectProtocol := *typedInput.RedirectProtocol
		configuration.RedirectProtocol = &redirectProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		redirectType := *typedInput.RedirectType
		configuration.RedirectType = &redirectType
	}

	// No error
	return nil
}

// AssignProperties_From_RedirectConfiguration_STATUS populates our RedirectConfiguration_STATUS from the provided source RedirectConfiguration_STATUS
func (configuration *RedirectConfiguration_STATUS) AssignProperties_From_RedirectConfiguration_STATUS(source *v20210601s.RedirectConfiguration_STATUS) error {

	// CustomFragment
	configuration.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHost
	configuration.CustomHost = genruntime.ClonePointerToString(source.CustomHost)

	// CustomPath
	configuration.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	configuration.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// OdataType
	if source.OdataType != nil {
		odataType := RedirectConfiguration_OdataType_STATUS(*source.OdataType)
		configuration.OdataType = &odataType
	} else {
		configuration.OdataType = nil
	}

	// RedirectProtocol
	if source.RedirectProtocol != nil {
		redirectProtocol := RedirectConfiguration_RedirectProtocol_STATUS(*source.RedirectProtocol)
		configuration.RedirectProtocol = &redirectProtocol
	} else {
		configuration.RedirectProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := RedirectConfiguration_RedirectType_STATUS(*source.RedirectType)
		configuration.RedirectType = &redirectType
	} else {
		configuration.RedirectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RedirectConfiguration_STATUS populates the provided destination RedirectConfiguration_STATUS from our RedirectConfiguration_STATUS
func (configuration *RedirectConfiguration_STATUS) AssignProperties_To_RedirectConfiguration_STATUS(destination *v20210601s.RedirectConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(configuration.CustomFragment)

	// CustomHost
	destination.CustomHost = genruntime.ClonePointerToString(configuration.CustomHost)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(configuration.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(configuration.CustomQueryString)

	// OdataType
	if configuration.OdataType != nil {
		odataType := string(*configuration.OdataType)
		destination.OdataType = &odataType
	} else {
		destination.OdataType = nil
	}

	// RedirectProtocol
	if configuration.RedirectProtocol != nil {
		redirectProtocol := string(*configuration.RedirectProtocol)
		destination.RedirectProtocol = &redirectProtocol
	} else {
		destination.RedirectProtocol = nil
	}

	// RedirectType
	if configuration.RedirectType != nil {
		redirectType := string(*configuration.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type CacheConfiguration_DynamicCompression string

const (
	CacheConfiguration_DynamicCompression_Disabled = CacheConfiguration_DynamicCompression("Disabled")
	CacheConfiguration_DynamicCompression_Enabled  = CacheConfiguration_DynamicCompression("Enabled")
)

// +kubebuilder:validation:Enum={"StripAll","StripAllExcept","StripNone","StripOnly"}
type CacheConfiguration_QueryParameterStripDirective string

const (
	CacheConfiguration_QueryParameterStripDirective_StripAll       = CacheConfiguration_QueryParameterStripDirective("StripAll")
	CacheConfiguration_QueryParameterStripDirective_StripAllExcept = CacheConfiguration_QueryParameterStripDirective("StripAllExcept")
	CacheConfiguration_QueryParameterStripDirective_StripNone      = CacheConfiguration_QueryParameterStripDirective("StripNone")
	CacheConfiguration_QueryParameterStripDirective_StripOnly      = CacheConfiguration_QueryParameterStripDirective("StripOnly")
)

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration_STATUS struct {
	// CacheDuration: The duration for which the content needs to be cached. Allowed format is in ISO 8601 format
	// (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than a year
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// DynamicCompression: Whether to use dynamic compression for cached content
	DynamicCompression *CacheConfiguration_DynamicCompression_STATUS `json:"dynamicCompression,omitempty"`

	// QueryParameterStripDirective: Treatment of URL query terms when forming the cache key.
	QueryParameterStripDirective *CacheConfiguration_QueryParameterStripDirective_STATUS `json:"queryParameterStripDirective,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "DynamicCompression":
	if typedInput.DynamicCompression != nil {
		dynamicCompression := *typedInput.DynamicCompression
		configuration.DynamicCompression = &dynamicCompression
	}

	// Set property "QueryParameterStripDirective":
	if typedInput.QueryParameterStripDirective != nil {
		queryParameterStripDirective := *typedInput.QueryParameterStripDirective
		configuration.QueryParameterStripDirective = &queryParameterStripDirective
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration_STATUS populates our CacheConfiguration_STATUS from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_From_CacheConfiguration_STATUS(source *v20210601s.CacheConfiguration_STATUS) error {

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// DynamicCompression
	if source.DynamicCompression != nil {
		dynamicCompression := CacheConfiguration_DynamicCompression_STATUS(*source.DynamicCompression)
		configuration.DynamicCompression = &dynamicCompression
	} else {
		configuration.DynamicCompression = nil
	}

	// QueryParameterStripDirective
	if source.QueryParameterStripDirective != nil {
		queryParameterStripDirective := CacheConfiguration_QueryParameterStripDirective_STATUS(*source.QueryParameterStripDirective)
		configuration.QueryParameterStripDirective = &queryParameterStripDirective
	} else {
		configuration.QueryParameterStripDirective = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration_STATUS populates the provided destination CacheConfiguration_STATUS from our CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_To_CacheConfiguration_STATUS(destination *v20210601s.CacheConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// DynamicCompression
	if configuration.DynamicCompression != nil {
		dynamicCompression := string(*configuration.DynamicCompression)
		destination.DynamicCompression = &dynamicCompression
	} else {
		destination.DynamicCompression = nil
	}

	// QueryParameterStripDirective
	if configuration.QueryParameterStripDirective != nil {
		queryParameterStripDirective := string(*configuration.QueryParameterStripDirective)
		destination.QueryParameterStripDirective = &queryParameterStripDirective
	} else {
		destination.QueryParameterStripDirective = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ForwardingConfiguration_ForwardingProtocol_STATUS string

const (
	ForwardingConfiguration_ForwardingProtocol_STATUS_HttpOnly     = ForwardingConfiguration_ForwardingProtocol_STATUS("HttpOnly")
	ForwardingConfiguration_ForwardingProtocol_STATUS_HttpsOnly    = ForwardingConfiguration_ForwardingProtocol_STATUS("HttpsOnly")
	ForwardingConfiguration_ForwardingProtocol_STATUS_MatchRequest = ForwardingConfiguration_ForwardingProtocol_STATUS("MatchRequest")
)

type ForwardingConfiguration_OdataType_STATUS string

const ForwardingConfiguration_OdataType_STATUS_MicrosoftAzureFrontDoorModelsFrontdoorForwardingConfiguration = ForwardingConfiguration_OdataType_STATUS("#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration")

type RedirectConfiguration_OdataType_STATUS string

const RedirectConfiguration_OdataType_STATUS_MicrosoftAzureFrontDoorModelsFrontdoorRedirectConfiguration = RedirectConfiguration_OdataType_STATUS("#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration")

type RedirectConfiguration_RedirectProtocol_STATUS string

const (
	RedirectConfiguration_RedirectProtocol_STATUS_HttpOnly     = RedirectConfiguration_RedirectProtocol_STATUS("HttpOnly")
	RedirectConfiguration_RedirectProtocol_STATUS_HttpsOnly    = RedirectConfiguration_RedirectProtocol_STATUS("HttpsOnly")
	RedirectConfiguration_RedirectProtocol_STATUS_MatchRequest = RedirectConfiguration_RedirectProtocol_STATUS("MatchRequest")
)

type RedirectConfiguration_RedirectType_STATUS string

const (
	RedirectConfiguration_RedirectType_STATUS_Found             = RedirectConfiguration_RedirectType_STATUS("Found")
	RedirectConfiguration_RedirectType_STATUS_Moved             = RedirectConfiguration_RedirectType_STATUS("Moved")
	RedirectConfiguration_RedirectType_STATUS_PermanentRedirect = RedirectConfiguration_RedirectType_STATUS("PermanentRedirect")
	RedirectConfiguration_RedirectType_STATUS_TemporaryRedirect = RedirectConfiguration_RedirectType_STATUS("TemporaryRedirect")
)

type CacheConfiguration_DynamicCompression_STATUS string

const (
	CacheConfiguration_DynamicCompression_STATUS_Disabled = CacheConfiguration_DynamicCompression_STATUS("Disabled")
	CacheConfiguration_DynamicCompression_STATUS_Enabled  = CacheConfiguration_DynamicCompression_STATUS("Enabled")
)

type CacheConfiguration_QueryParameterStripDirective_STATUS string

const (
	CacheConfiguration_QueryParameterStripDirective_STATUS_StripAll       = CacheConfiguration_QueryParameterStripDirective_STATUS("StripAll")
	CacheConfiguration_QueryParameterStripDirective_STATUS_StripAllExcept = CacheConfiguration_QueryParameterStripDirective_STATUS("StripAllExcept")
	CacheConfiguration_QueryParameterStripDirective_STATUS_StripNone      = CacheConfiguration_QueryParameterStripDirective_STATUS("StripNone")
	CacheConfiguration_QueryParameterStripDirective_STATUS_StripOnly      = CacheConfiguration_QueryParameterStripDirective_STATUS("StripOnly")
)

func init() {
	SchemeBuilder.Register(&FrontDoor{}, &FrontDoorList{})
}
