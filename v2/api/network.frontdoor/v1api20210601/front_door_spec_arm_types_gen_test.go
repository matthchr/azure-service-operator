// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_FrontDoor_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor_Spec_ARM, FrontDoor_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor_Spec_ARM runs a test to see if a specific instance of FrontDoor_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor_Spec_ARM(subject FrontDoor_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor_Spec_ARM instances for property testing - lazily instantiated by FrontDoor_Spec_ARMGenerator()
var frontDoor_Spec_ARMGenerator gopter.Gen

// FrontDoor_Spec_ARMGenerator returns a generator of FrontDoor_Spec_ARM instances for property testing.
// We first initialize frontDoor_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoor_Spec_ARMGenerator() gopter.Gen {
	if frontDoor_Spec_ARMGenerator != nil {
		return frontDoor_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec_ARM(generators)
	frontDoor_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontDoor_Spec_ARM(generators)
	frontDoor_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec_ARM{}), generators)

	return frontDoor_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoor_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoor_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoor_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontDoorProperties_ARMGenerator())
}

func Test_FrontDoorProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoorProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoorProperties_ARM, FrontDoorProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoorProperties_ARM runs a test to see if a specific instance of FrontDoorProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoorProperties_ARM(subject FrontDoorProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoorProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoorProperties_ARM instances for property testing - lazily instantiated by
// FrontDoorProperties_ARMGenerator()
var frontDoorProperties_ARMGenerator gopter.Gen

// FrontDoorProperties_ARMGenerator returns a generator of FrontDoorProperties_ARM instances for property testing.
// We first initialize frontDoorProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoorProperties_ARMGenerator() gopter.Gen {
	if frontDoorProperties_ARMGenerator != nil {
		return frontDoorProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorProperties_ARM(generators)
	frontDoorProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoorProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontDoorProperties_ARM(generators)
	frontDoorProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoorProperties_ARM{}), generators)

	return frontDoorProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoorProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoorProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(FrontDoorProperties_EnabledState_Disabled, FrontDoorProperties_EnabledState_Enabled))
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoorProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoorProperties_ARM(gens map[string]gopter.Gen) {
	gens["BackendPools"] = gen.SliceOf(BackendPool_ARMGenerator())
	gens["BackendPoolsSettings"] = gen.PtrOf(BackendPoolsSettings_ARMGenerator())
	gens["FrontendEndpoints"] = gen.SliceOf(FrontendEndpoint_ARMGenerator())
	gens["HealthProbeSettings"] = gen.SliceOf(HealthProbeSettingsModel_ARMGenerator())
	gens["LoadBalancingSettings"] = gen.SliceOf(LoadBalancingSettingsModel_ARMGenerator())
	gens["RoutingRules"] = gen.SliceOf(RoutingRule_ARMGenerator())
}

func Test_BackendPool_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPool_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPool_ARM, BackendPool_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPool_ARM runs a test to see if a specific instance of BackendPool_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPool_ARM(subject BackendPool_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPool_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPool_ARM instances for property testing - lazily instantiated by BackendPool_ARMGenerator()
var backendPool_ARMGenerator gopter.Gen

// BackendPool_ARMGenerator returns a generator of BackendPool_ARM instances for property testing.
// We first initialize backendPool_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendPool_ARMGenerator() gopter.Gen {
	if backendPool_ARMGenerator != nil {
		return backendPool_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool_ARM(generators)
	backendPool_ARMGenerator = gen.Struct(reflect.TypeOf(BackendPool_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool_ARM(generators)
	AddRelatedPropertyGeneratorsForBackendPool_ARM(generators)
	backendPool_ARMGenerator = gen.Struct(reflect.TypeOf(BackendPool_ARM{}), generators)

	return backendPool_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendPool_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPool_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendPool_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendPool_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackendPoolProperties_ARMGenerator())
}

func Test_BackendPoolsSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolsSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolsSettings_ARM, BackendPoolsSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolsSettings_ARM runs a test to see if a specific instance of BackendPoolsSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolsSettings_ARM(subject BackendPoolsSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolsSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolsSettings_ARM instances for property testing - lazily instantiated by
// BackendPoolsSettings_ARMGenerator()
var backendPoolsSettings_ARMGenerator gopter.Gen

// BackendPoolsSettings_ARMGenerator returns a generator of BackendPoolsSettings_ARM instances for property testing.
func BackendPoolsSettings_ARMGenerator() gopter.Gen {
	if backendPoolsSettings_ARMGenerator != nil {
		return backendPoolsSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPoolsSettings_ARM(generators)
	backendPoolsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(BackendPoolsSettings_ARM{}), generators)

	return backendPoolsSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackendPoolsSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPoolsSettings_ARM(gens map[string]gopter.Gen) {
	gens["EnforceCertificateNameCheck"] = gen.PtrOf(gen.OneConstOf(BackendPoolsSettings_EnforceCertificateNameCheck_Disabled, BackendPoolsSettings_EnforceCertificateNameCheck_Enabled))
	gens["SendRecvTimeoutSeconds"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpoint_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpoint_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpoint_ARM, FrontendEndpoint_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpoint_ARM runs a test to see if a specific instance of FrontendEndpoint_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpoint_ARM(subject FrontendEndpoint_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpoint_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpoint_ARM instances for property testing - lazily instantiated by
// FrontendEndpoint_ARMGenerator()
var frontendEndpoint_ARMGenerator gopter.Gen

// FrontendEndpoint_ARMGenerator returns a generator of FrontendEndpoint_ARM instances for property testing.
// We first initialize frontendEndpoint_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendEndpoint_ARMGenerator() gopter.Gen {
	if frontendEndpoint_ARMGenerator != nil {
		return frontendEndpoint_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint_ARM(generators)
	frontendEndpoint_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontendEndpoint_ARM(generators)
	frontendEndpoint_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint_ARM{}), generators)

	return frontendEndpoint_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpoint_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpoint_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontendEndpoint_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendEndpoint_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FrontendEndpointProperties_ARMGenerator())
}

func Test_HealthProbeSettingsModel_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsModel_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsModel_ARM, HealthProbeSettingsModel_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsModel_ARM runs a test to see if a specific instance of HealthProbeSettingsModel_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsModel_ARM(subject HealthProbeSettingsModel_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsModel_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsModel_ARM instances for property testing - lazily instantiated by
// HealthProbeSettingsModel_ARMGenerator()
var healthProbeSettingsModel_ARMGenerator gopter.Gen

// HealthProbeSettingsModel_ARMGenerator returns a generator of HealthProbeSettingsModel_ARM instances for property testing.
// We first initialize healthProbeSettingsModel_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HealthProbeSettingsModel_ARMGenerator() gopter.Gen {
	if healthProbeSettingsModel_ARMGenerator != nil {
		return healthProbeSettingsModel_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_ARM(generators)
	healthProbeSettingsModel_ARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_ARM(generators)
	AddRelatedPropertyGeneratorsForHealthProbeSettingsModel_ARM(generators)
	healthProbeSettingsModel_ARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel_ARM{}), generators)

	return healthProbeSettingsModel_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHealthProbeSettingsModel_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHealthProbeSettingsModel_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HealthProbeSettingsProperties_ARMGenerator())
}

func Test_LoadBalancingSettingsModel_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsModel_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsModel_ARM, LoadBalancingSettingsModel_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsModel_ARM runs a test to see if a specific instance of LoadBalancingSettingsModel_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsModel_ARM(subject LoadBalancingSettingsModel_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsModel_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsModel_ARM instances for property testing - lazily instantiated by
// LoadBalancingSettingsModel_ARMGenerator()
var loadBalancingSettingsModel_ARMGenerator gopter.Gen

// LoadBalancingSettingsModel_ARMGenerator returns a generator of LoadBalancingSettingsModel_ARM instances for property testing.
// We first initialize loadBalancingSettingsModel_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoadBalancingSettingsModel_ARMGenerator() gopter.Gen {
	if loadBalancingSettingsModel_ARMGenerator != nil {
		return loadBalancingSettingsModel_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_ARM(generators)
	loadBalancingSettingsModel_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_ARM(generators)
	AddRelatedPropertyGeneratorsForLoadBalancingSettingsModel_ARM(generators)
	loadBalancingSettingsModel_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel_ARM{}), generators)

	return loadBalancingSettingsModel_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLoadBalancingSettingsModel_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancingSettingsModel_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(LoadBalancingSettingsProperties_ARMGenerator())
}

func Test_RoutingRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRule_ARM, RoutingRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRule_ARM runs a test to see if a specific instance of RoutingRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRule_ARM(subject RoutingRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRule_ARM instances for property testing - lazily instantiated by RoutingRule_ARMGenerator()
var routingRule_ARMGenerator gopter.Gen

// RoutingRule_ARMGenerator returns a generator of RoutingRule_ARM instances for property testing.
// We first initialize routingRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingRule_ARMGenerator() gopter.Gen {
	if routingRule_ARMGenerator != nil {
		return routingRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule_ARM(generators)
	routingRule_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingRule_ARM(generators)
	routingRule_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingRule_ARM{}), generators)

	return routingRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRule_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingRule_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(RoutingRuleProperties_ARMGenerator())
}

func Test_BackendPoolProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolProperties_ARM, BackendPoolProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolProperties_ARM runs a test to see if a specific instance of BackendPoolProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolProperties_ARM(subject BackendPoolProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolProperties_ARM instances for property testing - lazily instantiated by
// BackendPoolProperties_ARMGenerator()
var backendPoolProperties_ARMGenerator gopter.Gen

// BackendPoolProperties_ARMGenerator returns a generator of BackendPoolProperties_ARM instances for property testing.
func BackendPoolProperties_ARMGenerator() gopter.Gen {
	if backendPoolProperties_ARMGenerator != nil {
		return backendPoolProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackendPoolProperties_ARM(generators)
	backendPoolProperties_ARMGenerator = gen.Struct(reflect.TypeOf(BackendPoolProperties_ARM{}), generators)

	return backendPoolProperties_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBackendPoolProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendPoolProperties_ARM(gens map[string]gopter.Gen) {
	gens["Backends"] = gen.SliceOf(Backend_ARMGenerator())
	gens["HealthProbeSettings"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["LoadBalancingSettings"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_FrontendEndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpointProperties_ARM, FrontendEndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpointProperties_ARM runs a test to see if a specific instance of FrontendEndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpointProperties_ARM(subject FrontendEndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpointProperties_ARM instances for property testing - lazily instantiated by
// FrontendEndpointProperties_ARMGenerator()
var frontendEndpointProperties_ARMGenerator gopter.Gen

// FrontendEndpointProperties_ARMGenerator returns a generator of FrontendEndpointProperties_ARM instances for property testing.
// We first initialize frontendEndpointProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendEndpointProperties_ARMGenerator() gopter.Gen {
	if frontendEndpointProperties_ARMGenerator != nil {
		return frontendEndpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpointProperties_ARM(generators)
	frontendEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpointProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontendEndpointProperties_ARM(generators)
	frontendEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointProperties_ARM{}), generators)

	return frontendEndpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["SessionAffinityEnabledState"] = gen.PtrOf(gen.OneConstOf(FrontendEndpointProperties_SessionAffinityEnabledState_Disabled, FrontendEndpointProperties_SessionAffinityEnabledState_Enabled))
	gens["SessionAffinityTtlSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFrontendEndpointProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator())
}

func Test_HealthProbeSettingsProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsProperties_ARM, HealthProbeSettingsProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsProperties_ARM runs a test to see if a specific instance of HealthProbeSettingsProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsProperties_ARM(subject HealthProbeSettingsProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsProperties_ARM instances for property testing - lazily instantiated by
// HealthProbeSettingsProperties_ARMGenerator()
var healthProbeSettingsProperties_ARMGenerator gopter.Gen

// HealthProbeSettingsProperties_ARMGenerator returns a generator of HealthProbeSettingsProperties_ARM instances for property testing.
func HealthProbeSettingsProperties_ARMGenerator() gopter.Gen {
	if healthProbeSettingsProperties_ARMGenerator != nil {
		return healthProbeSettingsProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsProperties_ARM(generators)
	healthProbeSettingsProperties_ARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsProperties_ARM{}), generators)

	return healthProbeSettingsProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsProperties_ARM(gens map[string]gopter.Gen) {
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_EnabledState_Disabled, HealthProbeSettingsProperties_EnabledState_Enabled))
	gens["HealthProbeMethod"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_HealthProbeMethod_GET, HealthProbeSettingsProperties_HealthProbeMethod_HEAD))
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_Protocol_Http, HealthProbeSettingsProperties_Protocol_Https))
}

func Test_LoadBalancingSettingsProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsProperties_ARM, LoadBalancingSettingsProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsProperties_ARM runs a test to see if a specific instance of LoadBalancingSettingsProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsProperties_ARM(subject LoadBalancingSettingsProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsProperties_ARM instances for property testing - lazily instantiated by
// LoadBalancingSettingsProperties_ARMGenerator()
var loadBalancingSettingsProperties_ARMGenerator gopter.Gen

// LoadBalancingSettingsProperties_ARMGenerator returns a generator of LoadBalancingSettingsProperties_ARM instances for property testing.
func LoadBalancingSettingsProperties_ARMGenerator() gopter.Gen {
	if loadBalancingSettingsProperties_ARMGenerator != nil {
		return loadBalancingSettingsProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsProperties_ARM(generators)
	loadBalancingSettingsProperties_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsProperties_ARM{}), generators)

	return loadBalancingSettingsProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdditionalLatencyMilliseconds"] = gen.PtrOf(gen.Int())
	gens["SampleSize"] = gen.PtrOf(gen.Int())
	gens["SuccessfulSamplesRequired"] = gen.PtrOf(gen.Int())
}

func Test_RoutingRuleProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRuleProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRuleProperties_ARM, RoutingRuleProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRuleProperties_ARM runs a test to see if a specific instance of RoutingRuleProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRuleProperties_ARM(subject RoutingRuleProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRuleProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRuleProperties_ARM instances for property testing - lazily instantiated by
// RoutingRuleProperties_ARMGenerator()
var routingRuleProperties_ARMGenerator gopter.Gen

// RoutingRuleProperties_ARMGenerator returns a generator of RoutingRuleProperties_ARM instances for property testing.
// We first initialize routingRuleProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingRuleProperties_ARMGenerator() gopter.Gen {
	if routingRuleProperties_ARMGenerator != nil {
		return routingRuleProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRuleProperties_ARM(generators)
	routingRuleProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingRuleProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRuleProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingRuleProperties_ARM(generators)
	routingRuleProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingRuleProperties_ARM{}), generators)

	return routingRuleProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRuleProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRuleProperties_ARM(gens map[string]gopter.Gen) {
	gens["AcceptedProtocols"] = gen.SliceOf(gen.OneConstOf(RoutingRuleProperties_AcceptedProtocols_Http, RoutingRuleProperties_AcceptedProtocols_Https))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(RoutingRuleProperties_EnabledState_Disabled, RoutingRuleProperties_EnabledState_Enabled))
	gens["PatternsToMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingRuleProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingRuleProperties_ARM(gens map[string]gopter.Gen) {
	gens["FrontendEndpoints"] = gen.SliceOf(SubResource_ARMGenerator())
	gens["RouteConfiguration"] = gen.PtrOf(RouteConfiguration_ARMGenerator())
	gens["RulesEngine"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator())
}

func Test_Backend_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Backend_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackend_ARM, Backend_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackend_ARM runs a test to see if a specific instance of Backend_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackend_ARM(subject Backend_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Backend_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Backend_ARM instances for property testing - lazily instantiated by Backend_ARMGenerator()
var backend_ARMGenerator gopter.Gen

// Backend_ARMGenerator returns a generator of Backend_ARM instances for property testing.
func Backend_ARMGenerator() gopter.Gen {
	if backend_ARMGenerator != nil {
		return backend_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackend_ARM(generators)
	backend_ARMGenerator = gen.Struct(reflect.TypeOf(Backend_ARM{}), generators)

	return backend_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackend_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackend_ARM(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["BackendHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(Backend_EnabledState_Disabled, Backend_EnabledState_Enabled))
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM, FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM runs a test to see if a specific instance of FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM(subject FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing - lazily
// instantiated by FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator()
var frontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator gopter.Gen

// FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator returns a generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing.
func FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator() gopter.Gen {
	if frontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator != nil {
		return frontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM(generators)
	frontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM{}), generators)

	return frontendEndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpointProperties_WebApplicationFirewallPolicyLink_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RouteConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfiguration_ARM, RouteConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfiguration_ARM runs a test to see if a specific instance of RouteConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfiguration_ARM(subject RouteConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfiguration_ARM instances for property testing - lazily instantiated by
// RouteConfiguration_ARMGenerator()
var routeConfiguration_ARMGenerator gopter.Gen

// RouteConfiguration_ARMGenerator returns a generator of RouteConfiguration_ARM instances for property testing.
func RouteConfiguration_ARMGenerator() gopter.Gen {
	if routeConfiguration_ARMGenerator != nil {
		return routeConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRouteConfiguration_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(RouteConfiguration_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	routeConfiguration_ARMGenerator = gen.OneGenOf(gens...)

	return routeConfiguration_ARMGenerator
}

// AddRelatedPropertyGeneratorsForRouteConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureFrontDoorModelsFrontdoorForwarding"] = ForwardingConfiguration_ARMGenerator().Map(func(it ForwardingConfiguration_ARM) *ForwardingConfiguration_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureFrontDoorModelsFrontdoorRedirect"] = RedirectConfiguration_ARMGenerator().Map(func(it RedirectConfiguration_ARM) *RedirectConfiguration_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM, RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM runs a test to see if a specific instance of RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM(subject RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing - lazily
// instantiated by RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator()
var routingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator gopter.Gen

// RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator returns a generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing.
func RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator() gopter.Gen {
	if routingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator != nil {
		return routingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM(generators)
	routingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM{}), generators)

	return routingRuleProperties_WebApplicationFirewallPolicyLink_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRuleProperties_WebApplicationFirewallPolicyLink_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_ARM, SubResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_ARM runs a test to see if a specific instance of SubResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_ARM(subject SubResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_ARM instances for property testing - lazily instantiated by SubResource_ARMGenerator()
var subResource_ARMGenerator gopter.Gen

// SubResource_ARMGenerator returns a generator of SubResource_ARM instances for property testing.
func SubResource_ARMGenerator() gopter.Gen {
	if subResource_ARMGenerator != nil {
		return subResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_ARM(generators)
	subResource_ARMGenerator = gen.Struct(reflect.TypeOf(SubResource_ARM{}), generators)

	return subResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ForwardingConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardingConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardingConfiguration_ARM, ForwardingConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardingConfiguration_ARM runs a test to see if a specific instance of ForwardingConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardingConfiguration_ARM(subject ForwardingConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardingConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardingConfiguration_ARM instances for property testing - lazily instantiated by
// ForwardingConfiguration_ARMGenerator()
var forwardingConfiguration_ARMGenerator gopter.Gen

// ForwardingConfiguration_ARMGenerator returns a generator of ForwardingConfiguration_ARM instances for property testing.
// We first initialize forwardingConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ForwardingConfiguration_ARMGenerator() gopter.Gen {
	if forwardingConfiguration_ARMGenerator != nil {
		return forwardingConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_ARM(generators)
	forwardingConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForForwardingConfiguration_ARM(generators)
	forwardingConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_ARM{}), generators)

	return forwardingConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForForwardingConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardingConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CustomForwardingPath"] = gen.PtrOf(gen.AlphaString())
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(ForwardingConfiguration_ForwardingProtocol_HttpOnly, ForwardingConfiguration_ForwardingProtocol_HttpsOnly, ForwardingConfiguration_ForwardingProtocol_MatchRequest))
	gens["OdataType"] = gen.OneConstOf(ForwardingConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorForwardingConfiguration)
}

// AddRelatedPropertyGeneratorsForForwardingConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForForwardingConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["BackendPool"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfiguration_ARMGenerator())
}

func Test_RedirectConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RedirectConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRedirectConfiguration_ARM, RedirectConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRedirectConfiguration_ARM runs a test to see if a specific instance of RedirectConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRedirectConfiguration_ARM(subject RedirectConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RedirectConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RedirectConfiguration_ARM instances for property testing - lazily instantiated by
// RedirectConfiguration_ARMGenerator()
var redirectConfiguration_ARMGenerator gopter.Gen

// RedirectConfiguration_ARMGenerator returns a generator of RedirectConfiguration_ARM instances for property testing.
func RedirectConfiguration_ARMGenerator() gopter.Gen {
	if redirectConfiguration_ARMGenerator != nil {
		return redirectConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRedirectConfiguration_ARM(generators)
	redirectConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(RedirectConfiguration_ARM{}), generators)

	return redirectConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRedirectConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRedirectConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHost"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.OneConstOf(RedirectConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorRedirectConfiguration)
	gens["RedirectProtocol"] = gen.PtrOf(gen.OneConstOf(RedirectConfiguration_RedirectProtocol_HttpOnly, RedirectConfiguration_RedirectProtocol_HttpsOnly, RedirectConfiguration_RedirectProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		RedirectConfiguration_RedirectType_Found,
		RedirectConfiguration_RedirectType_Moved,
		RedirectConfiguration_RedirectType_PermanentRedirect,
		RedirectConfiguration_RedirectType_TemporaryRedirect))
}

func Test_CacheConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration_ARM, CacheConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration_ARM runs a test to see if a specific instance of CacheConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration_ARM(subject CacheConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration_ARM instances for property testing - lazily instantiated by
// CacheConfiguration_ARMGenerator()
var cacheConfiguration_ARMGenerator gopter.Gen

// CacheConfiguration_ARMGenerator returns a generator of CacheConfiguration_ARM instances for property testing.
func CacheConfiguration_ARMGenerator() gopter.Gen {
	if cacheConfiguration_ARMGenerator != nil {
		return cacheConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration_ARM(generators)
	cacheConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration_ARM{}), generators)

	return cacheConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["DynamicCompression"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_DynamicCompression_Disabled, CacheConfiguration_DynamicCompression_Enabled))
	gens["QueryParameterStripDirective"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryParameterStripDirective_StripAll,
		CacheConfiguration_QueryParameterStripDirective_StripAllExcept,
		CacheConfiguration_QueryParameterStripDirective_StripNone,
		CacheConfiguration_QueryParameterStripDirective_StripOnly))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
}
