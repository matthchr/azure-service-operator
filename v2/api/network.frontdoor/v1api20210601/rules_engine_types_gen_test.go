// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20210601/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_RulesEngine_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngine to hub returns original",
		prop.ForAll(RunResourceConversionTestForRulesEngine, RulesEngineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForRulesEngine tests if a specific instance of RulesEngine round trips to the hub storage version and back losslessly
func RunResourceConversionTestForRulesEngine(subject RulesEngine) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.RulesEngine
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual RulesEngine
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngine_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngine to RulesEngine via AssignProperties_To_RulesEngine & AssignProperties_From_RulesEngine returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngine, RulesEngineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngine tests if a specific instance of RulesEngine can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngine(subject RulesEngine) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngine
	err := copied.AssignProperties_To_RulesEngine(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngine
	err = actual.AssignProperties_From_RulesEngine(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngine, RulesEngineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngine runs a test to see if a specific instance of RulesEngine round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngine(subject RulesEngine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngine instances for property testing - lazily instantiated by RulesEngineGenerator()
var rulesEngineGenerator gopter.Gen

// RulesEngineGenerator returns a generator of RulesEngine instances for property testing.
func RulesEngineGenerator() gopter.Gen {
	if rulesEngineGenerator != nil {
		return rulesEngineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngine(generators)
	rulesEngineGenerator = gen.Struct(reflect.TypeOf(RulesEngine{}), generators)

	return rulesEngineGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngine(gens map[string]gopter.Gen) {
	gens["Spec"] = FrontDoors_RulesEngine_SpecGenerator()
	gens["Status"] = FrontDoors_RulesEngine_STATUSGenerator()
}

func Test_FrontDoors_RulesEngine_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoors_RulesEngine_Spec to FrontDoors_RulesEngine_Spec via AssignProperties_To_FrontDoors_RulesEngine_Spec & AssignProperties_From_FrontDoors_RulesEngine_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoors_RulesEngine_Spec, FrontDoors_RulesEngine_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoors_RulesEngine_Spec tests if a specific instance of FrontDoors_RulesEngine_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoors_RulesEngine_Spec(subject FrontDoors_RulesEngine_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontDoors_RulesEngine_Spec
	err := copied.AssignProperties_To_FrontDoors_RulesEngine_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoors_RulesEngine_Spec
	err = actual.AssignProperties_From_FrontDoors_RulesEngine_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoors_RulesEngine_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoors_RulesEngine_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoors_RulesEngine_Spec, FrontDoors_RulesEngine_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoors_RulesEngine_Spec runs a test to see if a specific instance of FrontDoors_RulesEngine_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoors_RulesEngine_Spec(subject FrontDoors_RulesEngine_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoors_RulesEngine_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoors_RulesEngine_Spec instances for property testing - lazily instantiated by
// FrontDoors_RulesEngine_SpecGenerator()
var frontDoors_RulesEngine_SpecGenerator gopter.Gen

// FrontDoors_RulesEngine_SpecGenerator returns a generator of FrontDoors_RulesEngine_Spec instances for property testing.
// We first initialize frontDoors_RulesEngine_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoors_RulesEngine_SpecGenerator() gopter.Gen {
	if frontDoors_RulesEngine_SpecGenerator != nil {
		return frontDoors_RulesEngine_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	frontDoors_RulesEngine_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec(generators)
	frontDoors_RulesEngine_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_Spec{}), generators)

	return frontDoors_RulesEngine_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_Spec(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(RulesEngineRuleGenerator())
}

func Test_FrontDoors_RulesEngine_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoors_RulesEngine_STATUS to FrontDoors_RulesEngine_STATUS via AssignProperties_To_FrontDoors_RulesEngine_STATUS & AssignProperties_From_FrontDoors_RulesEngine_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoors_RulesEngine_STATUS, FrontDoors_RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoors_RulesEngine_STATUS tests if a specific instance of FrontDoors_RulesEngine_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoors_RulesEngine_STATUS(subject FrontDoors_RulesEngine_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontDoors_RulesEngine_STATUS
	err := copied.AssignProperties_To_FrontDoors_RulesEngine_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoors_RulesEngine_STATUS
	err = actual.AssignProperties_From_FrontDoors_RulesEngine_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoors_RulesEngine_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoors_RulesEngine_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS, FrontDoors_RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS runs a test to see if a specific instance of FrontDoors_RulesEngine_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoors_RulesEngine_STATUS(subject FrontDoors_RulesEngine_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoors_RulesEngine_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoors_RulesEngine_STATUS instances for property testing - lazily instantiated by
// FrontDoors_RulesEngine_STATUSGenerator()
var frontDoors_RulesEngine_STATUSGenerator gopter.Gen

// FrontDoors_RulesEngine_STATUSGenerator returns a generator of FrontDoors_RulesEngine_STATUS instances for property testing.
// We first initialize frontDoors_RulesEngine_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoors_RulesEngine_STATUSGenerator() gopter.Gen {
	if frontDoors_RulesEngine_STATUSGenerator != nil {
		return frontDoors_RulesEngine_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	frontDoors_RulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(generators)
	frontDoors_RulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoors_RulesEngine_STATUS{}), generators)

	return frontDoors_RulesEngine_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		ResourceState_STATUS_Creating,
		ResourceState_STATUS_Deleting,
		ResourceState_STATUS_Disabled,
		ResourceState_STATUS_Disabling,
		ResourceState_STATUS_Enabled,
		ResourceState_STATUS_Enabling,
		ResourceState_STATUS_Migrated,
		ResourceState_STATUS_Migrating))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoors_RulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(RulesEngineRule_STATUSGenerator())
}

func Test_RulesEngineRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineRule to RulesEngineRule via AssignProperties_To_RulesEngineRule & AssignProperties_From_RulesEngineRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineRule, RulesEngineRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineRule tests if a specific instance of RulesEngineRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineRule(subject RulesEngineRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineRule
	err := copied.AssignProperties_To_RulesEngineRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineRule
	err = actual.AssignProperties_From_RulesEngineRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineRule, RulesEngineRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineRule runs a test to see if a specific instance of RulesEngineRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineRule(subject RulesEngineRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineRule instances for property testing - lazily instantiated by RulesEngineRuleGenerator()
var rulesEngineRuleGenerator gopter.Gen

// RulesEngineRuleGenerator returns a generator of RulesEngineRule instances for property testing.
// We first initialize rulesEngineRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RulesEngineRuleGenerator() gopter.Gen {
	if rulesEngineRuleGenerator != nil {
		return rulesEngineRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule(generators)
	rulesEngineRuleGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule(generators)
	AddRelatedPropertyGeneratorsForRulesEngineRule(generators)
	rulesEngineRuleGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule{}), generators)

	return rulesEngineRuleGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineRule(gens map[string]gopter.Gen) {
	gens["MatchProcessingBehavior"] = gen.PtrOf(gen.OneConstOf(RulesEngineRule_MatchProcessingBehavior_Continue, RulesEngineRule_MatchProcessingBehavior_Stop))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForRulesEngineRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(RulesEngineActionGenerator())
	gens["MatchConditions"] = gen.SliceOf(RulesEngineMatchConditionGenerator())
}

func Test_RulesEngineRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineRule_STATUS to RulesEngineRule_STATUS via AssignProperties_To_RulesEngineRule_STATUS & AssignProperties_From_RulesEngineRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineRule_STATUS, RulesEngineRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineRule_STATUS tests if a specific instance of RulesEngineRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineRule_STATUS(subject RulesEngineRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineRule_STATUS
	err := copied.AssignProperties_To_RulesEngineRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineRule_STATUS
	err = actual.AssignProperties_From_RulesEngineRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineRule_STATUS, RulesEngineRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineRule_STATUS runs a test to see if a specific instance of RulesEngineRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineRule_STATUS(subject RulesEngineRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineRule_STATUS instances for property testing - lazily instantiated by
// RulesEngineRule_STATUSGenerator()
var rulesEngineRule_STATUSGenerator gopter.Gen

// RulesEngineRule_STATUSGenerator returns a generator of RulesEngineRule_STATUS instances for property testing.
// We first initialize rulesEngineRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RulesEngineRule_STATUSGenerator() gopter.Gen {
	if rulesEngineRule_STATUSGenerator != nil {
		return rulesEngineRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	rulesEngineRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS(generators)
	rulesEngineRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineRule_STATUS{}), generators)

	return rulesEngineRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineRule_STATUS(gens map[string]gopter.Gen) {
	gens["MatchProcessingBehavior"] = gen.PtrOf(gen.OneConstOf(RulesEngineRule_MatchProcessingBehavior_STATUS_Continue, RulesEngineRule_MatchProcessingBehavior_STATUS_Stop))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(RulesEngineAction_STATUSGenerator())
	gens["MatchConditions"] = gen.SliceOf(RulesEngineMatchCondition_STATUSGenerator())
}

func Test_RulesEngineAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineAction to RulesEngineAction via AssignProperties_To_RulesEngineAction & AssignProperties_From_RulesEngineAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineAction, RulesEngineActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineAction tests if a specific instance of RulesEngineAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineAction(subject RulesEngineAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineAction
	err := copied.AssignProperties_To_RulesEngineAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineAction
	err = actual.AssignProperties_From_RulesEngineAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineAction, RulesEngineActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineAction runs a test to see if a specific instance of RulesEngineAction round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineAction(subject RulesEngineAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineAction instances for property testing - lazily instantiated by RulesEngineActionGenerator()
var rulesEngineActionGenerator gopter.Gen

// RulesEngineActionGenerator returns a generator of RulesEngineAction instances for property testing.
func RulesEngineActionGenerator() gopter.Gen {
	if rulesEngineActionGenerator != nil {
		return rulesEngineActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngineAction(generators)
	rulesEngineActionGenerator = gen.Struct(reflect.TypeOf(RulesEngineAction{}), generators)

	return rulesEngineActionGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngineAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineAction(gens map[string]gopter.Gen) {
	gens["RequestHeaderActions"] = gen.SliceOf(HeaderActionGenerator())
	gens["ResponseHeaderActions"] = gen.SliceOf(HeaderActionGenerator())
	gens["RouteConfigurationOverride"] = gen.PtrOf(RouteConfigurationGenerator())
}

func Test_RulesEngineAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineAction_STATUS to RulesEngineAction_STATUS via AssignProperties_To_RulesEngineAction_STATUS & AssignProperties_From_RulesEngineAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineAction_STATUS, RulesEngineAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineAction_STATUS tests if a specific instance of RulesEngineAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineAction_STATUS(subject RulesEngineAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineAction_STATUS
	err := copied.AssignProperties_To_RulesEngineAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineAction_STATUS
	err = actual.AssignProperties_From_RulesEngineAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineAction_STATUS, RulesEngineAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineAction_STATUS runs a test to see if a specific instance of RulesEngineAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineAction_STATUS(subject RulesEngineAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineAction_STATUS instances for property testing - lazily instantiated by
// RulesEngineAction_STATUSGenerator()
var rulesEngineAction_STATUSGenerator gopter.Gen

// RulesEngineAction_STATUSGenerator returns a generator of RulesEngineAction_STATUS instances for property testing.
func RulesEngineAction_STATUSGenerator() gopter.Gen {
	if rulesEngineAction_STATUSGenerator != nil {
		return rulesEngineAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS(generators)
	rulesEngineAction_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineAction_STATUS{}), generators)

	return rulesEngineAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRulesEngineAction_STATUS(gens map[string]gopter.Gen) {
	gens["RequestHeaderActions"] = gen.SliceOf(HeaderAction_STATUSGenerator())
	gens["ResponseHeaderActions"] = gen.SliceOf(HeaderAction_STATUSGenerator())
	gens["RouteConfigurationOverride"] = gen.PtrOf(RouteConfiguration_STATUSGenerator())
}

func Test_RulesEngineMatchCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineMatchCondition to RulesEngineMatchCondition via AssignProperties_To_RulesEngineMatchCondition & AssignProperties_From_RulesEngineMatchCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineMatchCondition, RulesEngineMatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineMatchCondition tests if a specific instance of RulesEngineMatchCondition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineMatchCondition(subject RulesEngineMatchCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineMatchCondition
	err := copied.AssignProperties_To_RulesEngineMatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineMatchCondition
	err = actual.AssignProperties_From_RulesEngineMatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineMatchCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineMatchCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineMatchCondition, RulesEngineMatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineMatchCondition runs a test to see if a specific instance of RulesEngineMatchCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineMatchCondition(subject RulesEngineMatchCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineMatchCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineMatchCondition instances for property testing - lazily instantiated by
// RulesEngineMatchConditionGenerator()
var rulesEngineMatchConditionGenerator gopter.Gen

// RulesEngineMatchConditionGenerator returns a generator of RulesEngineMatchCondition instances for property testing.
func RulesEngineMatchConditionGenerator() gopter.Gen {
	if rulesEngineMatchConditionGenerator != nil {
		return rulesEngineMatchConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineMatchCondition(generators)
	rulesEngineMatchConditionGenerator = gen.Struct(reflect.TypeOf(RulesEngineMatchCondition{}), generators)

	return rulesEngineMatchConditionGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineMatchCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineMatchCondition(gens map[string]gopter.Gen) {
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["RulesEngineMatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["RulesEngineMatchVariable"] = gen.PtrOf(gen.OneConstOf(
		RulesEngineMatchCondition_RulesEngineMatchVariable_IsMobile,
		RulesEngineMatchCondition_RulesEngineMatchVariable_PostArgs,
		RulesEngineMatchCondition_RulesEngineMatchVariable_QueryString,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RemoteAddr,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestBody,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestFilename,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestFilenameExtension,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestHeader,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestMethod,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestPath,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestScheme,
		RulesEngineMatchCondition_RulesEngineMatchVariable_RequestUri))
	gens["RulesEngineOperator"] = gen.PtrOf(gen.OneConstOf(
		RulesEngineMatchCondition_RulesEngineOperator_Any,
		RulesEngineMatchCondition_RulesEngineOperator_BeginsWith,
		RulesEngineMatchCondition_RulesEngineOperator_Contains,
		RulesEngineMatchCondition_RulesEngineOperator_EndsWith,
		RulesEngineMatchCondition_RulesEngineOperator_Equal,
		RulesEngineMatchCondition_RulesEngineOperator_GeoMatch,
		RulesEngineMatchCondition_RulesEngineOperator_GreaterThan,
		RulesEngineMatchCondition_RulesEngineOperator_GreaterThanOrEqual,
		RulesEngineMatchCondition_RulesEngineOperator_IPMatch,
		RulesEngineMatchCondition_RulesEngineOperator_LessThan,
		RulesEngineMatchCondition_RulesEngineOperator_LessThanOrEqual))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
}

func Test_RulesEngineMatchCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngineMatchCondition_STATUS to RulesEngineMatchCondition_STATUS via AssignProperties_To_RulesEngineMatchCondition_STATUS & AssignProperties_From_RulesEngineMatchCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngineMatchCondition_STATUS, RulesEngineMatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngineMatchCondition_STATUS tests if a specific instance of RulesEngineMatchCondition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngineMatchCondition_STATUS(subject RulesEngineMatchCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngineMatchCondition_STATUS
	err := copied.AssignProperties_To_RulesEngineMatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngineMatchCondition_STATUS
	err = actual.AssignProperties_From_RulesEngineMatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngineMatchCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngineMatchCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngineMatchCondition_STATUS, RulesEngineMatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngineMatchCondition_STATUS runs a test to see if a specific instance of RulesEngineMatchCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngineMatchCondition_STATUS(subject RulesEngineMatchCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngineMatchCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngineMatchCondition_STATUS instances for property testing - lazily instantiated by
// RulesEngineMatchCondition_STATUSGenerator()
var rulesEngineMatchCondition_STATUSGenerator gopter.Gen

// RulesEngineMatchCondition_STATUSGenerator returns a generator of RulesEngineMatchCondition_STATUS instances for property testing.
func RulesEngineMatchCondition_STATUSGenerator() gopter.Gen {
	if rulesEngineMatchCondition_STATUSGenerator != nil {
		return rulesEngineMatchCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS(generators)
	rulesEngineMatchCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngineMatchCondition_STATUS{}), generators)

	return rulesEngineMatchCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngineMatchCondition_STATUS(gens map[string]gopter.Gen) {
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["RulesEngineMatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["RulesEngineMatchVariable"] = gen.PtrOf(gen.OneConstOf(
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_IsMobile,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_PostArgs,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_QueryString,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RemoteAddr,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestBody,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestFilename,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestFilenameExtension,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestHeader,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestMethod,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestPath,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestScheme,
		RulesEngineMatchCondition_RulesEngineMatchVariable_STATUS_RequestUri))
	gens["RulesEngineOperator"] = gen.PtrOf(gen.OneConstOf(
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_Any,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_BeginsWith,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_Contains,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_EndsWith,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_Equal,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_GeoMatch,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_GreaterThan,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_GreaterThanOrEqual,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_IPMatch,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_LessThan,
		RulesEngineMatchCondition_RulesEngineOperator_STATUS_LessThanOrEqual))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
}

func Test_HeaderAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderAction to HeaderAction via AssignProperties_To_HeaderAction & AssignProperties_From_HeaderAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderAction, HeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderAction tests if a specific instance of HeaderAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHeaderAction(subject HeaderAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HeaderAction
	err := copied.AssignProperties_To_HeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderAction
	err = actual.AssignProperties_From_HeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderAction, HeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderAction runs a test to see if a specific instance of HeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderAction(subject HeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderAction instances for property testing - lazily instantiated by HeaderActionGenerator()
var headerActionGenerator gopter.Gen

// HeaderActionGenerator returns a generator of HeaderAction instances for property testing.
func HeaderActionGenerator() gopter.Gen {
	if headerActionGenerator != nil {
		return headerActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderAction(generators)
	headerActionGenerator = gen.Struct(reflect.TypeOf(HeaderAction{}), generators)

	return headerActionGenerator
}

// AddIndependentPropertyGeneratorsForHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderAction(gens map[string]gopter.Gen) {
	gens["HeaderActionType"] = gen.PtrOf(gen.OneConstOf(HeaderAction_HeaderActionType_Append, HeaderAction_HeaderActionType_Delete, HeaderAction_HeaderActionType_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HeaderAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderAction_STATUS to HeaderAction_STATUS via AssignProperties_To_HeaderAction_STATUS & AssignProperties_From_HeaderAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderAction_STATUS, HeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderAction_STATUS tests if a specific instance of HeaderAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHeaderAction_STATUS(subject HeaderAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HeaderAction_STATUS
	err := copied.AssignProperties_To_HeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderAction_STATUS
	err = actual.AssignProperties_From_HeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderAction_STATUS, HeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderAction_STATUS runs a test to see if a specific instance of HeaderAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderAction_STATUS(subject HeaderAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderAction_STATUS instances for property testing - lazily instantiated by
// HeaderAction_STATUSGenerator()
var headerAction_STATUSGenerator gopter.Gen

// HeaderAction_STATUSGenerator returns a generator of HeaderAction_STATUS instances for property testing.
func HeaderAction_STATUSGenerator() gopter.Gen {
	if headerAction_STATUSGenerator != nil {
		return headerAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderAction_STATUS(generators)
	headerAction_STATUSGenerator = gen.Struct(reflect.TypeOf(HeaderAction_STATUS{}), generators)

	return headerAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHeaderAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["HeaderActionType"] = gen.PtrOf(gen.OneConstOf(HeaderAction_HeaderActionType_STATUS_Append, HeaderAction_HeaderActionType_STATUS_Delete, HeaderAction_HeaderActionType_STATUS_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
