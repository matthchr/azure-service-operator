// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20210601/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_FrontDoor_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoor to hub returns original",
		prop.ForAll(RunResourceConversionTestForFrontDoor, FrontDoorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForFrontDoor tests if a specific instance of FrontDoor round trips to the hub storage version and back losslessly
func RunResourceConversionTestForFrontDoor(subject FrontDoor) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.FrontDoor
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual FrontDoor
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoor_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoor to FrontDoor via AssignProperties_To_FrontDoor & AssignProperties_From_FrontDoor returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoor, FrontDoorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoor tests if a specific instance of FrontDoor can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoor(subject FrontDoor) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontDoor
	err := copied.AssignProperties_To_FrontDoor(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoor
	err = actual.AssignProperties_From_FrontDoor(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoor_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor, FrontDoorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor runs a test to see if a specific instance of FrontDoor round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor(subject FrontDoor) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor instances for property testing - lazily instantiated by FrontDoorGenerator()
var frontDoorGenerator gopter.Gen

// FrontDoorGenerator returns a generator of FrontDoor instances for property testing.
func FrontDoorGenerator() gopter.Gen {
	if frontDoorGenerator != nil {
		return frontDoorGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFrontDoor(generators)
	frontDoorGenerator = gen.Struct(reflect.TypeOf(FrontDoor{}), generators)

	return frontDoorGenerator
}

// AddRelatedPropertyGeneratorsForFrontDoor is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor(gens map[string]gopter.Gen) {
	gens["Spec"] = FrontDoor_SpecGenerator()
	gens["Status"] = FrontDoor_STATUSGenerator()
}

func Test_FrontDoor_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoor_Spec to FrontDoor_Spec via AssignProperties_To_FrontDoor_Spec & AssignProperties_From_FrontDoor_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoor_Spec, FrontDoor_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoor_Spec tests if a specific instance of FrontDoor_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoor_Spec(subject FrontDoor_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontDoor_Spec
	err := copied.AssignProperties_To_FrontDoor_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoor_Spec
	err = actual.AssignProperties_From_FrontDoor_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoor_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor_Spec, FrontDoor_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor_Spec runs a test to see if a specific instance of FrontDoor_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor_Spec(subject FrontDoor_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor_Spec instances for property testing - lazily instantiated by FrontDoor_SpecGenerator()
var frontDoor_SpecGenerator gopter.Gen

// FrontDoor_SpecGenerator returns a generator of FrontDoor_Spec instances for property testing.
// We first initialize frontDoor_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoor_SpecGenerator() gopter.Gen {
	if frontDoor_SpecGenerator != nil {
		return frontDoor_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec(generators)
	frontDoor_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_Spec(generators)
	AddRelatedPropertyGeneratorsForFrontDoor_Spec(generators)
	frontDoor_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoor_Spec{}), generators)

	return frontDoor_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoor_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoor_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(FrontDoorProperties_EnabledState_Disabled, FrontDoorProperties_EnabledState_Enabled))
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoor_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor_Spec(gens map[string]gopter.Gen) {
	gens["BackendPools"] = gen.SliceOf(BackendPoolGenerator())
	gens["BackendPoolsSettings"] = gen.PtrOf(BackendPoolsSettingsGenerator())
	gens["FrontendEndpoints"] = gen.SliceOf(FrontendEndpointGenerator())
	gens["HealthProbeSettings"] = gen.SliceOf(HealthProbeSettingsModelGenerator())
	gens["LoadBalancingSettings"] = gen.SliceOf(LoadBalancingSettingsModelGenerator())
	gens["RoutingRules"] = gen.SliceOf(RoutingRuleGenerator())
}

func Test_FrontDoor_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoor_STATUS to FrontDoor_STATUS via AssignProperties_To_FrontDoor_STATUS & AssignProperties_From_FrontDoor_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoor_STATUS, FrontDoor_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoor_STATUS tests if a specific instance of FrontDoor_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoor_STATUS(subject FrontDoor_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontDoor_STATUS
	err := copied.AssignProperties_To_FrontDoor_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoor_STATUS
	err = actual.AssignProperties_From_FrontDoor_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoor_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoor_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoor_STATUS, FrontDoor_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoor_STATUS runs a test to see if a specific instance of FrontDoor_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoor_STATUS(subject FrontDoor_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoor_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoor_STATUS instances for property testing - lazily instantiated by FrontDoor_STATUSGenerator()
var frontDoor_STATUSGenerator gopter.Gen

// FrontDoor_STATUSGenerator returns a generator of FrontDoor_STATUS instances for property testing.
// We first initialize frontDoor_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoor_STATUSGenerator() gopter.Gen {
	if frontDoor_STATUSGenerator != nil {
		return frontDoor_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_STATUS(generators)
	frontDoor_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoor_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoor_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontDoor_STATUS(generators)
	frontDoor_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoor_STATUS{}), generators)

	return frontDoor_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoor_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoor_STATUS(gens map[string]gopter.Gen) {
	gens["Cname"] = gen.PtrOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(FrontDoorProperties_EnabledState_STATUS_Disabled, FrontDoorProperties_EnabledState_STATUS_Enabled))
	gens["ExtendedProperties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["FrontdoorId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		ResourceState_STATUS_Creating,
		ResourceState_STATUS_Deleting,
		ResourceState_STATUS_Disabled,
		ResourceState_STATUS_Disabling,
		ResourceState_STATUS_Enabled,
		ResourceState_STATUS_Enabling,
		ResourceState_STATUS_Migrated,
		ResourceState_STATUS_Migrating))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoor_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoor_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPools"] = gen.SliceOf(BackendPool_STATUSGenerator())
	gens["BackendPoolsSettings"] = gen.PtrOf(BackendPoolsSettings_STATUSGenerator())
	gens["FrontendEndpoints"] = gen.SliceOf(FrontendEndpoint_STATUSGenerator())
	gens["HealthProbeSettings"] = gen.SliceOf(HealthProbeSettingsModel_STATUSGenerator())
	gens["LoadBalancingSettings"] = gen.SliceOf(LoadBalancingSettingsModel_STATUSGenerator())
	gens["RoutingRules"] = gen.SliceOf(RoutingRule_STATUSGenerator())
	gens["RulesEngines"] = gen.SliceOf(RulesEngine_STATUSGenerator())
}

func Test_BackendPool_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendPool to BackendPool via AssignProperties_To_BackendPool & AssignProperties_From_BackendPool returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendPool, BackendPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendPool tests if a specific instance of BackendPool can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackendPool(subject BackendPool) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.BackendPool
	err := copied.AssignProperties_To_BackendPool(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendPool
	err = actual.AssignProperties_From_BackendPool(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPool, BackendPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPool runs a test to see if a specific instance of BackendPool round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPool(subject BackendPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPool instances for property testing - lazily instantiated by BackendPoolGenerator()
var backendPoolGenerator gopter.Gen

// BackendPoolGenerator returns a generator of BackendPool instances for property testing.
// We first initialize backendPoolGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackendPoolGenerator() gopter.Gen {
	if backendPoolGenerator != nil {
		return backendPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool(generators)
	backendPoolGenerator = gen.Struct(reflect.TypeOf(BackendPool{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool(generators)
	AddRelatedPropertyGeneratorsForBackendPool(generators)
	backendPoolGenerator = gen.Struct(reflect.TypeOf(BackendPool{}), generators)

	return backendPoolGenerator
}

// AddIndependentPropertyGeneratorsForBackendPool is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPool(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackendPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendPool(gens map[string]gopter.Gen) {
	gens["Backends"] = gen.SliceOf(BackendGenerator())
	gens["HealthProbeSettings"] = gen.PtrOf(SubResourceGenerator())
	gens["LoadBalancingSettings"] = gen.PtrOf(SubResourceGenerator())
}

func Test_BackendPool_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendPool_STATUS to BackendPool_STATUS via AssignProperties_To_BackendPool_STATUS & AssignProperties_From_BackendPool_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendPool_STATUS, BackendPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendPool_STATUS tests if a specific instance of BackendPool_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackendPool_STATUS(subject BackendPool_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.BackendPool_STATUS
	err := copied.AssignProperties_To_BackendPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendPool_STATUS
	err = actual.AssignProperties_From_BackendPool_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendPool_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPool_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPool_STATUS, BackendPool_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPool_STATUS runs a test to see if a specific instance of BackendPool_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPool_STATUS(subject BackendPool_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPool_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPool_STATUS instances for property testing - lazily instantiated by BackendPool_STATUSGenerator()
var backendPool_STATUSGenerator gopter.Gen

// BackendPool_STATUSGenerator returns a generator of BackendPool_STATUS instances for property testing.
func BackendPool_STATUSGenerator() gopter.Gen {
	if backendPool_STATUSGenerator != nil {
		return backendPool_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPool_STATUS(generators)
	backendPool_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendPool_STATUS{}), generators)

	return backendPool_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackendPool_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPool_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackendPoolsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendPoolsSettings to BackendPoolsSettings via AssignProperties_To_BackendPoolsSettings & AssignProperties_From_BackendPoolsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendPoolsSettings, BackendPoolsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendPoolsSettings tests if a specific instance of BackendPoolsSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackendPoolsSettings(subject BackendPoolsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.BackendPoolsSettings
	err := copied.AssignProperties_To_BackendPoolsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendPoolsSettings
	err = actual.AssignProperties_From_BackendPoolsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendPoolsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolsSettings, BackendPoolsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolsSettings runs a test to see if a specific instance of BackendPoolsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolsSettings(subject BackendPoolsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolsSettings instances for property testing - lazily instantiated by
// BackendPoolsSettingsGenerator()
var backendPoolsSettingsGenerator gopter.Gen

// BackendPoolsSettingsGenerator returns a generator of BackendPoolsSettings instances for property testing.
func BackendPoolsSettingsGenerator() gopter.Gen {
	if backendPoolsSettingsGenerator != nil {
		return backendPoolsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPoolsSettings(generators)
	backendPoolsSettingsGenerator = gen.Struct(reflect.TypeOf(BackendPoolsSettings{}), generators)

	return backendPoolsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForBackendPoolsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPoolsSettings(gens map[string]gopter.Gen) {
	gens["EnforceCertificateNameCheck"] = gen.PtrOf(gen.OneConstOf(BackendPoolsSettings_EnforceCertificateNameCheck_Disabled, BackendPoolsSettings_EnforceCertificateNameCheck_Enabled))
	gens["SendRecvTimeoutSeconds"] = gen.PtrOf(gen.Int())
}

func Test_BackendPoolsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendPoolsSettings_STATUS to BackendPoolsSettings_STATUS via AssignProperties_To_BackendPoolsSettings_STATUS & AssignProperties_From_BackendPoolsSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendPoolsSettings_STATUS, BackendPoolsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendPoolsSettings_STATUS tests if a specific instance of BackendPoolsSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackendPoolsSettings_STATUS(subject BackendPoolsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.BackendPoolsSettings_STATUS
	err := copied.AssignProperties_To_BackendPoolsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendPoolsSettings_STATUS
	err = actual.AssignProperties_From_BackendPoolsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendPoolsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendPoolsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendPoolsSettings_STATUS, BackendPoolsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendPoolsSettings_STATUS runs a test to see if a specific instance of BackendPoolsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendPoolsSettings_STATUS(subject BackendPoolsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendPoolsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendPoolsSettings_STATUS instances for property testing - lazily instantiated by
// BackendPoolsSettings_STATUSGenerator()
var backendPoolsSettings_STATUSGenerator gopter.Gen

// BackendPoolsSettings_STATUSGenerator returns a generator of BackendPoolsSettings_STATUS instances for property testing.
func BackendPoolsSettings_STATUSGenerator() gopter.Gen {
	if backendPoolsSettings_STATUSGenerator != nil {
		return backendPoolsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS(generators)
	backendPoolsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(BackendPoolsSettings_STATUS{}), generators)

	return backendPoolsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackendPoolsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["EnforceCertificateNameCheck"] = gen.PtrOf(gen.OneConstOf(BackendPoolsSettings_EnforceCertificateNameCheck_STATUS_Disabled, BackendPoolsSettings_EnforceCertificateNameCheck_STATUS_Enabled))
	gens["SendRecvTimeoutSeconds"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpoint_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendEndpoint to FrontendEndpoint via AssignProperties_To_FrontendEndpoint & AssignProperties_From_FrontendEndpoint returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendEndpoint, FrontendEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendEndpoint tests if a specific instance of FrontendEndpoint can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontendEndpoint(subject FrontendEndpoint) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontendEndpoint
	err := copied.AssignProperties_To_FrontendEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendEndpoint
	err = actual.AssignProperties_From_FrontendEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendEndpoint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpoint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpoint, FrontendEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpoint runs a test to see if a specific instance of FrontendEndpoint round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpoint(subject FrontendEndpoint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpoint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpoint instances for property testing - lazily instantiated by FrontendEndpointGenerator()
var frontendEndpointGenerator gopter.Gen

// FrontendEndpointGenerator returns a generator of FrontendEndpoint instances for property testing.
// We first initialize frontendEndpointGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontendEndpointGenerator() gopter.Gen {
	if frontendEndpointGenerator != nil {
		return frontendEndpointGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint(generators)
	frontendEndpointGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint(generators)
	AddRelatedPropertyGeneratorsForFrontendEndpoint(generators)
	frontendEndpointGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint{}), generators)

	return frontendEndpointGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpoint is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpoint(gens map[string]gopter.Gen) {
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SessionAffinityEnabledState"] = gen.PtrOf(gen.OneConstOf(FrontendEndpointProperties_SessionAffinityEnabledState_Disabled, FrontendEndpointProperties_SessionAffinityEnabledState_Enabled))
	gens["SessionAffinityTtlSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFrontendEndpoint is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontendEndpoint(gens map[string]gopter.Gen) {
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_FrontendEndpoint_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendEndpoint_STATUS to FrontendEndpoint_STATUS via AssignProperties_To_FrontendEndpoint_STATUS & AssignProperties_From_FrontendEndpoint_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendEndpoint_STATUS, FrontendEndpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendEndpoint_STATUS tests if a specific instance of FrontendEndpoint_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontendEndpoint_STATUS(subject FrontendEndpoint_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontendEndpoint_STATUS
	err := copied.AssignProperties_To_FrontendEndpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendEndpoint_STATUS
	err = actual.AssignProperties_From_FrontendEndpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendEndpoint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpoint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpoint_STATUS, FrontendEndpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpoint_STATUS runs a test to see if a specific instance of FrontendEndpoint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpoint_STATUS(subject FrontendEndpoint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpoint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpoint_STATUS instances for property testing - lazily instantiated by
// FrontendEndpoint_STATUSGenerator()
var frontendEndpoint_STATUSGenerator gopter.Gen

// FrontendEndpoint_STATUSGenerator returns a generator of FrontendEndpoint_STATUS instances for property testing.
func FrontendEndpoint_STATUSGenerator() gopter.Gen {
	if frontendEndpoint_STATUSGenerator != nil {
		return frontendEndpoint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS(generators)
	frontendEndpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontendEndpoint_STATUS{}), generators)

	return frontendEndpoint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpoint_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_HealthProbeSettingsModel_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeSettingsModel to HealthProbeSettingsModel via AssignProperties_To_HealthProbeSettingsModel & AssignProperties_From_HealthProbeSettingsModel returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeSettingsModel, HealthProbeSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeSettingsModel tests if a specific instance of HealthProbeSettingsModel can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeSettingsModel(subject HealthProbeSettingsModel) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeSettingsModel
	err := copied.AssignProperties_To_HealthProbeSettingsModel(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeSettingsModel
	err = actual.AssignProperties_From_HealthProbeSettingsModel(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeSettingsModel_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsModel via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsModel, HealthProbeSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsModel runs a test to see if a specific instance of HealthProbeSettingsModel round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsModel(subject HealthProbeSettingsModel) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsModel
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsModel instances for property testing - lazily instantiated by
// HealthProbeSettingsModelGenerator()
var healthProbeSettingsModelGenerator gopter.Gen

// HealthProbeSettingsModelGenerator returns a generator of HealthProbeSettingsModel instances for property testing.
func HealthProbeSettingsModelGenerator() gopter.Gen {
	if healthProbeSettingsModelGenerator != nil {
		return healthProbeSettingsModelGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel(generators)
	healthProbeSettingsModelGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel{}), generators)

	return healthProbeSettingsModelGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsModel is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsModel(gens map[string]gopter.Gen) {
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_EnabledState_Disabled, HealthProbeSettingsProperties_EnabledState_Enabled))
	gens["HealthProbeMethod"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_HealthProbeMethod_GET, HealthProbeSettingsProperties_HealthProbeMethod_HEAD))
	gens["IntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeSettingsProperties_Protocol_Http, HealthProbeSettingsProperties_Protocol_Https))
}

func Test_HealthProbeSettingsModel_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeSettingsModel_STATUS to HealthProbeSettingsModel_STATUS via AssignProperties_To_HealthProbeSettingsModel_STATUS & AssignProperties_From_HealthProbeSettingsModel_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeSettingsModel_STATUS, HealthProbeSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeSettingsModel_STATUS tests if a specific instance of HealthProbeSettingsModel_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeSettingsModel_STATUS(subject HealthProbeSettingsModel_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeSettingsModel_STATUS
	err := copied.AssignProperties_To_HealthProbeSettingsModel_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeSettingsModel_STATUS
	err = actual.AssignProperties_From_HealthProbeSettingsModel_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeSettingsModel_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeSettingsModel_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeSettingsModel_STATUS, HealthProbeSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeSettingsModel_STATUS runs a test to see if a specific instance of HealthProbeSettingsModel_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeSettingsModel_STATUS(subject HealthProbeSettingsModel_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeSettingsModel_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeSettingsModel_STATUS instances for property testing - lazily instantiated by
// HealthProbeSettingsModel_STATUSGenerator()
var healthProbeSettingsModel_STATUSGenerator gopter.Gen

// HealthProbeSettingsModel_STATUSGenerator returns a generator of HealthProbeSettingsModel_STATUS instances for property testing.
func HealthProbeSettingsModel_STATUSGenerator() gopter.Gen {
	if healthProbeSettingsModel_STATUSGenerator != nil {
		return healthProbeSettingsModel_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS(generators)
	healthProbeSettingsModel_STATUSGenerator = gen.Struct(reflect.TypeOf(HealthProbeSettingsModel_STATUS{}), generators)

	return healthProbeSettingsModel_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeSettingsModel_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoadBalancingSettingsModel_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingSettingsModel to LoadBalancingSettingsModel via AssignProperties_To_LoadBalancingSettingsModel & AssignProperties_From_LoadBalancingSettingsModel returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingSettingsModel, LoadBalancingSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingSettingsModel tests if a specific instance of LoadBalancingSettingsModel can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingSettingsModel(subject LoadBalancingSettingsModel) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.LoadBalancingSettingsModel
	err := copied.AssignProperties_To_LoadBalancingSettingsModel(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingSettingsModel
	err = actual.AssignProperties_From_LoadBalancingSettingsModel(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingSettingsModel_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsModel via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsModel, LoadBalancingSettingsModelGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsModel runs a test to see if a specific instance of LoadBalancingSettingsModel round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsModel(subject LoadBalancingSettingsModel) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsModel
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsModel instances for property testing - lazily instantiated by
// LoadBalancingSettingsModelGenerator()
var loadBalancingSettingsModelGenerator gopter.Gen

// LoadBalancingSettingsModelGenerator returns a generator of LoadBalancingSettingsModel instances for property testing.
func LoadBalancingSettingsModelGenerator() gopter.Gen {
	if loadBalancingSettingsModelGenerator != nil {
		return loadBalancingSettingsModelGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel(generators)
	loadBalancingSettingsModelGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel{}), generators)

	return loadBalancingSettingsModelGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel(gens map[string]gopter.Gen) {
	gens["AdditionalLatencyMilliseconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SampleSize"] = gen.PtrOf(gen.Int())
	gens["SuccessfulSamplesRequired"] = gen.PtrOf(gen.Int())
}

func Test_LoadBalancingSettingsModel_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancingSettingsModel_STATUS to LoadBalancingSettingsModel_STATUS via AssignProperties_To_LoadBalancingSettingsModel_STATUS & AssignProperties_From_LoadBalancingSettingsModel_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancingSettingsModel_STATUS, LoadBalancingSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancingSettingsModel_STATUS tests if a specific instance of LoadBalancingSettingsModel_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancingSettingsModel_STATUS(subject LoadBalancingSettingsModel_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.LoadBalancingSettingsModel_STATUS
	err := copied.AssignProperties_To_LoadBalancingSettingsModel_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancingSettingsModel_STATUS
	err = actual.AssignProperties_From_LoadBalancingSettingsModel_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancingSettingsModel_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancingSettingsModel_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS, LoadBalancingSettingsModel_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS runs a test to see if a specific instance of LoadBalancingSettingsModel_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancingSettingsModel_STATUS(subject LoadBalancingSettingsModel_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancingSettingsModel_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancingSettingsModel_STATUS instances for property testing - lazily instantiated by
// LoadBalancingSettingsModel_STATUSGenerator()
var loadBalancingSettingsModel_STATUSGenerator gopter.Gen

// LoadBalancingSettingsModel_STATUSGenerator returns a generator of LoadBalancingSettingsModel_STATUS instances for property testing.
func LoadBalancingSettingsModel_STATUSGenerator() gopter.Gen {
	if loadBalancingSettingsModel_STATUSGenerator != nil {
		return loadBalancingSettingsModel_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS(generators)
	loadBalancingSettingsModel_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancingSettingsModel_STATUS{}), generators)

	return loadBalancingSettingsModel_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoadBalancingSettingsModel_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingRule to RoutingRule via AssignProperties_To_RoutingRule & AssignProperties_From_RoutingRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingRule, RoutingRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingRule tests if a specific instance of RoutingRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingRule(subject RoutingRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RoutingRule
	err := copied.AssignProperties_To_RoutingRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingRule
	err = actual.AssignProperties_From_RoutingRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRule, RoutingRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRule runs a test to see if a specific instance of RoutingRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRule(subject RoutingRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRule instances for property testing - lazily instantiated by RoutingRuleGenerator()
var routingRuleGenerator gopter.Gen

// RoutingRuleGenerator returns a generator of RoutingRule instances for property testing.
// We first initialize routingRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingRuleGenerator() gopter.Gen {
	if routingRuleGenerator != nil {
		return routingRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule(generators)
	routingRuleGenerator = gen.Struct(reflect.TypeOf(RoutingRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule(generators)
	AddRelatedPropertyGeneratorsForRoutingRule(generators)
	routingRuleGenerator = gen.Struct(reflect.TypeOf(RoutingRule{}), generators)

	return routingRuleGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRule(gens map[string]gopter.Gen) {
	gens["AcceptedProtocols"] = gen.SliceOf(gen.OneConstOf(RoutingRuleProperties_AcceptedProtocols_Http, RoutingRuleProperties_AcceptedProtocols_Https))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(RoutingRuleProperties_EnabledState_Disabled, RoutingRuleProperties_EnabledState_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PatternsToMatch"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingRule(gens map[string]gopter.Gen) {
	gens["FrontendEndpoints"] = gen.SliceOf(SubResourceGenerator())
	gens["RouteConfiguration"] = gen.PtrOf(RouteConfigurationGenerator())
	gens["RulesEngine"] = gen.PtrOf(SubResourceGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_RoutingRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingRule_STATUS to RoutingRule_STATUS via AssignProperties_To_RoutingRule_STATUS & AssignProperties_From_RoutingRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingRule_STATUS, RoutingRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingRule_STATUS tests if a specific instance of RoutingRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingRule_STATUS(subject RoutingRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RoutingRule_STATUS
	err := copied.AssignProperties_To_RoutingRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingRule_STATUS
	err = actual.AssignProperties_From_RoutingRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRule_STATUS, RoutingRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRule_STATUS runs a test to see if a specific instance of RoutingRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRule_STATUS(subject RoutingRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRule_STATUS instances for property testing - lazily instantiated by RoutingRule_STATUSGenerator()
var routingRule_STATUSGenerator gopter.Gen

// RoutingRule_STATUSGenerator returns a generator of RoutingRule_STATUS instances for property testing.
func RoutingRule_STATUSGenerator() gopter.Gen {
	if routingRule_STATUSGenerator != nil {
		return routingRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRule_STATUS(generators)
	routingRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingRule_STATUS{}), generators)

	return routingRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRule_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RulesEngine_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RulesEngine_STATUS to RulesEngine_STATUS via AssignProperties_To_RulesEngine_STATUS & AssignProperties_From_RulesEngine_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRulesEngine_STATUS, RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRulesEngine_STATUS tests if a specific instance of RulesEngine_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRulesEngine_STATUS(subject RulesEngine_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RulesEngine_STATUS
	err := copied.AssignProperties_To_RulesEngine_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RulesEngine_STATUS
	err = actual.AssignProperties_From_RulesEngine_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RulesEngine_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RulesEngine_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRulesEngine_STATUS, RulesEngine_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRulesEngine_STATUS runs a test to see if a specific instance of RulesEngine_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRulesEngine_STATUS(subject RulesEngine_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RulesEngine_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RulesEngine_STATUS instances for property testing - lazily instantiated by RulesEngine_STATUSGenerator()
var rulesEngine_STATUSGenerator gopter.Gen

// RulesEngine_STATUSGenerator returns a generator of RulesEngine_STATUS instances for property testing.
func RulesEngine_STATUSGenerator() gopter.Gen {
	if rulesEngine_STATUSGenerator != nil {
		return rulesEngine_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRulesEngine_STATUS(generators)
	rulesEngine_STATUSGenerator = gen.Struct(reflect.TypeOf(RulesEngine_STATUS{}), generators)

	return rulesEngine_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRulesEngine_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRulesEngine_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_Backend_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Backend to Backend via AssignProperties_To_Backend & AssignProperties_From_Backend returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackend, BackendGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackend tests if a specific instance of Backend can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackend(subject Backend) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Backend
	err := copied.AssignProperties_To_Backend(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Backend
	err = actual.AssignProperties_From_Backend(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Backend_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Backend via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackend, BackendGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackend runs a test to see if a specific instance of Backend round trips to JSON and back losslessly
func RunJSONSerializationTestForBackend(subject Backend) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Backend
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Backend instances for property testing - lazily instantiated by BackendGenerator()
var backendGenerator gopter.Gen

// BackendGenerator returns a generator of Backend instances for property testing.
func BackendGenerator() gopter.Gen {
	if backendGenerator != nil {
		return backendGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackend(generators)
	backendGenerator = gen.Struct(reflect.TypeOf(Backend{}), generators)

	return backendGenerator
}

// AddIndependentPropertyGeneratorsForBackend is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackend(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
	gens["BackendHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(Backend_EnabledState_Disabled, Backend_EnabledState_Enabled))
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_FrontendEndpointProperties_WebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendEndpointProperties_WebApplicationFirewallPolicyLink to FrontendEndpointProperties_WebApplicationFirewallPolicyLink via AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink & AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink, FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink tests if a specific instance of FrontendEndpointProperties_WebApplicationFirewallPolicyLink can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink(subject FrontendEndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.FrontendEndpointProperties_WebApplicationFirewallPolicyLink
	err := copied.AssignProperties_To_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendEndpointProperties_WebApplicationFirewallPolicyLink
	err = actual.AssignProperties_From_FrontendEndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendEndpointProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpointProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink, FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of FrontendEndpointProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpointProperties_WebApplicationFirewallPolicyLink(subject FrontendEndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpointProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily
// instantiated by FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator()
var frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of FrontendEndpointProperties_WebApplicationFirewallPolicyLink instances for property testing.
func FrontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointProperties_WebApplicationFirewallPolicyLink{}), generators)

	return frontendEndpointProperties_WebApplicationFirewallPolicyLinkGenerator
}

func Test_RouteConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteConfiguration to RouteConfiguration via AssignProperties_To_RouteConfiguration & AssignProperties_From_RouteConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteConfiguration, RouteConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteConfiguration tests if a specific instance of RouteConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRouteConfiguration(subject RouteConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RouteConfiguration
	err := copied.AssignProperties_To_RouteConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteConfiguration
	err = actual.AssignProperties_From_RouteConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfiguration, RouteConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfiguration runs a test to see if a specific instance of RouteConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfiguration(subject RouteConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfiguration instances for property testing - lazily instantiated by RouteConfigurationGenerator()
var routeConfigurationGenerator gopter.Gen

// RouteConfigurationGenerator returns a generator of RouteConfiguration instances for property testing.
func RouteConfigurationGenerator() gopter.Gen {
	if routeConfigurationGenerator != nil {
		return routeConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRouteConfiguration(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(RouteConfiguration{}), map[string]gopter.Gen{propName: propGen}))
	}
	routeConfigurationGenerator = gen.OneGenOf(gens...)

	return routeConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForRouteConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfiguration(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureFrontDoorModelsFrontdoorForwarding"] = ForwardingConfigurationGenerator().Map(func(it ForwardingConfiguration) *ForwardingConfiguration {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureFrontDoorModelsFrontdoorRedirect"] = RedirectConfigurationGenerator().Map(func(it RedirectConfiguration) *RedirectConfiguration {
		return &it
	}) // generate one case for OneOf type
}

func Test_RoutingRuleProperties_WebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingRuleProperties_WebApplicationFirewallPolicyLink to RoutingRuleProperties_WebApplicationFirewallPolicyLink via AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink & AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink, RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink tests if a specific instance of RoutingRuleProperties_WebApplicationFirewallPolicyLink can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink(subject RoutingRuleProperties_WebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RoutingRuleProperties_WebApplicationFirewallPolicyLink
	err := copied.AssignProperties_To_RoutingRuleProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingRuleProperties_WebApplicationFirewallPolicyLink
	err = actual.AssignProperties_From_RoutingRuleProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingRuleProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRuleProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink, RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of RoutingRuleProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRuleProperties_WebApplicationFirewallPolicyLink(subject RoutingRuleProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRuleProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily
// instantiated by RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator()
var routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of RoutingRuleProperties_WebApplicationFirewallPolicyLink instances for property testing.
func RoutingRuleProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(RoutingRuleProperties_WebApplicationFirewallPolicyLink{}), generators)

	return routingRuleProperties_WebApplicationFirewallPolicyLinkGenerator
}

func Test_SubResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource to SubResource via AssignProperties_To_SubResource & AssignProperties_From_SubResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource tests if a specific instance of SubResource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource(subject SubResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SubResource
	err := copied.AssignProperties_To_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource
	err = actual.AssignProperties_From_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

func Test_ForwardingConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ForwardingConfiguration to ForwardingConfiguration via AssignProperties_To_ForwardingConfiguration & AssignProperties_From_ForwardingConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForForwardingConfiguration, ForwardingConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForForwardingConfiguration tests if a specific instance of ForwardingConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForForwardingConfiguration(subject ForwardingConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ForwardingConfiguration
	err := copied.AssignProperties_To_ForwardingConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ForwardingConfiguration
	err = actual.AssignProperties_From_ForwardingConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ForwardingConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardingConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardingConfiguration, ForwardingConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardingConfiguration runs a test to see if a specific instance of ForwardingConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardingConfiguration(subject ForwardingConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardingConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardingConfiguration instances for property testing - lazily instantiated by
// ForwardingConfigurationGenerator()
var forwardingConfigurationGenerator gopter.Gen

// ForwardingConfigurationGenerator returns a generator of ForwardingConfiguration instances for property testing.
// We first initialize forwardingConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ForwardingConfigurationGenerator() gopter.Gen {
	if forwardingConfigurationGenerator != nil {
		return forwardingConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration(generators)
	forwardingConfigurationGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration(generators)
	AddRelatedPropertyGeneratorsForForwardingConfiguration(generators)
	forwardingConfigurationGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration{}), generators)

	return forwardingConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForForwardingConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardingConfiguration(gens map[string]gopter.Gen) {
	gens["CustomForwardingPath"] = gen.PtrOf(gen.AlphaString())
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(ForwardingConfiguration_ForwardingProtocol_HttpOnly, ForwardingConfiguration_ForwardingProtocol_HttpsOnly, ForwardingConfiguration_ForwardingProtocol_MatchRequest))
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(ForwardingConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorForwardingConfiguration))
}

// AddRelatedPropertyGeneratorsForForwardingConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForForwardingConfiguration(gens map[string]gopter.Gen) {
	gens["BackendPool"] = gen.PtrOf(SubResourceGenerator())
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationGenerator())
}

func Test_RedirectConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RedirectConfiguration to RedirectConfiguration via AssignProperties_To_RedirectConfiguration & AssignProperties_From_RedirectConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForRedirectConfiguration, RedirectConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRedirectConfiguration tests if a specific instance of RedirectConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRedirectConfiguration(subject RedirectConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RedirectConfiguration
	err := copied.AssignProperties_To_RedirectConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RedirectConfiguration
	err = actual.AssignProperties_From_RedirectConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RedirectConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RedirectConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRedirectConfiguration, RedirectConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRedirectConfiguration runs a test to see if a specific instance of RedirectConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForRedirectConfiguration(subject RedirectConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RedirectConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RedirectConfiguration instances for property testing - lazily instantiated by
// RedirectConfigurationGenerator()
var redirectConfigurationGenerator gopter.Gen

// RedirectConfigurationGenerator returns a generator of RedirectConfiguration instances for property testing.
func RedirectConfigurationGenerator() gopter.Gen {
	if redirectConfigurationGenerator != nil {
		return redirectConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRedirectConfiguration(generators)
	redirectConfigurationGenerator = gen.Struct(reflect.TypeOf(RedirectConfiguration{}), generators)

	return redirectConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForRedirectConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRedirectConfiguration(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHost"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(RedirectConfiguration_OdataType_MicrosoftAzureFrontDoorModelsFrontdoorRedirectConfiguration))
	gens["RedirectProtocol"] = gen.PtrOf(gen.OneConstOf(RedirectConfiguration_RedirectProtocol_HttpOnly, RedirectConfiguration_RedirectProtocol_HttpsOnly, RedirectConfiguration_RedirectProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		RedirectConfiguration_RedirectType_Found,
		RedirectConfiguration_RedirectType_Moved,
		RedirectConfiguration_RedirectType_PermanentRedirect,
		RedirectConfiguration_RedirectType_TemporaryRedirect))
}

func Test_RouteConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteConfiguration_STATUS to RouteConfiguration_STATUS via AssignProperties_To_RouteConfiguration_STATUS & AssignProperties_From_RouteConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteConfiguration_STATUS, RouteConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteConfiguration_STATUS tests if a specific instance of RouteConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRouteConfiguration_STATUS(subject RouteConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RouteConfiguration_STATUS
	err := copied.AssignProperties_To_RouteConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteConfiguration_STATUS
	err = actual.AssignProperties_From_RouteConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfiguration_STATUS, RouteConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfiguration_STATUS runs a test to see if a specific instance of RouteConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfiguration_STATUS(subject RouteConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfiguration_STATUS instances for property testing - lazily instantiated by
// RouteConfiguration_STATUSGenerator()
var routeConfiguration_STATUSGenerator gopter.Gen

// RouteConfiguration_STATUSGenerator returns a generator of RouteConfiguration_STATUS instances for property testing.
func RouteConfiguration_STATUSGenerator() gopter.Gen {
	if routeConfiguration_STATUSGenerator != nil {
		return routeConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(RouteConfiguration_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	routeConfiguration_STATUSGenerator = gen.OneGenOf(gens...)

	return routeConfiguration_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureFrontDoorModelsFrontdoorForwarding"] = ForwardingConfiguration_STATUSGenerator().Map(func(it ForwardingConfiguration_STATUS) *ForwardingConfiguration_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureFrontDoorModelsFrontdoorRedirect"] = RedirectConfiguration_STATUSGenerator().Map(func(it RedirectConfiguration_STATUS) *RedirectConfiguration_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_SubResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_STATUS to SubResource_STATUS via AssignProperties_To_SubResource_STATUS & AssignProperties_From_SubResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_STATUS tests if a specific instance of SubResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SubResource_STATUS
	err := copied.AssignProperties_To_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_STATUS
	err = actual.AssignProperties_From_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_CacheConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheConfiguration to CacheConfiguration via AssignProperties_To_CacheConfiguration & AssignProperties_From_CacheConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheConfiguration tests if a specific instance of CacheConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCacheConfiguration(subject CacheConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheConfiguration
	err := copied.AssignProperties_To_CacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheConfiguration
	err = actual.AssignProperties_From_CacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration runs a test to see if a specific instance of CacheConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration(subject CacheConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration instances for property testing - lazily instantiated by CacheConfigurationGenerator()
var cacheConfigurationGenerator gopter.Gen

// CacheConfigurationGenerator returns a generator of CacheConfiguration instances for property testing.
func CacheConfigurationGenerator() gopter.Gen {
	if cacheConfigurationGenerator != nil {
		return cacheConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration(generators)
	cacheConfigurationGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration{}), generators)

	return cacheConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration(gens map[string]gopter.Gen) {
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["DynamicCompression"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_DynamicCompression_Disabled, CacheConfiguration_DynamicCompression_Enabled))
	gens["QueryParameterStripDirective"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryParameterStripDirective_StripAll,
		CacheConfiguration_QueryParameterStripDirective_StripAllExcept,
		CacheConfiguration_QueryParameterStripDirective_StripNone,
		CacheConfiguration_QueryParameterStripDirective_StripOnly))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_ForwardingConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ForwardingConfiguration_STATUS to ForwardingConfiguration_STATUS via AssignProperties_To_ForwardingConfiguration_STATUS & AssignProperties_From_ForwardingConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForForwardingConfiguration_STATUS, ForwardingConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForForwardingConfiguration_STATUS tests if a specific instance of ForwardingConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForForwardingConfiguration_STATUS(subject ForwardingConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ForwardingConfiguration_STATUS
	err := copied.AssignProperties_To_ForwardingConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ForwardingConfiguration_STATUS
	err = actual.AssignProperties_From_ForwardingConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ForwardingConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardingConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardingConfiguration_STATUS, ForwardingConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardingConfiguration_STATUS runs a test to see if a specific instance of ForwardingConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardingConfiguration_STATUS(subject ForwardingConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardingConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardingConfiguration_STATUS instances for property testing - lazily instantiated by
// ForwardingConfiguration_STATUSGenerator()
var forwardingConfiguration_STATUSGenerator gopter.Gen

// ForwardingConfiguration_STATUSGenerator returns a generator of ForwardingConfiguration_STATUS instances for property testing.
// We first initialize forwardingConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ForwardingConfiguration_STATUSGenerator() gopter.Gen {
	if forwardingConfiguration_STATUSGenerator != nil {
		return forwardingConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	forwardingConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS(generators)
	forwardingConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(ForwardingConfiguration_STATUS{}), generators)

	return forwardingConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardingConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomForwardingPath"] = gen.PtrOf(gen.AlphaString())
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(ForwardingConfiguration_ForwardingProtocol_STATUS_HttpOnly, ForwardingConfiguration_ForwardingProtocol_STATUS_HttpsOnly, ForwardingConfiguration_ForwardingProtocol_STATUS_MatchRequest))
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(ForwardingConfiguration_OdataType_STATUS_MicrosoftAzureFrontDoorModelsFrontdoorForwardingConfiguration))
}

// AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForForwardingConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["BackendPool"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfiguration_STATUSGenerator())
}

func Test_RedirectConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RedirectConfiguration_STATUS to RedirectConfiguration_STATUS via AssignProperties_To_RedirectConfiguration_STATUS & AssignProperties_From_RedirectConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRedirectConfiguration_STATUS, RedirectConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRedirectConfiguration_STATUS tests if a specific instance of RedirectConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRedirectConfiguration_STATUS(subject RedirectConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RedirectConfiguration_STATUS
	err := copied.AssignProperties_To_RedirectConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RedirectConfiguration_STATUS
	err = actual.AssignProperties_From_RedirectConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RedirectConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RedirectConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRedirectConfiguration_STATUS, RedirectConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRedirectConfiguration_STATUS runs a test to see if a specific instance of RedirectConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRedirectConfiguration_STATUS(subject RedirectConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RedirectConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RedirectConfiguration_STATUS instances for property testing - lazily instantiated by
// RedirectConfiguration_STATUSGenerator()
var redirectConfiguration_STATUSGenerator gopter.Gen

// RedirectConfiguration_STATUSGenerator returns a generator of RedirectConfiguration_STATUS instances for property testing.
func RedirectConfiguration_STATUSGenerator() gopter.Gen {
	if redirectConfiguration_STATUSGenerator != nil {
		return redirectConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS(generators)
	redirectConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(RedirectConfiguration_STATUS{}), generators)

	return redirectConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRedirectConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHost"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(RedirectConfiguration_OdataType_STATUS_MicrosoftAzureFrontDoorModelsFrontdoorRedirectConfiguration))
	gens["RedirectProtocol"] = gen.PtrOf(gen.OneConstOf(RedirectConfiguration_RedirectProtocol_STATUS_HttpOnly, RedirectConfiguration_RedirectProtocol_STATUS_HttpsOnly, RedirectConfiguration_RedirectProtocol_STATUS_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		RedirectConfiguration_RedirectType_STATUS_Found,
		RedirectConfiguration_RedirectType_STATUS_Moved,
		RedirectConfiguration_RedirectType_STATUS_PermanentRedirect,
		RedirectConfiguration_RedirectType_STATUS_TemporaryRedirect))
}

func Test_CacheConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheConfiguration_STATUS to CacheConfiguration_STATUS via AssignProperties_To_CacheConfiguration_STATUS & AssignProperties_From_CacheConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheConfiguration_STATUS, CacheConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheConfiguration_STATUS tests if a specific instance of CacheConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCacheConfiguration_STATUS(subject CacheConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheConfiguration_STATUS
	err := copied.AssignProperties_To_CacheConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheConfiguration_STATUS
	err = actual.AssignProperties_From_CacheConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration_STATUS, CacheConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration_STATUS runs a test to see if a specific instance of CacheConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration_STATUS(subject CacheConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration_STATUS instances for property testing - lazily instantiated by
// CacheConfiguration_STATUSGenerator()
var cacheConfiguration_STATUSGenerator gopter.Gen

// CacheConfiguration_STATUSGenerator returns a generator of CacheConfiguration_STATUS instances for property testing.
func CacheConfiguration_STATUSGenerator() gopter.Gen {
	if cacheConfiguration_STATUSGenerator != nil {
		return cacheConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(generators)
	cacheConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration_STATUS{}), generators)

	return cacheConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["DynamicCompression"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_DynamicCompression_STATUS_Disabled, CacheConfiguration_DynamicCompression_STATUS_Enabled))
	gens["QueryParameterStripDirective"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryParameterStripDirective_STATUS_StripAll,
		CacheConfiguration_QueryParameterStripDirective_STATUS_StripAllExcept,
		CacheConfiguration_QueryParameterStripDirective_STATUS_StripNone,
		CacheConfiguration_QueryParameterStripDirective_STATUS_StripOnly))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
}
