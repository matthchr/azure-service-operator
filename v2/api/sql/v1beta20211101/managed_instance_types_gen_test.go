// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211101

import (
	"encoding/json"
	v20211101s "github.com/Azure/azure-service-operator/v2/api/sql/v1beta20211101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedInstance_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstance to hub returns original",
		prop.ForAll(RunResourceConversionTestForManagedInstance, ManagedInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForManagedInstance tests if a specific instance of ManagedInstance round trips to the hub storage version and back losslessly
func RunResourceConversionTestForManagedInstance(subject ManagedInstance) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20211101s.ManagedInstance
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ManagedInstance
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstance_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstance to ManagedInstance via AssignProperties_To_ManagedInstance & AssignProperties_From_ManagedInstance returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstance, ManagedInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstance tests if a specific instance of ManagedInstance can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstance(subject ManagedInstance) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstance
	err := copied.AssignProperties_To_ManagedInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstance
	err = actual.AssignProperties_From_ManagedInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstance, ManagedInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstance runs a test to see if a specific instance of ManagedInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstance(subject ManagedInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstance instances for property testing - lazily instantiated by ManagedInstanceGenerator()
var managedInstanceGenerator gopter.Gen

// ManagedInstanceGenerator returns a generator of ManagedInstance instances for property testing.
func ManagedInstanceGenerator() gopter.Gen {
	if managedInstanceGenerator != nil {
		return managedInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedInstance(generators)
	managedInstanceGenerator = gen.Struct(reflect.TypeOf(ManagedInstance{}), generators)

	return managedInstanceGenerator
}

// AddRelatedPropertyGeneratorsForManagedInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedInstance(gens map[string]gopter.Gen) {
	gens["Spec"] = ManagedInstance_SpecGenerator()
	gens["Status"] = ManagedInstance_STATUSGenerator()
}

func Test_ManagedInstance_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstance_Spec to ManagedInstance_Spec via AssignProperties_To_ManagedInstance_Spec & AssignProperties_From_ManagedInstance_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstance_Spec, ManagedInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstance_Spec tests if a specific instance of ManagedInstance_Spec can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstance_Spec(subject ManagedInstance_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstance_Spec
	err := copied.AssignProperties_To_ManagedInstance_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstance_Spec
	err = actual.AssignProperties_From_ManagedInstance_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstance_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstance_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstance_Spec, ManagedInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstance_Spec runs a test to see if a specific instance of ManagedInstance_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstance_Spec(subject ManagedInstance_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstance_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstance_Spec instances for property testing - lazily instantiated by
// ManagedInstance_SpecGenerator()
var managedInstance_SpecGenerator gopter.Gen

// ManagedInstance_SpecGenerator returns a generator of ManagedInstance_Spec instances for property testing.
// We first initialize managedInstance_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedInstance_SpecGenerator() gopter.Gen {
	if managedInstance_SpecGenerator != nil {
		return managedInstance_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstance_Spec(generators)
	managedInstance_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedInstance_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstance_Spec(generators)
	AddRelatedPropertyGeneratorsForManagedInstance_Spec(generators)
	managedInstance_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedInstance_Spec{}), generators)

	return managedInstance_SpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstance_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstance_Spec(gens map[string]gopter.Gen) {
	gens["AdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["Collation"] = gen.PtrOf(gen.AlphaString())
	gens["InstancePoolId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_LicenseType_BasePrice, ManagedInstanceProperties_LicenseType_LicenseIncluded))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceConfigurationId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedInstanceCreateMode"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_ManagedInstanceCreateMode_Default, ManagedInstanceProperties_ManagedInstanceCreateMode_PointInTimeRestore))
	gens["MinimalTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["ProxyOverride"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_ProxyOverride_Default, ManagedInstanceProperties_ProxyOverride_Proxy, ManagedInstanceProperties_ProxyOverride_Redirect))
	gens["PublicDataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["RequestedBackupStorageRedundancy"] = gen.PtrOf(gen.OneConstOf(
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_Geo,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_GeoZone,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_Local,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_Zone))
	gens["RestorePointInTime"] = gen.PtrOf(gen.AlphaString())
	gens["StorageSizeInGB"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TimezoneId"] = gen.PtrOf(gen.AlphaString())
	gens["VCores"] = gen.PtrOf(gen.Int())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedInstance_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedInstance_Spec(gens map[string]gopter.Gen) {
	gens["Administrators"] = gen.PtrOf(ManagedInstanceExternalAdministratorGenerator())
	gens["Identity"] = gen.PtrOf(ResourceIdentityGenerator())
	gens["ServicePrincipal"] = gen.PtrOf(ServicePrincipalGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_ManagedInstance_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstance_STATUS to ManagedInstance_STATUS via AssignProperties_To_ManagedInstance_STATUS & AssignProperties_From_ManagedInstance_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstance_STATUS, ManagedInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstance_STATUS tests if a specific instance of ManagedInstance_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstance_STATUS(subject ManagedInstance_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstance_STATUS
	err := copied.AssignProperties_To_ManagedInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstance_STATUS
	err = actual.AssignProperties_From_ManagedInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstance_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstance_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstance_STATUS, ManagedInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstance_STATUS runs a test to see if a specific instance of ManagedInstance_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstance_STATUS(subject ManagedInstance_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstance_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstance_STATUS instances for property testing - lazily instantiated by
// ManagedInstance_STATUSGenerator()
var managedInstance_STATUSGenerator gopter.Gen

// ManagedInstance_STATUSGenerator returns a generator of ManagedInstance_STATUS instances for property testing.
// We first initialize managedInstance_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedInstance_STATUSGenerator() gopter.Gen {
	if managedInstance_STATUSGenerator != nil {
		return managedInstance_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstance_STATUS(generators)
	managedInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstance_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstance_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedInstance_STATUS(generators)
	managedInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstance_STATUS{}), generators)

	return managedInstance_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstance_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstance_STATUS(gens map[string]gopter.Gen) {
	gens["AdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["Collation"] = gen.PtrOf(gen.AlphaString())
	gens["CurrentBackupStorageRedundancy"] = gen.PtrOf(gen.OneConstOf(
		ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Geo,
		ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_GeoZone,
		ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Local,
		ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Zone))
	gens["DnsZone"] = gen.PtrOf(gen.AlphaString())
	gens["DnsZonePartner"] = gen.PtrOf(gen.AlphaString())
	gens["FullyQualifiedDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["InstancePoolId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_LicenseType_STATUS_BasePrice, ManagedInstanceProperties_LicenseType_STATUS_LicenseIncluded))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceConfigurationId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedInstanceCreateMode"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS_Default, ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS_PointInTimeRestore))
	gens["MinimalTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentityId"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ManagedInstanceProperties_ProvisioningState_STATUS_Accepted,
		ManagedInstanceProperties_ProvisioningState_STATUS_Canceled,
		ManagedInstanceProperties_ProvisioningState_STATUS_Created,
		ManagedInstanceProperties_ProvisioningState_STATUS_Creating,
		ManagedInstanceProperties_ProvisioningState_STATUS_Deleted,
		ManagedInstanceProperties_ProvisioningState_STATUS_Deleting,
		ManagedInstanceProperties_ProvisioningState_STATUS_Failed,
		ManagedInstanceProperties_ProvisioningState_STATUS_NotSpecified,
		ManagedInstanceProperties_ProvisioningState_STATUS_Registering,
		ManagedInstanceProperties_ProvisioningState_STATUS_Running,
		ManagedInstanceProperties_ProvisioningState_STATUS_Succeeded,
		ManagedInstanceProperties_ProvisioningState_STATUS_TimedOut,
		ManagedInstanceProperties_ProvisioningState_STATUS_Unknown,
		ManagedInstanceProperties_ProvisioningState_STATUS_Unrecognized,
		ManagedInstanceProperties_ProvisioningState_STATUS_Updating))
	gens["ProxyOverride"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceProperties_ProxyOverride_STATUS_Default, ManagedInstanceProperties_ProxyOverride_STATUS_Proxy, ManagedInstanceProperties_ProxyOverride_STATUS_Redirect))
	gens["PublicDataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["RequestedBackupStorageRedundancy"] = gen.PtrOf(gen.OneConstOf(
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Geo,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_GeoZone,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Local,
		ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Zone))
	gens["RestorePointInTime"] = gen.PtrOf(gen.AlphaString())
	gens["SourceManagedInstanceId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
	gens["StorageSizeInGB"] = gen.PtrOf(gen.Int())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TimezoneId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VCores"] = gen.PtrOf(gen.Int())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedInstance_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedInstance_STATUS(gens map[string]gopter.Gen) {
	gens["Administrators"] = gen.PtrOf(ManagedInstanceExternalAdministrator_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ResourceIdentity_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(ManagedInstancePecProperty_STATUSGenerator())
	gens["ServicePrincipal"] = gen.PtrOf(ServicePrincipal_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
}

func Test_ManagedInstanceExternalAdministrator_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstanceExternalAdministrator to ManagedInstanceExternalAdministrator via AssignProperties_To_ManagedInstanceExternalAdministrator & AssignProperties_From_ManagedInstanceExternalAdministrator returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstanceExternalAdministrator, ManagedInstanceExternalAdministratorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstanceExternalAdministrator tests if a specific instance of ManagedInstanceExternalAdministrator can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstanceExternalAdministrator(subject ManagedInstanceExternalAdministrator) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstanceExternalAdministrator
	err := copied.AssignProperties_To_ManagedInstanceExternalAdministrator(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstanceExternalAdministrator
	err = actual.AssignProperties_From_ManagedInstanceExternalAdministrator(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstanceExternalAdministrator_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstanceExternalAdministrator via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstanceExternalAdministrator, ManagedInstanceExternalAdministratorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstanceExternalAdministrator runs a test to see if a specific instance of ManagedInstanceExternalAdministrator round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstanceExternalAdministrator(subject ManagedInstanceExternalAdministrator) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstanceExternalAdministrator
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstanceExternalAdministrator instances for property testing - lazily instantiated by
// ManagedInstanceExternalAdministratorGenerator()
var managedInstanceExternalAdministratorGenerator gopter.Gen

// ManagedInstanceExternalAdministratorGenerator returns a generator of ManagedInstanceExternalAdministrator instances for property testing.
func ManagedInstanceExternalAdministratorGenerator() gopter.Gen {
	if managedInstanceExternalAdministratorGenerator != nil {
		return managedInstanceExternalAdministratorGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator(generators)
	managedInstanceExternalAdministratorGenerator = gen.Struct(reflect.TypeOf(ManagedInstanceExternalAdministrator{}), generators)

	return managedInstanceExternalAdministratorGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator(gens map[string]gopter.Gen) {
	gens["AdministratorType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceExternalAdministrator_AdministratorType_ActiveDirectory))
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["Login"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceExternalAdministrator_PrincipalType_Application, ManagedInstanceExternalAdministrator_PrincipalType_Group, ManagedInstanceExternalAdministrator_PrincipalType_User))
	gens["Sid"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedInstanceExternalAdministrator_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstanceExternalAdministrator_STATUS to ManagedInstanceExternalAdministrator_STATUS via AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS & AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstanceExternalAdministrator_STATUS, ManagedInstanceExternalAdministrator_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstanceExternalAdministrator_STATUS tests if a specific instance of ManagedInstanceExternalAdministrator_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstanceExternalAdministrator_STATUS(subject ManagedInstanceExternalAdministrator_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstanceExternalAdministrator_STATUS
	err := copied.AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstanceExternalAdministrator_STATUS
	err = actual.AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstanceExternalAdministrator_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstanceExternalAdministrator_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstanceExternalAdministrator_STATUS, ManagedInstanceExternalAdministrator_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstanceExternalAdministrator_STATUS runs a test to see if a specific instance of ManagedInstanceExternalAdministrator_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstanceExternalAdministrator_STATUS(subject ManagedInstanceExternalAdministrator_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstanceExternalAdministrator_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstanceExternalAdministrator_STATUS instances for property testing - lazily instantiated by
// ManagedInstanceExternalAdministrator_STATUSGenerator()
var managedInstanceExternalAdministrator_STATUSGenerator gopter.Gen

// ManagedInstanceExternalAdministrator_STATUSGenerator returns a generator of ManagedInstanceExternalAdministrator_STATUS instances for property testing.
func ManagedInstanceExternalAdministrator_STATUSGenerator() gopter.Gen {
	if managedInstanceExternalAdministrator_STATUSGenerator != nil {
		return managedInstanceExternalAdministrator_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator_STATUS(generators)
	managedInstanceExternalAdministrator_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstanceExternalAdministrator_STATUS{}), generators)

	return managedInstanceExternalAdministrator_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstanceExternalAdministrator_STATUS(gens map[string]gopter.Gen) {
	gens["AdministratorType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceExternalAdministrator_AdministratorType_STATUS_ActiveDirectory))
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["Login"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalType"] = gen.PtrOf(gen.OneConstOf(ManagedInstanceExternalAdministrator_PrincipalType_STATUS_Application, ManagedInstanceExternalAdministrator_PrincipalType_STATUS_Group, ManagedInstanceExternalAdministrator_PrincipalType_STATUS_User))
	gens["Sid"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedInstancePecProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstancePecProperty_STATUS to ManagedInstancePecProperty_STATUS via AssignProperties_To_ManagedInstancePecProperty_STATUS & AssignProperties_From_ManagedInstancePecProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstancePecProperty_STATUS, ManagedInstancePecProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstancePecProperty_STATUS tests if a specific instance of ManagedInstancePecProperty_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstancePecProperty_STATUS(subject ManagedInstancePecProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstancePecProperty_STATUS
	err := copied.AssignProperties_To_ManagedInstancePecProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstancePecProperty_STATUS
	err = actual.AssignProperties_From_ManagedInstancePecProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstancePecProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstancePecProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstancePecProperty_STATUS, ManagedInstancePecProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstancePecProperty_STATUS runs a test to see if a specific instance of ManagedInstancePecProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstancePecProperty_STATUS(subject ManagedInstancePecProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstancePecProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstancePecProperty_STATUS instances for property testing - lazily instantiated by
// ManagedInstancePecProperty_STATUSGenerator()
var managedInstancePecProperty_STATUSGenerator gopter.Gen

// ManagedInstancePecProperty_STATUSGenerator returns a generator of ManagedInstancePecProperty_STATUS instances for property testing.
// We first initialize managedInstancePecProperty_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedInstancePecProperty_STATUSGenerator() gopter.Gen {
	if managedInstancePecProperty_STATUSGenerator != nil {
		return managedInstancePecProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePecProperty_STATUS(generators)
	managedInstancePecProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePecProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePecProperty_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedInstancePecProperty_STATUS(generators)
	managedInstancePecProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePecProperty_STATUS{}), generators)

	return managedInstancePecProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstancePecProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstancePecProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedInstancePecProperty_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedInstancePecProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator())
}

func Test_ResourceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceIdentity to ResourceIdentity via AssignProperties_To_ResourceIdentity & AssignProperties_From_ResourceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceIdentity, ResourceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceIdentity tests if a specific instance of ResourceIdentity can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForResourceIdentity(subject ResourceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ResourceIdentity
	err := copied.AssignProperties_To_ResourceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceIdentity
	err = actual.AssignProperties_From_ResourceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceIdentity, ResourceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceIdentity runs a test to see if a specific instance of ResourceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceIdentity(subject ResourceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceIdentity instances for property testing - lazily instantiated by ResourceIdentityGenerator()
var resourceIdentityGenerator gopter.Gen

// ResourceIdentityGenerator returns a generator of ResourceIdentity instances for property testing.
func ResourceIdentityGenerator() gopter.Gen {
	if resourceIdentityGenerator != nil {
		return resourceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity(generators)
	resourceIdentityGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity{}), generators)

	return resourceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForResourceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ResourceIdentity_Type_None,
		ResourceIdentity_Type_SystemAssigned,
		ResourceIdentity_Type_SystemAssignedUserAssigned,
		ResourceIdentity_Type_UserAssigned))
}

func Test_ResourceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceIdentity_STATUS to ResourceIdentity_STATUS via AssignProperties_To_ResourceIdentity_STATUS & AssignProperties_From_ResourceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceIdentity_STATUS, ResourceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceIdentity_STATUS tests if a specific instance of ResourceIdentity_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForResourceIdentity_STATUS(subject ResourceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ResourceIdentity_STATUS
	err := copied.AssignProperties_To_ResourceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceIdentity_STATUS
	err = actual.AssignProperties_From_ResourceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceIdentity_STATUS, ResourceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceIdentity_STATUS runs a test to see if a specific instance of ResourceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceIdentity_STATUS(subject ResourceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceIdentity_STATUS instances for property testing - lazily instantiated by
// ResourceIdentity_STATUSGenerator()
var resourceIdentity_STATUSGenerator gopter.Gen

// ResourceIdentity_STATUSGenerator returns a generator of ResourceIdentity_STATUS instances for property testing.
// We first initialize resourceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceIdentity_STATUSGenerator() gopter.Gen {
	if resourceIdentity_STATUSGenerator != nil {
		return resourceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(generators)
	resourceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForResourceIdentity_STATUS(generators)
	resourceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity_STATUS{}), generators)

	return resourceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ResourceIdentity_Type_STATUS_None,
		ResourceIdentity_Type_STATUS_SystemAssigned,
		ResourceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ResourceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForResourceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentity_STATUSGenerator())
}

func Test_ServicePrincipal_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipal to ServicePrincipal via AssignProperties_To_ServicePrincipal & AssignProperties_From_ServicePrincipal returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipal, ServicePrincipalGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipal tests if a specific instance of ServicePrincipal can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipal(subject ServicePrincipal) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ServicePrincipal
	err := copied.AssignProperties_To_ServicePrincipal(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipal
	err = actual.AssignProperties_From_ServicePrincipal(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipal_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipal via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipal, ServicePrincipalGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipal runs a test to see if a specific instance of ServicePrincipal round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipal(subject ServicePrincipal) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipal
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipal instances for property testing - lazily instantiated by ServicePrincipalGenerator()
var servicePrincipalGenerator gopter.Gen

// ServicePrincipalGenerator returns a generator of ServicePrincipal instances for property testing.
func ServicePrincipalGenerator() gopter.Gen {
	if servicePrincipalGenerator != nil {
		return servicePrincipalGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipal(generators)
	servicePrincipalGenerator = gen.Struct(reflect.TypeOf(ServicePrincipal{}), generators)

	return servicePrincipalGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipal is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipal(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ServicePrincipal_Type_None, ServicePrincipal_Type_SystemAssigned))
}

func Test_ServicePrincipal_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipal_STATUS to ServicePrincipal_STATUS via AssignProperties_To_ServicePrincipal_STATUS & AssignProperties_From_ServicePrincipal_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipal_STATUS, ServicePrincipal_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipal_STATUS tests if a specific instance of ServicePrincipal_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipal_STATUS(subject ServicePrincipal_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ServicePrincipal_STATUS
	err := copied.AssignProperties_To_ServicePrincipal_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipal_STATUS
	err = actual.AssignProperties_From_ServicePrincipal_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipal_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipal_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipal_STATUS, ServicePrincipal_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipal_STATUS runs a test to see if a specific instance of ServicePrincipal_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipal_STATUS(subject ServicePrincipal_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipal_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipal_STATUS instances for property testing - lazily instantiated by
// ServicePrincipal_STATUSGenerator()
var servicePrincipal_STATUSGenerator gopter.Gen

// ServicePrincipal_STATUSGenerator returns a generator of ServicePrincipal_STATUS instances for property testing.
func ServicePrincipal_STATUSGenerator() gopter.Gen {
	if servicePrincipal_STATUSGenerator != nil {
		return servicePrincipal_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipal_STATUS(generators)
	servicePrincipal_STATUSGenerator = gen.Struct(reflect.TypeOf(ServicePrincipal_STATUS{}), generators)

	return servicePrincipal_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipal_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipal_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ServicePrincipal_Type_STATUS_None, ServicePrincipal_Type_STATUS_SystemAssigned))
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignProperties_To_Sku & AssignProperties_From_Sku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.Sku
	err := copied.AssignProperties_To_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignProperties_From_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_STATUS to Sku_STATUS via AssignProperties_To_Sku_STATUS & AssignProperties_From_Sku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.Sku_STATUS
	err := copied.AssignProperties_To_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
	err = actual.AssignProperties_From_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedInstancePrivateEndpointConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstancePrivateEndpointConnectionProperties_STATUS to ManagedInstancePrivateEndpointConnectionProperties_STATUS via AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS & AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstancePrivateEndpointConnectionProperties_STATUS, ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstancePrivateEndpointConnectionProperties_STATUS tests if a specific instance of ManagedInstancePrivateEndpointConnectionProperties_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstancePrivateEndpointConnectionProperties_STATUS(subject ManagedInstancePrivateEndpointConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstancePrivateEndpointConnectionProperties_STATUS
	err := copied.AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstancePrivateEndpointConnectionProperties_STATUS
	err = actual.AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstancePrivateEndpointConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstancePrivateEndpointConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstancePrivateEndpointConnectionProperties_STATUS, ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstancePrivateEndpointConnectionProperties_STATUS runs a test to see if a specific instance of ManagedInstancePrivateEndpointConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstancePrivateEndpointConnectionProperties_STATUS(subject ManagedInstancePrivateEndpointConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstancePrivateEndpointConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstancePrivateEndpointConnectionProperties_STATUS instances for property testing - lazily
// instantiated by ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator()
var managedInstancePrivateEndpointConnectionProperties_STATUSGenerator gopter.Gen

// ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator returns a generator of ManagedInstancePrivateEndpointConnectionProperties_STATUS instances for property testing.
// We first initialize managedInstancePrivateEndpointConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedInstancePrivateEndpointConnectionProperties_STATUSGenerator() gopter.Gen {
	if managedInstancePrivateEndpointConnectionProperties_STATUSGenerator != nil {
		return managedInstancePrivateEndpointConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS(generators)
	managedInstancePrivateEndpointConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePrivateEndpointConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS(generators)
	managedInstancePrivateEndpointConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePrivateEndpointConnectionProperties_STATUS{}), generators)

	return managedInstancePrivateEndpointConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedInstancePrivateEndpointConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(ManagedInstancePrivateEndpointProperty_STATUSGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator())
}

func Test_UserIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserIdentity_STATUS to UserIdentity_STATUS via AssignProperties_To_UserIdentity_STATUS & AssignProperties_From_UserIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentity_STATUS, UserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentity_STATUS tests if a specific instance of UserIdentity_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForUserIdentity_STATUS(subject UserIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.UserIdentity_STATUS
	err := copied.AssignProperties_To_UserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserIdentity_STATUS
	err = actual.AssignProperties_From_UserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentity_STATUS, UserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentity_STATUS runs a test to see if a specific instance of UserIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentity_STATUS(subject UserIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentity_STATUS instances for property testing - lazily instantiated by
// UserIdentity_STATUSGenerator()
var userIdentity_STATUSGenerator gopter.Gen

// UserIdentity_STATUSGenerator returns a generator of UserIdentity_STATUS instances for property testing.
func UserIdentity_STATUSGenerator() gopter.Gen {
	if userIdentity_STATUSGenerator != nil {
		return userIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentity_STATUS(generators)
	userIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentity_STATUS{}), generators)

	return userIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedInstancePrivateEndpointProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstancePrivateEndpointProperty_STATUS to ManagedInstancePrivateEndpointProperty_STATUS via AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS & AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstancePrivateEndpointProperty_STATUS, ManagedInstancePrivateEndpointProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstancePrivateEndpointProperty_STATUS tests if a specific instance of ManagedInstancePrivateEndpointProperty_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstancePrivateEndpointProperty_STATUS(subject ManagedInstancePrivateEndpointProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstancePrivateEndpointProperty_STATUS
	err := copied.AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstancePrivateEndpointProperty_STATUS
	err = actual.AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstancePrivateEndpointProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstancePrivateEndpointProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstancePrivateEndpointProperty_STATUS, ManagedInstancePrivateEndpointProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstancePrivateEndpointProperty_STATUS runs a test to see if a specific instance of ManagedInstancePrivateEndpointProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstancePrivateEndpointProperty_STATUS(subject ManagedInstancePrivateEndpointProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstancePrivateEndpointProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstancePrivateEndpointProperty_STATUS instances for property testing - lazily instantiated by
// ManagedInstancePrivateEndpointProperty_STATUSGenerator()
var managedInstancePrivateEndpointProperty_STATUSGenerator gopter.Gen

// ManagedInstancePrivateEndpointProperty_STATUSGenerator returns a generator of ManagedInstancePrivateEndpointProperty_STATUS instances for property testing.
func ManagedInstancePrivateEndpointProperty_STATUSGenerator() gopter.Gen {
	if managedInstancePrivateEndpointProperty_STATUSGenerator != nil {
		return managedInstancePrivateEndpointProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointProperty_STATUS(generators)
	managedInstancePrivateEndpointProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePrivateEndpointProperty_STATUS{}), generators)

	return managedInstancePrivateEndpointProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstancePrivateEndpointProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS to ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS via AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS & AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS, ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS tests if a specific instance of ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS can be assigned to v1beta20211101storage and back losslessly
func RunPropertyAssignmentTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(subject ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211101s.ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
	err := copied.AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
	err = actual.AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS, ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS runs a test to see if a specific instance of ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(subject ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS instances for property testing - lazily
// instantiated by ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator()
var managedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator gopter.Gen

// ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator returns a generator of ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS instances for property testing.
func ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator() gopter.Gen {
	if managedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator != nil {
		return managedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(generators)
	managedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS{}), generators)

	return managedInstancePrivateLinkServiceConnectionStateProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}
