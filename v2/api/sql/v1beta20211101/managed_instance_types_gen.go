// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211101

import (
	"fmt"
	v20211101s "github.com/Azure/azure-service-operator/v2/api/sql/v1beta20211101storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /sql/resource-manager/Microsoft.Sql/stable/2021-11-01/ManagedInstances.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}
type ManagedInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedInstance_Spec   `json:"spec,omitempty"`
	Status            ManagedInstance_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedInstance{}

// GetConditions returns the conditions of the resource
func (instance *ManagedInstance) GetConditions() conditions.Conditions {
	return instance.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (instance *ManagedInstance) SetConditions(conditions conditions.Conditions) {
	instance.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedInstance{}

// ConvertFrom populates our ManagedInstance from the provided hub ManagedInstance
func (instance *ManagedInstance) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20211101s.ManagedInstance)
	if !ok {
		return fmt.Errorf("expected sql/v1beta20211101storage/ManagedInstance but received %T instead", hub)
	}

	return instance.AssignProperties_From_ManagedInstance(source)
}

// ConvertTo populates the provided hub ManagedInstance from our ManagedInstance
func (instance *ManagedInstance) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20211101s.ManagedInstance)
	if !ok {
		return fmt.Errorf("expected sql/v1beta20211101storage/ManagedInstance but received %T instead", hub)
	}

	return instance.AssignProperties_To_ManagedInstance(destination)
}

// +kubebuilder:webhook:path=/mutate-sql-azure-com-v1beta20211101-managedinstance,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=sql.azure.com,resources=managedinstances,verbs=create;update,versions=v1beta20211101,name=default.v1beta20211101.managedinstances.sql.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ManagedInstance{}

// Default applies defaults to the ManagedInstance resource
func (instance *ManagedInstance) Default() {
	instance.defaultImpl()
	var temp interface{} = instance
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (instance *ManagedInstance) defaultAzureName() {
	if instance.Spec.AzureName == "" {
		instance.Spec.AzureName = instance.Name
	}
}

// defaultImpl applies the code generated defaults to the ManagedInstance resource
func (instance *ManagedInstance) defaultImpl() { instance.defaultAzureName() }

var _ genruntime.KubernetesResource = &ManagedInstance{}

// AzureName returns the Azure name of the resource
func (instance *ManagedInstance) AzureName() string {
	return instance.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-11-01"
func (instance ManagedInstance) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (instance *ManagedInstance) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (instance *ManagedInstance) GetSpec() genruntime.ConvertibleSpec {
	return &instance.Spec
}

// GetStatus returns the status of this resource
func (instance *ManagedInstance) GetStatus() genruntime.ConvertibleStatus {
	return &instance.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Sql/managedInstances"
func (instance *ManagedInstance) GetType() string {
	return "Microsoft.Sql/managedInstances"
}

// NewEmptyStatus returns a new empty (blank) status
func (instance *ManagedInstance) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedInstance_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (instance *ManagedInstance) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(instance.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  instance.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (instance *ManagedInstance) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedInstance_STATUS); ok {
		instance.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedInstance_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	instance.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-sql-azure-com-v1beta20211101-managedinstance,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=sql.azure.com,resources=managedinstances,verbs=create;update,versions=v1beta20211101,name=validate.v1beta20211101.managedinstances.sql.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ManagedInstance{}

// ValidateCreate validates the creation of the resource
func (instance *ManagedInstance) ValidateCreate() error {
	validations := instance.createValidations()
	var temp interface{} = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (instance *ManagedInstance) ValidateDelete() error {
	validations := instance.deleteValidations()
	var temp interface{} = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (instance *ManagedInstance) ValidateUpdate(old runtime.Object) error {
	validations := instance.updateValidations()
	var temp interface{} = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (instance *ManagedInstance) createValidations() []func() error {
	return []func() error{instance.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (instance *ManagedInstance) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (instance *ManagedInstance) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return instance.validateResourceReferences()
		},
		instance.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (instance *ManagedInstance) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&instance.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (instance *ManagedInstance) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*ManagedInstance)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, instance)
}

// AssignProperties_From_ManagedInstance populates our ManagedInstance from the provided source ManagedInstance
func (instance *ManagedInstance) AssignProperties_From_ManagedInstance(source *v20211101s.ManagedInstance) error {

	// ObjectMeta
	instance.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ManagedInstance_Spec
	err := spec.AssignProperties_From_ManagedInstance_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedInstance_Spec() to populate field Spec")
	}
	instance.Spec = spec

	// Status
	var status ManagedInstance_STATUS
	err = status.AssignProperties_From_ManagedInstance_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedInstance_STATUS() to populate field Status")
	}
	instance.Status = status

	// No error
	return nil
}

// AssignProperties_To_ManagedInstance populates the provided destination ManagedInstance from our ManagedInstance
func (instance *ManagedInstance) AssignProperties_To_ManagedInstance(destination *v20211101s.ManagedInstance) error {

	// ObjectMeta
	destination.ObjectMeta = *instance.ObjectMeta.DeepCopy()

	// Spec
	var spec v20211101s.ManagedInstance_Spec
	err := instance.Spec.AssignProperties_To_ManagedInstance_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedInstance_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20211101s.ManagedInstance_STATUS
	err = instance.Status.AssignProperties_To_ManagedInstance_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedInstance_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (instance *ManagedInstance) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: instance.Spec.OriginalVersion(),
		Kind:    "ManagedInstance",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /sql/resource-manager/Microsoft.Sql/stable/2021-11-01/ManagedInstances.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}
type ManagedInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedInstance `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-11-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-11-01")

type ManagedInstance_Spec struct {
	// AdministratorLogin: Administrator username for the managed instance. Can only be specified when the managed instance is
	// being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// AdministratorLoginPassword: The administrator login password (required for managed instance creation).
	AdministratorLoginPassword *genruntime.SecretReference `json:"administratorLoginPassword,omitempty"`

	// Administrators: The Azure Active Directory administrator of the server.
	Administrators *ManagedInstanceExternalAdministrator `json:"administrators,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Collation: Collation of the managed instance.
	Collation *string `json:"collation,omitempty"`

	// DnsZonePartnerReference: The resource id of another managed instance whose DNS zone this managed instance will share
	// after creation.
	DnsZonePartnerReference *genruntime.ResourceReference `armReference:"DnsZonePartner" json:"dnsZonePartnerReference,omitempty"`

	// Identity: The Azure Active Directory identity of the managed instance.
	Identity *ResourceIdentity `json:"identity,omitempty"`

	// InstancePoolId: The Id of the instance pool this managed server belongs to.
	InstancePoolId *string `json:"instancePoolId,omitempty"`

	// KeyId: A CMK URI of the key to use for encryption.
	KeyId *string `json:"keyId,omitempty"`

	// LicenseType: The license type. Possible values are 'LicenseIncluded' (regular price inclusive of a new SQL license) and
	// 'BasePrice' (discounted AHB price for bringing your own SQL licenses).
	LicenseType *ManagedInstanceProperties_LicenseType `json:"licenseType,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MaintenanceConfigurationId: Specifies maintenance configuration id to apply to this managed instance.
	MaintenanceConfigurationId *string `json:"maintenanceConfigurationId,omitempty"`

	// ManagedInstanceCreateMode: Specifies the mode of database creation.
	// Default: Regular instance creation.
	// Restore: Creates an instance by restoring a set of backups to specific point in time. RestorePointInTime and
	// SourceManagedInstanceId must be specified.
	ManagedInstanceCreateMode *ManagedInstanceProperties_ManagedInstanceCreateMode `json:"managedInstanceCreateMode,omitempty"`

	// MinimalTlsVersion: Minimal TLS version. Allowed values: 'None', '1.0', '1.1', '1.2'
	MinimalTlsVersion *string `json:"minimalTlsVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PrimaryUserAssignedIdentityReference: The resource id of a user assigned identity to be used by default.
	PrimaryUserAssignedIdentityReference *genruntime.ResourceReference `armReference:"PrimaryUserAssignedIdentityId" json:"primaryUserAssignedIdentityReference,omitempty"`

	// ProxyOverride: Connection type used for connecting to the instance.
	ProxyOverride *ManagedInstanceProperties_ProxyOverride `json:"proxyOverride,omitempty"`

	// PublicDataEndpointEnabled: Whether or not the public data endpoint is enabled.
	PublicDataEndpointEnabled *bool `json:"publicDataEndpointEnabled,omitempty"`

	// RequestedBackupStorageRedundancy: The storage account type to be used to store backups for this instance. The options
	// are Local (LocallyRedundantStorage), Zone (ZoneRedundantStorage), Geo (GeoRedundantStorage) and
	// GeoZone(GeoZoneRedundantStorage)
	RequestedBackupStorageRedundancy *ManagedInstanceProperties_RequestedBackupStorageRedundancy `json:"requestedBackupStorageRedundancy,omitempty"`

	// RestorePointInTime: Specifies the point in time (ISO8601 format) of the source database that will be restored to create
	// the new database.
	RestorePointInTime *string `json:"restorePointInTime,omitempty"`

	// ServicePrincipal: The managed instance's service principal.
	ServicePrincipal *ServicePrincipal `json:"servicePrincipal,omitempty"`

	// Sku: Managed instance SKU. Allowed values for sku.name: GP_Gen5, GP_G8IM, GP_G8IH, BC_Gen5, BC_G8IM, BC_G8IH
	Sku *Sku `json:"sku,omitempty"`

	// SourceManagedInstanceReference: The resource identifier of the source managed instance associated with create operation
	// of this instance.
	SourceManagedInstanceReference *genruntime.ResourceReference `armReference:"SourceManagedInstanceId" json:"sourceManagedInstanceReference,omitempty"`

	// StorageSizeInGB: Storage size in GB. Minimum value: 32. Maximum value: 16384. Increments of 32 GB allowed only. Maximum
	// value depends on the selected hardware family and number of vCores.
	StorageSizeInGB *int `json:"storageSizeInGB,omitempty"`

	// SubnetReference: Subnet resource ID for the managed instance.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TimezoneId: Id of the timezone. Allowed values are timezones supported by Windows.
	// Windows keeps details on supported timezones, including the id, in registry under
	// KEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones.
	// You can get those registry values via SQL Server by querying SELECT name AS timezone_id FROM sys.time_zone_info.
	// List of Ids can also be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
	// An example of valid timezone id is "Pacific Standard Time" or "W. Europe Standard Time".
	TimezoneId *string `json:"timezoneId,omitempty"`

	// VCores: The number of vCores. Allowed values: 8, 16, 24, 32, 40, 64, 80.
	VCores *int `json:"vCores,omitempty"`

	// ZoneRedundant: Whether or not the multi-az is enabled.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedInstance_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *ManagedInstance_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &ManagedInstance_Spec_ARM{}

	// Set property ‘Identity’:
	if instance.Identity != nil {
		identity_ARM, err := (*instance.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*ResourceIdentity_ARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if instance.Location != nil {
		location := *instance.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if instance.AdministratorLogin != nil ||
		instance.AdministratorLoginPassword != nil ||
		instance.Administrators != nil ||
		instance.Collation != nil ||
		instance.DnsZonePartnerReference != nil ||
		instance.InstancePoolId != nil ||
		instance.KeyId != nil ||
		instance.LicenseType != nil ||
		instance.MaintenanceConfigurationId != nil ||
		instance.ManagedInstanceCreateMode != nil ||
		instance.MinimalTlsVersion != nil ||
		instance.PrimaryUserAssignedIdentityReference != nil ||
		instance.ProxyOverride != nil ||
		instance.PublicDataEndpointEnabled != nil ||
		instance.RequestedBackupStorageRedundancy != nil ||
		instance.RestorePointInTime != nil ||
		instance.ServicePrincipal != nil ||
		instance.SourceManagedInstanceReference != nil ||
		instance.StorageSizeInGB != nil ||
		instance.SubnetReference != nil ||
		instance.TimezoneId != nil ||
		instance.VCores != nil ||
		instance.ZoneRedundant != nil {
		result.Properties = &ManagedInstanceProperties_ARM{}
	}
	if instance.AdministratorLogin != nil {
		administratorLogin := *instance.AdministratorLogin
		result.Properties.AdministratorLogin = &administratorLogin
	}
	if instance.AdministratorLoginPassword != nil {
		administratorLoginPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*instance.AdministratorLoginPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdministratorLoginPassword")
		}
		administratorLoginPassword := administratorLoginPasswordSecret
		result.Properties.AdministratorLoginPassword = &administratorLoginPassword
	}
	if instance.Administrators != nil {
		administrators_ARM, err := (*instance.Administrators).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administrators := *administrators_ARM.(*ManagedInstanceExternalAdministrator_ARM)
		result.Properties.Administrators = &administrators
	}
	if instance.Collation != nil {
		collation := *instance.Collation
		result.Properties.Collation = &collation
	}
	if instance.DnsZonePartnerReference != nil {
		dnsZonePartnerARMID, err := resolved.ResolvedReferences.Lookup(*instance.DnsZonePartnerReference)
		if err != nil {
			return nil, err
		}
		dnsZonePartner := dnsZonePartnerARMID
		result.Properties.DnsZonePartner = &dnsZonePartner
	}
	if instance.InstancePoolId != nil {
		instancePoolId := *instance.InstancePoolId
		result.Properties.InstancePoolId = &instancePoolId
	}
	if instance.KeyId != nil {
		keyId := *instance.KeyId
		result.Properties.KeyId = &keyId
	}
	if instance.LicenseType != nil {
		licenseType := *instance.LicenseType
		result.Properties.LicenseType = &licenseType
	}
	if instance.MaintenanceConfigurationId != nil {
		maintenanceConfigurationId := *instance.MaintenanceConfigurationId
		result.Properties.MaintenanceConfigurationId = &maintenanceConfigurationId
	}
	if instance.ManagedInstanceCreateMode != nil {
		managedInstanceCreateMode := *instance.ManagedInstanceCreateMode
		result.Properties.ManagedInstanceCreateMode = &managedInstanceCreateMode
	}
	if instance.MinimalTlsVersion != nil {
		minimalTlsVersion := *instance.MinimalTlsVersion
		result.Properties.MinimalTlsVersion = &minimalTlsVersion
	}
	if instance.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityIdARMID, err := resolved.ResolvedReferences.Lookup(*instance.PrimaryUserAssignedIdentityReference)
		if err != nil {
			return nil, err
		}
		primaryUserAssignedIdentityId := primaryUserAssignedIdentityIdARMID
		result.Properties.PrimaryUserAssignedIdentityId = &primaryUserAssignedIdentityId
	}
	if instance.ProxyOverride != nil {
		proxyOverride := *instance.ProxyOverride
		result.Properties.ProxyOverride = &proxyOverride
	}
	if instance.PublicDataEndpointEnabled != nil {
		publicDataEndpointEnabled := *instance.PublicDataEndpointEnabled
		result.Properties.PublicDataEndpointEnabled = &publicDataEndpointEnabled
	}
	if instance.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := *instance.RequestedBackupStorageRedundancy
		result.Properties.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	}
	if instance.RestorePointInTime != nil {
		restorePointInTime := *instance.RestorePointInTime
		result.Properties.RestorePointInTime = &restorePointInTime
	}
	if instance.ServicePrincipal != nil {
		servicePrincipal_ARM, err := (*instance.ServicePrincipal).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipal := *servicePrincipal_ARM.(*ServicePrincipal_ARM)
		result.Properties.ServicePrincipal = &servicePrincipal
	}
	if instance.SourceManagedInstanceReference != nil {
		sourceManagedInstanceIdARMID, err := resolved.ResolvedReferences.Lookup(*instance.SourceManagedInstanceReference)
		if err != nil {
			return nil, err
		}
		sourceManagedInstanceId := sourceManagedInstanceIdARMID
		result.Properties.SourceManagedInstanceId = &sourceManagedInstanceId
	}
	if instance.StorageSizeInGB != nil {
		storageSizeInGB := *instance.StorageSizeInGB
		result.Properties.StorageSizeInGB = &storageSizeInGB
	}
	if instance.SubnetReference != nil {
		subnetIdARMID, err := resolved.ResolvedReferences.Lookup(*instance.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetId := subnetIdARMID
		result.Properties.SubnetId = &subnetId
	}
	if instance.TimezoneId != nil {
		timezoneId := *instance.TimezoneId
		result.Properties.TimezoneId = &timezoneId
	}
	if instance.VCores != nil {
		vCores := *instance.VCores
		result.Properties.VCores = &vCores
	}
	if instance.ZoneRedundant != nil {
		zoneRedundant := *instance.ZoneRedundant
		result.Properties.ZoneRedundant = &zoneRedundant
	}

	// Set property ‘Sku’:
	if instance.Sku != nil {
		sku_ARM, err := (*instance.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if instance.Tags != nil {
		result.Tags = make(map[string]string, len(instance.Tags))
		for key, value := range instance.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ManagedInstance_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstance_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ManagedInstance_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstance_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstance_Spec_ARM, got %T", armInput)
	}

	// Set property ‘AdministratorLogin’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdministratorLogin != nil {
			administratorLogin := *typedInput.Properties.AdministratorLogin
			instance.AdministratorLogin = &administratorLogin
		}
	}

	// no assignment for property ‘AdministratorLoginPassword’

	// Set property ‘Administrators’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Administrators != nil {
			var administrators1 ManagedInstanceExternalAdministrator
			err := administrators1.PopulateFromARM(owner, *typedInput.Properties.Administrators)
			if err != nil {
				return err
			}
			administrators := administrators1
			instance.Administrators = &administrators
		}
	}

	// Set property ‘AzureName’:
	instance.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Collation’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Collation != nil {
			collation := *typedInput.Properties.Collation
			instance.Collation = &collation
		}
	}

	// no assignment for property ‘DnsZonePartnerReference’

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ResourceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		instance.Identity = &identity
	}

	// Set property ‘InstancePoolId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstancePoolId != nil {
			instancePoolId := *typedInput.Properties.InstancePoolId
			instance.InstancePoolId = &instancePoolId
		}
	}

	// Set property ‘KeyId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyId != nil {
			keyId := *typedInput.Properties.KeyId
			instance.KeyId = &keyId
		}
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			instance.LicenseType = &licenseType
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		instance.Location = &location
	}

	// Set property ‘MaintenanceConfigurationId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaintenanceConfigurationId != nil {
			maintenanceConfigurationId := *typedInput.Properties.MaintenanceConfigurationId
			instance.MaintenanceConfigurationId = &maintenanceConfigurationId
		}
	}

	// Set property ‘ManagedInstanceCreateMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedInstanceCreateMode != nil {
			managedInstanceCreateMode := *typedInput.Properties.ManagedInstanceCreateMode
			instance.ManagedInstanceCreateMode = &managedInstanceCreateMode
		}
	}

	// Set property ‘MinimalTlsVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimalTlsVersion != nil {
			minimalTlsVersion := *typedInput.Properties.MinimalTlsVersion
			instance.MinimalTlsVersion = &minimalTlsVersion
		}
	}

	// Set property ‘Owner’:
	instance.Owner = &genruntime.KnownResourceReference{Name: owner.Name}

	// no assignment for property ‘PrimaryUserAssignedIdentityReference’

	// Set property ‘ProxyOverride’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProxyOverride != nil {
			proxyOverride := *typedInput.Properties.ProxyOverride
			instance.ProxyOverride = &proxyOverride
		}
	}

	// Set property ‘PublicDataEndpointEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicDataEndpointEnabled != nil {
			publicDataEndpointEnabled := *typedInput.Properties.PublicDataEndpointEnabled
			instance.PublicDataEndpointEnabled = &publicDataEndpointEnabled
		}
	}

	// Set property ‘RequestedBackupStorageRedundancy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestedBackupStorageRedundancy != nil {
			requestedBackupStorageRedundancy := *typedInput.Properties.RequestedBackupStorageRedundancy
			instance.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
		}
	}

	// Set property ‘RestorePointInTime’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePointInTime != nil {
			restorePointInTime := *typedInput.Properties.RestorePointInTime
			instance.RestorePointInTime = &restorePointInTime
		}
	}

	// Set property ‘ServicePrincipal’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipal != nil {
			var servicePrincipal1 ServicePrincipal
			err := servicePrincipal1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipal)
			if err != nil {
				return err
			}
			servicePrincipal := servicePrincipal1
			instance.ServicePrincipal = &servicePrincipal
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		instance.Sku = &sku
	}

	// no assignment for property ‘SourceManagedInstanceReference’

	// Set property ‘StorageSizeInGB’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageSizeInGB != nil {
			storageSizeInGB := *typedInput.Properties.StorageSizeInGB
			instance.StorageSizeInGB = &storageSizeInGB
		}
	}

	// no assignment for property ‘SubnetReference’

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		instance.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			instance.Tags[key] = value
		}
	}

	// Set property ‘TimezoneId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TimezoneId != nil {
			timezoneId := *typedInput.Properties.TimezoneId
			instance.TimezoneId = &timezoneId
		}
	}

	// Set property ‘VCores’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VCores != nil {
			vCores := *typedInput.Properties.VCores
			instance.VCores = &vCores
		}
	}

	// Set property ‘ZoneRedundant’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			instance.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedInstance_Spec{}

// ConvertSpecFrom populates our ManagedInstance_Spec from the provided source
func (instance *ManagedInstance_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20211101s.ManagedInstance_Spec)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_ManagedInstance_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20211101s.ManagedInstance_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_ManagedInstance_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedInstance_Spec
func (instance *ManagedInstance_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20211101s.ManagedInstance_Spec)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_ManagedInstance_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20211101s.ManagedInstance_Spec{}
	err := instance.AssignProperties_To_ManagedInstance_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ManagedInstance_Spec populates our ManagedInstance_Spec from the provided source ManagedInstance_Spec
func (instance *ManagedInstance_Spec) AssignProperties_From_ManagedInstance_Spec(source *v20211101s.ManagedInstance_Spec) error {

	// AdministratorLogin
	instance.AdministratorLogin = genruntime.ClonePointerToString(source.AdministratorLogin)

	// AdministratorLoginPassword
	if source.AdministratorLoginPassword != nil {
		administratorLoginPassword := source.AdministratorLoginPassword.Copy()
		instance.AdministratorLoginPassword = &administratorLoginPassword
	} else {
		instance.AdministratorLoginPassword = nil
	}

	// Administrators
	if source.Administrators != nil {
		var administrator ManagedInstanceExternalAdministrator
		err := administrator.AssignProperties_From_ManagedInstanceExternalAdministrator(source.Administrators)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedInstanceExternalAdministrator() to populate field Administrators")
		}
		instance.Administrators = &administrator
	} else {
		instance.Administrators = nil
	}

	// AzureName
	instance.AzureName = source.AzureName

	// Collation
	instance.Collation = genruntime.ClonePointerToString(source.Collation)

	// DnsZonePartnerReference
	if source.DnsZonePartnerReference != nil {
		dnsZonePartnerReference := source.DnsZonePartnerReference.Copy()
		instance.DnsZonePartnerReference = &dnsZonePartnerReference
	} else {
		instance.DnsZonePartnerReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ResourceIdentity
		err := identity.AssignProperties_From_ResourceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceIdentity() to populate field Identity")
		}
		instance.Identity = &identity
	} else {
		instance.Identity = nil
	}

	// InstancePoolId
	instance.InstancePoolId = genruntime.ClonePointerToString(source.InstancePoolId)

	// KeyId
	instance.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedInstanceProperties_LicenseType(*source.LicenseType)
		instance.LicenseType = &licenseType
	} else {
		instance.LicenseType = nil
	}

	// Location
	instance.Location = genruntime.ClonePointerToString(source.Location)

	// MaintenanceConfigurationId
	instance.MaintenanceConfigurationId = genruntime.ClonePointerToString(source.MaintenanceConfigurationId)

	// ManagedInstanceCreateMode
	if source.ManagedInstanceCreateMode != nil {
		managedInstanceCreateMode := ManagedInstanceProperties_ManagedInstanceCreateMode(*source.ManagedInstanceCreateMode)
		instance.ManagedInstanceCreateMode = &managedInstanceCreateMode
	} else {
		instance.ManagedInstanceCreateMode = nil
	}

	// MinimalTlsVersion
	instance.MinimalTlsVersion = genruntime.ClonePointerToString(source.MinimalTlsVersion)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		instance.Owner = &owner
	} else {
		instance.Owner = nil
	}

	// PrimaryUserAssignedIdentityReference
	if source.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityReference := source.PrimaryUserAssignedIdentityReference.Copy()
		instance.PrimaryUserAssignedIdentityReference = &primaryUserAssignedIdentityReference
	} else {
		instance.PrimaryUserAssignedIdentityReference = nil
	}

	// ProxyOverride
	if source.ProxyOverride != nil {
		proxyOverride := ManagedInstanceProperties_ProxyOverride(*source.ProxyOverride)
		instance.ProxyOverride = &proxyOverride
	} else {
		instance.ProxyOverride = nil
	}

	// PublicDataEndpointEnabled
	if source.PublicDataEndpointEnabled != nil {
		publicDataEndpointEnabled := *source.PublicDataEndpointEnabled
		instance.PublicDataEndpointEnabled = &publicDataEndpointEnabled
	} else {
		instance.PublicDataEndpointEnabled = nil
	}

	// RequestedBackupStorageRedundancy
	if source.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := ManagedInstanceProperties_RequestedBackupStorageRedundancy(*source.RequestedBackupStorageRedundancy)
		instance.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		instance.RequestedBackupStorageRedundancy = nil
	}

	// RestorePointInTime
	if source.RestorePointInTime != nil {
		restorePointInTime := *source.RestorePointInTime
		instance.RestorePointInTime = &restorePointInTime
	} else {
		instance.RestorePointInTime = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipal
		err := servicePrincipal.AssignProperties_From_ServicePrincipal(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipal() to populate field ServicePrincipal")
		}
		instance.ServicePrincipal = &servicePrincipal
	} else {
		instance.ServicePrincipal = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		instance.Sku = &sku
	} else {
		instance.Sku = nil
	}

	// SourceManagedInstanceReference
	if source.SourceManagedInstanceReference != nil {
		sourceManagedInstanceReference := source.SourceManagedInstanceReference.Copy()
		instance.SourceManagedInstanceReference = &sourceManagedInstanceReference
	} else {
		instance.SourceManagedInstanceReference = nil
	}

	// StorageSizeInGB
	instance.StorageSizeInGB = genruntime.ClonePointerToInt(source.StorageSizeInGB)

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		instance.SubnetReference = &subnetReference
	} else {
		instance.SubnetReference = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimezoneId
	instance.TimezoneId = genruntime.ClonePointerToString(source.TimezoneId)

	// VCores
	instance.VCores = genruntime.ClonePointerToInt(source.VCores)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		instance.ZoneRedundant = &zoneRedundant
	} else {
		instance.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedInstance_Spec populates the provided destination ManagedInstance_Spec from our ManagedInstance_Spec
func (instance *ManagedInstance_Spec) AssignProperties_To_ManagedInstance_Spec(destination *v20211101s.ManagedInstance_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorLogin
	destination.AdministratorLogin = genruntime.ClonePointerToString(instance.AdministratorLogin)

	// AdministratorLoginPassword
	if instance.AdministratorLoginPassword != nil {
		administratorLoginPassword := instance.AdministratorLoginPassword.Copy()
		destination.AdministratorLoginPassword = &administratorLoginPassword
	} else {
		destination.AdministratorLoginPassword = nil
	}

	// Administrators
	if instance.Administrators != nil {
		var administrator v20211101s.ManagedInstanceExternalAdministrator
		err := instance.Administrators.AssignProperties_To_ManagedInstanceExternalAdministrator(&administrator)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedInstanceExternalAdministrator() to populate field Administrators")
		}
		destination.Administrators = &administrator
	} else {
		destination.Administrators = nil
	}

	// AzureName
	destination.AzureName = instance.AzureName

	// Collation
	destination.Collation = genruntime.ClonePointerToString(instance.Collation)

	// DnsZonePartnerReference
	if instance.DnsZonePartnerReference != nil {
		dnsZonePartnerReference := instance.DnsZonePartnerReference.Copy()
		destination.DnsZonePartnerReference = &dnsZonePartnerReference
	} else {
		destination.DnsZonePartnerReference = nil
	}

	// Identity
	if instance.Identity != nil {
		var identity v20211101s.ResourceIdentity
		err := instance.Identity.AssignProperties_To_ResourceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstancePoolId
	destination.InstancePoolId = genruntime.ClonePointerToString(instance.InstancePoolId)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(instance.KeyId)

	// LicenseType
	if instance.LicenseType != nil {
		licenseType := string(*instance.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(instance.Location)

	// MaintenanceConfigurationId
	destination.MaintenanceConfigurationId = genruntime.ClonePointerToString(instance.MaintenanceConfigurationId)

	// ManagedInstanceCreateMode
	if instance.ManagedInstanceCreateMode != nil {
		managedInstanceCreateMode := string(*instance.ManagedInstanceCreateMode)
		destination.ManagedInstanceCreateMode = &managedInstanceCreateMode
	} else {
		destination.ManagedInstanceCreateMode = nil
	}

	// MinimalTlsVersion
	destination.MinimalTlsVersion = genruntime.ClonePointerToString(instance.MinimalTlsVersion)

	// OriginalVersion
	destination.OriginalVersion = instance.OriginalVersion()

	// Owner
	if instance.Owner != nil {
		owner := instance.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PrimaryUserAssignedIdentityReference
	if instance.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityReference := instance.PrimaryUserAssignedIdentityReference.Copy()
		destination.PrimaryUserAssignedIdentityReference = &primaryUserAssignedIdentityReference
	} else {
		destination.PrimaryUserAssignedIdentityReference = nil
	}

	// ProxyOverride
	if instance.ProxyOverride != nil {
		proxyOverride := string(*instance.ProxyOverride)
		destination.ProxyOverride = &proxyOverride
	} else {
		destination.ProxyOverride = nil
	}

	// PublicDataEndpointEnabled
	if instance.PublicDataEndpointEnabled != nil {
		publicDataEndpointEnabled := *instance.PublicDataEndpointEnabled
		destination.PublicDataEndpointEnabled = &publicDataEndpointEnabled
	} else {
		destination.PublicDataEndpointEnabled = nil
	}

	// RequestedBackupStorageRedundancy
	if instance.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := string(*instance.RequestedBackupStorageRedundancy)
		destination.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		destination.RequestedBackupStorageRedundancy = nil
	}

	// RestorePointInTime
	if instance.RestorePointInTime != nil {
		restorePointInTime := *instance.RestorePointInTime
		destination.RestorePointInTime = &restorePointInTime
	} else {
		destination.RestorePointInTime = nil
	}

	// ServicePrincipal
	if instance.ServicePrincipal != nil {
		var servicePrincipal v20211101s.ServicePrincipal
		err := instance.ServicePrincipal.AssignProperties_To_ServicePrincipal(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipal() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// Sku
	if instance.Sku != nil {
		var sku v20211101s.Sku
		err := instance.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SourceManagedInstanceReference
	if instance.SourceManagedInstanceReference != nil {
		sourceManagedInstanceReference := instance.SourceManagedInstanceReference.Copy()
		destination.SourceManagedInstanceReference = &sourceManagedInstanceReference
	} else {
		destination.SourceManagedInstanceReference = nil
	}

	// StorageSizeInGB
	destination.StorageSizeInGB = genruntime.ClonePointerToInt(instance.StorageSizeInGB)

	// SubnetReference
	if instance.SubnetReference != nil {
		subnetReference := instance.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// TimezoneId
	destination.TimezoneId = genruntime.ClonePointerToString(instance.TimezoneId)

	// VCores
	destination.VCores = genruntime.ClonePointerToInt(instance.VCores)

	// ZoneRedundant
	if instance.ZoneRedundant != nil {
		zoneRedundant := *instance.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (instance *ManagedInstance_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (instance *ManagedInstance_Spec) SetAzureName(azureName string) { instance.AzureName = azureName }

// An Azure SQL managed instance.
type ManagedInstance_STATUS struct {
	// AdministratorLogin: Administrator username for the managed instance. Can only be specified when the managed instance is
	// being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// Administrators: The Azure Active Directory administrator of the server.
	Administrators *ManagedInstanceExternalAdministrator_STATUS `json:"administrators,omitempty"`

	// Collation: Collation of the managed instance.
	Collation *string `json:"collation,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CurrentBackupStorageRedundancy: The storage account type used to store backups for this instance. The options are Local
	// (LocallyRedundantStorage), Zone (ZoneRedundantStorage), Geo (GeoRedundantStorage) and GeoZone(GeoZoneRedundantStorage)
	CurrentBackupStorageRedundancy *ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS `json:"currentBackupStorageRedundancy,omitempty"`

	// DnsZone: The Dns Zone that the managed instance is in.
	DnsZone *string `json:"dnsZone,omitempty"`

	// DnsZonePartner: The resource id of another managed instance whose DNS zone this managed instance will share after
	// creation.
	DnsZonePartner *string `json:"dnsZonePartner,omitempty"`

	// FullyQualifiedDomainName: The fully qualified domain name of the managed instance.
	FullyQualifiedDomainName *string `json:"fullyQualifiedDomainName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Identity: The Azure Active Directory identity of the managed instance.
	Identity *ResourceIdentity_STATUS `json:"identity,omitempty"`

	// InstancePoolId: The Id of the instance pool this managed server belongs to.
	InstancePoolId *string `json:"instancePoolId,omitempty"`

	// KeyId: A CMK URI of the key to use for encryption.
	KeyId *string `json:"keyId,omitempty"`

	// LicenseType: The license type. Possible values are 'LicenseIncluded' (regular price inclusive of a new SQL license) and
	// 'BasePrice' (discounted AHB price for bringing your own SQL licenses).
	LicenseType *ManagedInstanceProperties_LicenseType_STATUS `json:"licenseType,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// MaintenanceConfigurationId: Specifies maintenance configuration id to apply to this managed instance.
	MaintenanceConfigurationId *string `json:"maintenanceConfigurationId,omitempty"`

	// ManagedInstanceCreateMode: Specifies the mode of database creation.
	// Default: Regular instance creation.
	// Restore: Creates an instance by restoring a set of backups to specific point in time. RestorePointInTime and
	// SourceManagedInstanceId must be specified.
	ManagedInstanceCreateMode *ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS `json:"managedInstanceCreateMode,omitempty"`

	// MinimalTlsVersion: Minimal TLS version. Allowed values: 'None', '1.0', '1.1', '1.2'
	MinimalTlsVersion *string `json:"minimalTlsVersion,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PrimaryUserAssignedIdentityId: The resource id of a user assigned identity to be used by default.
	PrimaryUserAssignedIdentityId *string `json:"primaryUserAssignedIdentityId,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connections on a managed instance.
	PrivateEndpointConnections []ManagedInstancePecProperty_STATUS                 `json:"privateEndpointConnections,omitempty"`
	ProvisioningState          *ManagedInstanceProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ProxyOverride: Connection type used for connecting to the instance.
	ProxyOverride *ManagedInstanceProperties_ProxyOverride_STATUS `json:"proxyOverride,omitempty"`

	// PublicDataEndpointEnabled: Whether or not the public data endpoint is enabled.
	PublicDataEndpointEnabled *bool `json:"publicDataEndpointEnabled,omitempty"`

	// RequestedBackupStorageRedundancy: The storage account type to be used to store backups for this instance. The options
	// are Local (LocallyRedundantStorage), Zone (ZoneRedundantStorage), Geo (GeoRedundantStorage) and
	// GeoZone(GeoZoneRedundantStorage)
	RequestedBackupStorageRedundancy *ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS `json:"requestedBackupStorageRedundancy,omitempty"`

	// RestorePointInTime: Specifies the point in time (ISO8601 format) of the source database that will be restored to create
	// the new database.
	RestorePointInTime *string `json:"restorePointInTime,omitempty"`

	// ServicePrincipal: The managed instance's service principal.
	ServicePrincipal *ServicePrincipal_STATUS `json:"servicePrincipal,omitempty"`

	// Sku: Managed instance SKU. Allowed values for sku.name: GP_Gen5, GP_G8IM, GP_G8IH, BC_Gen5, BC_G8IM, BC_G8IH
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SourceManagedInstanceId: The resource identifier of the source managed instance associated with create operation of this
	// instance.
	SourceManagedInstanceId *string `json:"sourceManagedInstanceId,omitempty"`

	// State: The state of the managed instance.
	State *string `json:"state,omitempty"`

	// StorageSizeInGB: Storage size in GB. Minimum value: 32. Maximum value: 16384. Increments of 32 GB allowed only. Maximum
	// value depends on the selected hardware family and number of vCores.
	StorageSizeInGB *int `json:"storageSizeInGB,omitempty"`

	// SubnetId: Subnet resource ID for the managed instance.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TimezoneId: Id of the timezone. Allowed values are timezones supported by Windows.
	// Windows keeps details on supported timezones, including the id, in registry under
	// KEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones.
	// You can get those registry values via SQL Server by querying SELECT name AS timezone_id FROM sys.time_zone_info.
	// List of Ids can also be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
	// An example of valid timezone id is "Pacific Standard Time" or "W. Europe Standard Time".
	TimezoneId *string `json:"timezoneId,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// VCores: The number of vCores. Allowed values: 8, 16, 24, 32, 40, 64, 80.
	VCores *int `json:"vCores,omitempty"`

	// ZoneRedundant: Whether or not the multi-az is enabled.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedInstance_STATUS{}

// ConvertStatusFrom populates our ManagedInstance_STATUS from the provided source
func (instance *ManagedInstance_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20211101s.ManagedInstance_STATUS)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_ManagedInstance_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20211101s.ManagedInstance_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_ManagedInstance_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedInstance_STATUS
func (instance *ManagedInstance_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20211101s.ManagedInstance_STATUS)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_ManagedInstance_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20211101s.ManagedInstance_STATUS{}
	err := instance.AssignProperties_To_ManagedInstance_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedInstance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ManagedInstance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstance_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ManagedInstance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstance_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstance_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AdministratorLogin’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdministratorLogin != nil {
			administratorLogin := *typedInput.Properties.AdministratorLogin
			instance.AdministratorLogin = &administratorLogin
		}
	}

	// Set property ‘Administrators’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Administrators != nil {
			var administrators1 ManagedInstanceExternalAdministrator_STATUS
			err := administrators1.PopulateFromARM(owner, *typedInput.Properties.Administrators)
			if err != nil {
				return err
			}
			administrators := administrators1
			instance.Administrators = &administrators
		}
	}

	// Set property ‘Collation’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Collation != nil {
			collation := *typedInput.Properties.Collation
			instance.Collation = &collation
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘CurrentBackupStorageRedundancy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentBackupStorageRedundancy != nil {
			currentBackupStorageRedundancy := *typedInput.Properties.CurrentBackupStorageRedundancy
			instance.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
		}
	}

	// Set property ‘DnsZone’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsZone != nil {
			dnsZone := *typedInput.Properties.DnsZone
			instance.DnsZone = &dnsZone
		}
	}

	// Set property ‘DnsZonePartner’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsZonePartner != nil {
			dnsZonePartner := *typedInput.Properties.DnsZonePartner
			instance.DnsZonePartner = &dnsZonePartner
		}
	}

	// Set property ‘FullyQualifiedDomainName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FullyQualifiedDomainName != nil {
			fullyQualifiedDomainName := *typedInput.Properties.FullyQualifiedDomainName
			instance.FullyQualifiedDomainName = &fullyQualifiedDomainName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		instance.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ResourceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		instance.Identity = &identity
	}

	// Set property ‘InstancePoolId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstancePoolId != nil {
			instancePoolId := *typedInput.Properties.InstancePoolId
			instance.InstancePoolId = &instancePoolId
		}
	}

	// Set property ‘KeyId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyId != nil {
			keyId := *typedInput.Properties.KeyId
			instance.KeyId = &keyId
		}
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			instance.LicenseType = &licenseType
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		instance.Location = &location
	}

	// Set property ‘MaintenanceConfigurationId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaintenanceConfigurationId != nil {
			maintenanceConfigurationId := *typedInput.Properties.MaintenanceConfigurationId
			instance.MaintenanceConfigurationId = &maintenanceConfigurationId
		}
	}

	// Set property ‘ManagedInstanceCreateMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedInstanceCreateMode != nil {
			managedInstanceCreateMode := *typedInput.Properties.ManagedInstanceCreateMode
			instance.ManagedInstanceCreateMode = &managedInstanceCreateMode
		}
	}

	// Set property ‘MinimalTlsVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimalTlsVersion != nil {
			minimalTlsVersion := *typedInput.Properties.MinimalTlsVersion
			instance.MinimalTlsVersion = &minimalTlsVersion
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		instance.Name = &name
	}

	// Set property ‘PrimaryUserAssignedIdentityId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrimaryUserAssignedIdentityId != nil {
			primaryUserAssignedIdentityId := *typedInput.Properties.PrimaryUserAssignedIdentityId
			instance.PrimaryUserAssignedIdentityId = &primaryUserAssignedIdentityId
		}
	}

	// Set property ‘PrivateEndpointConnections’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 ManagedInstancePecProperty_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			instance.PrivateEndpointConnections = append(instance.PrivateEndpointConnections, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			instance.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProxyOverride’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProxyOverride != nil {
			proxyOverride := *typedInput.Properties.ProxyOverride
			instance.ProxyOverride = &proxyOverride
		}
	}

	// Set property ‘PublicDataEndpointEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicDataEndpointEnabled != nil {
			publicDataEndpointEnabled := *typedInput.Properties.PublicDataEndpointEnabled
			instance.PublicDataEndpointEnabled = &publicDataEndpointEnabled
		}
	}

	// Set property ‘RequestedBackupStorageRedundancy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestedBackupStorageRedundancy != nil {
			requestedBackupStorageRedundancy := *typedInput.Properties.RequestedBackupStorageRedundancy
			instance.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
		}
	}

	// Set property ‘RestorePointInTime’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePointInTime != nil {
			restorePointInTime := *typedInput.Properties.RestorePointInTime
			instance.RestorePointInTime = &restorePointInTime
		}
	}

	// Set property ‘ServicePrincipal’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipal != nil {
			var servicePrincipal1 ServicePrincipal_STATUS
			err := servicePrincipal1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipal)
			if err != nil {
				return err
			}
			servicePrincipal := servicePrincipal1
			instance.ServicePrincipal = &servicePrincipal
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		instance.Sku = &sku
	}

	// Set property ‘SourceManagedInstanceId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceManagedInstanceId != nil {
			sourceManagedInstanceId := *typedInput.Properties.SourceManagedInstanceId
			instance.SourceManagedInstanceId = &sourceManagedInstanceId
		}
	}

	// Set property ‘State’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.State != nil {
			state := *typedInput.Properties.State
			instance.State = &state
		}
	}

	// Set property ‘StorageSizeInGB’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageSizeInGB != nil {
			storageSizeInGB := *typedInput.Properties.StorageSizeInGB
			instance.StorageSizeInGB = &storageSizeInGB
		}
	}

	// Set property ‘SubnetId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SubnetId != nil {
			subnetId := *typedInput.Properties.SubnetId
			instance.SubnetId = &subnetId
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		instance.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			instance.Tags[key] = value
		}
	}

	// Set property ‘TimezoneId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TimezoneId != nil {
			timezoneId := *typedInput.Properties.TimezoneId
			instance.TimezoneId = &timezoneId
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		instance.Type = &typeVar
	}

	// Set property ‘VCores’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VCores != nil {
			vCores := *typedInput.Properties.VCores
			instance.VCores = &vCores
		}
	}

	// Set property ‘ZoneRedundant’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			instance.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstance_STATUS populates our ManagedInstance_STATUS from the provided source ManagedInstance_STATUS
func (instance *ManagedInstance_STATUS) AssignProperties_From_ManagedInstance_STATUS(source *v20211101s.ManagedInstance_STATUS) error {

	// AdministratorLogin
	instance.AdministratorLogin = genruntime.ClonePointerToString(source.AdministratorLogin)

	// Administrators
	if source.Administrators != nil {
		var administrator ManagedInstanceExternalAdministrator_STATUS
		err := administrator.AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS(source.Administrators)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS() to populate field Administrators")
		}
		instance.Administrators = &administrator
	} else {
		instance.Administrators = nil
	}

	// Collation
	instance.Collation = genruntime.ClonePointerToString(source.Collation)

	// Conditions
	instance.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CurrentBackupStorageRedundancy
	if source.CurrentBackupStorageRedundancy != nil {
		currentBackupStorageRedundancy := ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS(*source.CurrentBackupStorageRedundancy)
		instance.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
	} else {
		instance.CurrentBackupStorageRedundancy = nil
	}

	// DnsZone
	instance.DnsZone = genruntime.ClonePointerToString(source.DnsZone)

	// DnsZonePartner
	instance.DnsZonePartner = genruntime.ClonePointerToString(source.DnsZonePartner)

	// FullyQualifiedDomainName
	instance.FullyQualifiedDomainName = genruntime.ClonePointerToString(source.FullyQualifiedDomainName)

	// Id
	instance.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ResourceIdentity_STATUS
		err := identity.AssignProperties_From_ResourceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceIdentity_STATUS() to populate field Identity")
		}
		instance.Identity = &identity
	} else {
		instance.Identity = nil
	}

	// InstancePoolId
	instance.InstancePoolId = genruntime.ClonePointerToString(source.InstancePoolId)

	// KeyId
	instance.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedInstanceProperties_LicenseType_STATUS(*source.LicenseType)
		instance.LicenseType = &licenseType
	} else {
		instance.LicenseType = nil
	}

	// Location
	instance.Location = genruntime.ClonePointerToString(source.Location)

	// MaintenanceConfigurationId
	instance.MaintenanceConfigurationId = genruntime.ClonePointerToString(source.MaintenanceConfigurationId)

	// ManagedInstanceCreateMode
	if source.ManagedInstanceCreateMode != nil {
		managedInstanceCreateMode := ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS(*source.ManagedInstanceCreateMode)
		instance.ManagedInstanceCreateMode = &managedInstanceCreateMode
	} else {
		instance.ManagedInstanceCreateMode = nil
	}

	// MinimalTlsVersion
	instance.MinimalTlsVersion = genruntime.ClonePointerToString(source.MinimalTlsVersion)

	// Name
	instance.Name = genruntime.ClonePointerToString(source.Name)

	// PrimaryUserAssignedIdentityId
	instance.PrimaryUserAssignedIdentityId = genruntime.ClonePointerToString(source.PrimaryUserAssignedIdentityId)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]ManagedInstancePecProperty_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection ManagedInstancePecProperty_STATUS
			err := privateEndpointConnection.AssignProperties_From_ManagedInstancePecProperty_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedInstancePecProperty_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		instance.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		instance.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ManagedInstanceProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		instance.ProvisioningState = &provisioningState
	} else {
		instance.ProvisioningState = nil
	}

	// ProxyOverride
	if source.ProxyOverride != nil {
		proxyOverride := ManagedInstanceProperties_ProxyOverride_STATUS(*source.ProxyOverride)
		instance.ProxyOverride = &proxyOverride
	} else {
		instance.ProxyOverride = nil
	}

	// PublicDataEndpointEnabled
	if source.PublicDataEndpointEnabled != nil {
		publicDataEndpointEnabled := *source.PublicDataEndpointEnabled
		instance.PublicDataEndpointEnabled = &publicDataEndpointEnabled
	} else {
		instance.PublicDataEndpointEnabled = nil
	}

	// RequestedBackupStorageRedundancy
	if source.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS(*source.RequestedBackupStorageRedundancy)
		instance.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		instance.RequestedBackupStorageRedundancy = nil
	}

	// RestorePointInTime
	instance.RestorePointInTime = genruntime.ClonePointerToString(source.RestorePointInTime)

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipal_STATUS
		err := servicePrincipal.AssignProperties_From_ServicePrincipal_STATUS(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipal_STATUS() to populate field ServicePrincipal")
		}
		instance.ServicePrincipal = &servicePrincipal
	} else {
		instance.ServicePrincipal = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		instance.Sku = &sku
	} else {
		instance.Sku = nil
	}

	// SourceManagedInstanceId
	instance.SourceManagedInstanceId = genruntime.ClonePointerToString(source.SourceManagedInstanceId)

	// State
	instance.State = genruntime.ClonePointerToString(source.State)

	// StorageSizeInGB
	instance.StorageSizeInGB = genruntime.ClonePointerToInt(source.StorageSizeInGB)

	// SubnetId
	instance.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimezoneId
	instance.TimezoneId = genruntime.ClonePointerToString(source.TimezoneId)

	// Type
	instance.Type = genruntime.ClonePointerToString(source.Type)

	// VCores
	instance.VCores = genruntime.ClonePointerToInt(source.VCores)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		instance.ZoneRedundant = &zoneRedundant
	} else {
		instance.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedInstance_STATUS populates the provided destination ManagedInstance_STATUS from our ManagedInstance_STATUS
func (instance *ManagedInstance_STATUS) AssignProperties_To_ManagedInstance_STATUS(destination *v20211101s.ManagedInstance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorLogin
	destination.AdministratorLogin = genruntime.ClonePointerToString(instance.AdministratorLogin)

	// Administrators
	if instance.Administrators != nil {
		var administrator v20211101s.ManagedInstanceExternalAdministrator_STATUS
		err := instance.Administrators.AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS(&administrator)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS() to populate field Administrators")
		}
		destination.Administrators = &administrator
	} else {
		destination.Administrators = nil
	}

	// Collation
	destination.Collation = genruntime.ClonePointerToString(instance.Collation)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(instance.Conditions)

	// CurrentBackupStorageRedundancy
	if instance.CurrentBackupStorageRedundancy != nil {
		currentBackupStorageRedundancy := string(*instance.CurrentBackupStorageRedundancy)
		destination.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
	} else {
		destination.CurrentBackupStorageRedundancy = nil
	}

	// DnsZone
	destination.DnsZone = genruntime.ClonePointerToString(instance.DnsZone)

	// DnsZonePartner
	destination.DnsZonePartner = genruntime.ClonePointerToString(instance.DnsZonePartner)

	// FullyQualifiedDomainName
	destination.FullyQualifiedDomainName = genruntime.ClonePointerToString(instance.FullyQualifiedDomainName)

	// Id
	destination.Id = genruntime.ClonePointerToString(instance.Id)

	// Identity
	if instance.Identity != nil {
		var identity v20211101s.ResourceIdentity_STATUS
		err := instance.Identity.AssignProperties_To_ResourceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstancePoolId
	destination.InstancePoolId = genruntime.ClonePointerToString(instance.InstancePoolId)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(instance.KeyId)

	// LicenseType
	if instance.LicenseType != nil {
		licenseType := string(*instance.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(instance.Location)

	// MaintenanceConfigurationId
	destination.MaintenanceConfigurationId = genruntime.ClonePointerToString(instance.MaintenanceConfigurationId)

	// ManagedInstanceCreateMode
	if instance.ManagedInstanceCreateMode != nil {
		managedInstanceCreateMode := string(*instance.ManagedInstanceCreateMode)
		destination.ManagedInstanceCreateMode = &managedInstanceCreateMode
	} else {
		destination.ManagedInstanceCreateMode = nil
	}

	// MinimalTlsVersion
	destination.MinimalTlsVersion = genruntime.ClonePointerToString(instance.MinimalTlsVersion)

	// Name
	destination.Name = genruntime.ClonePointerToString(instance.Name)

	// PrimaryUserAssignedIdentityId
	destination.PrimaryUserAssignedIdentityId = genruntime.ClonePointerToString(instance.PrimaryUserAssignedIdentityId)

	// PrivateEndpointConnections
	if instance.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]v20211101s.ManagedInstancePecProperty_STATUS, len(instance.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range instance.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection v20211101s.ManagedInstancePecProperty_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_ManagedInstancePecProperty_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedInstancePecProperty_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if instance.ProvisioningState != nil {
		provisioningState := string(*instance.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ProxyOverride
	if instance.ProxyOverride != nil {
		proxyOverride := string(*instance.ProxyOverride)
		destination.ProxyOverride = &proxyOverride
	} else {
		destination.ProxyOverride = nil
	}

	// PublicDataEndpointEnabled
	if instance.PublicDataEndpointEnabled != nil {
		publicDataEndpointEnabled := *instance.PublicDataEndpointEnabled
		destination.PublicDataEndpointEnabled = &publicDataEndpointEnabled
	} else {
		destination.PublicDataEndpointEnabled = nil
	}

	// RequestedBackupStorageRedundancy
	if instance.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := string(*instance.RequestedBackupStorageRedundancy)
		destination.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		destination.RequestedBackupStorageRedundancy = nil
	}

	// RestorePointInTime
	destination.RestorePointInTime = genruntime.ClonePointerToString(instance.RestorePointInTime)

	// ServicePrincipal
	if instance.ServicePrincipal != nil {
		var servicePrincipal v20211101s.ServicePrincipal_STATUS
		err := instance.ServicePrincipal.AssignProperties_To_ServicePrincipal_STATUS(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipal_STATUS() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// Sku
	if instance.Sku != nil {
		var sku v20211101s.Sku_STATUS
		err := instance.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SourceManagedInstanceId
	destination.SourceManagedInstanceId = genruntime.ClonePointerToString(instance.SourceManagedInstanceId)

	// State
	destination.State = genruntime.ClonePointerToString(instance.State)

	// StorageSizeInGB
	destination.StorageSizeInGB = genruntime.ClonePointerToInt(instance.StorageSizeInGB)

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(instance.SubnetId)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// TimezoneId
	destination.TimezoneId = genruntime.ClonePointerToString(instance.TimezoneId)

	// Type
	destination.Type = genruntime.ClonePointerToString(instance.Type)

	// VCores
	destination.VCores = genruntime.ClonePointerToInt(instance.VCores)

	// ZoneRedundant
	if instance.ZoneRedundant != nil {
		zoneRedundant := *instance.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of a active directory administrator.
type ManagedInstanceExternalAdministrator struct {
	// AdministratorType: Type of the sever administrator.
	AdministratorType *ManagedInstanceExternalAdministrator_AdministratorType `json:"administratorType,omitempty"`

	// AzureADOnlyAuthentication: Azure Active Directory only Authentication enabled.
	AzureADOnlyAuthentication *bool `json:"azureADOnlyAuthentication,omitempty"`

	// Login: Login name of the server administrator.
	Login *string `json:"login,omitempty"`

	// PrincipalType: Principal Type of the sever administrator.
	PrincipalType *ManagedInstanceExternalAdministrator_PrincipalType `json:"principalType,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// Sid: SID (object ID) of the server administrator.
	Sid *string `json:"sid,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// TenantId: Tenant ID of the administrator.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedInstanceExternalAdministrator{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (administrator *ManagedInstanceExternalAdministrator) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if administrator == nil {
		return nil, nil
	}
	result := &ManagedInstanceExternalAdministrator_ARM{}

	// Set property ‘AdministratorType’:
	if administrator.AdministratorType != nil {
		administratorType := *administrator.AdministratorType
		result.AdministratorType = &administratorType
	}

	// Set property ‘AzureADOnlyAuthentication’:
	if administrator.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *administrator.AzureADOnlyAuthentication
		result.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	}

	// Set property ‘Login’:
	if administrator.Login != nil {
		login := *administrator.Login
		result.Login = &login
	}

	// Set property ‘PrincipalType’:
	if administrator.PrincipalType != nil {
		principalType := *administrator.PrincipalType
		result.PrincipalType = &principalType
	}

	// Set property ‘Sid’:
	if administrator.Sid != nil {
		sid := *administrator.Sid
		result.Sid = &sid
	}

	// Set property ‘TenantId’:
	if administrator.TenantId != nil {
		tenantId := *administrator.TenantId
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (administrator *ManagedInstanceExternalAdministrator) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstanceExternalAdministrator_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (administrator *ManagedInstanceExternalAdministrator) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstanceExternalAdministrator_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstanceExternalAdministrator_ARM, got %T", armInput)
	}

	// Set property ‘AdministratorType’:
	if typedInput.AdministratorType != nil {
		administratorType := *typedInput.AdministratorType
		administrator.AdministratorType = &administratorType
	}

	// Set property ‘AzureADOnlyAuthentication’:
	if typedInput.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *typedInput.AzureADOnlyAuthentication
		administrator.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	}

	// Set property ‘Login’:
	if typedInput.Login != nil {
		login := *typedInput.Login
		administrator.Login = &login
	}

	// Set property ‘PrincipalType’:
	if typedInput.PrincipalType != nil {
		principalType := *typedInput.PrincipalType
		administrator.PrincipalType = &principalType
	}

	// Set property ‘Sid’:
	if typedInput.Sid != nil {
		sid := *typedInput.Sid
		administrator.Sid = &sid
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		administrator.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstanceExternalAdministrator populates our ManagedInstanceExternalAdministrator from the provided source ManagedInstanceExternalAdministrator
func (administrator *ManagedInstanceExternalAdministrator) AssignProperties_From_ManagedInstanceExternalAdministrator(source *v20211101s.ManagedInstanceExternalAdministrator) error {

	// AdministratorType
	if source.AdministratorType != nil {
		administratorType := ManagedInstanceExternalAdministrator_AdministratorType(*source.AdministratorType)
		administrator.AdministratorType = &administratorType
	} else {
		administrator.AdministratorType = nil
	}

	// AzureADOnlyAuthentication
	if source.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *source.AzureADOnlyAuthentication
		administrator.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	} else {
		administrator.AzureADOnlyAuthentication = nil
	}

	// Login
	administrator.Login = genruntime.ClonePointerToString(source.Login)

	// PrincipalType
	if source.PrincipalType != nil {
		principalType := ManagedInstanceExternalAdministrator_PrincipalType(*source.PrincipalType)
		administrator.PrincipalType = &principalType
	} else {
		administrator.PrincipalType = nil
	}

	// Sid
	if source.Sid != nil {
		sid := *source.Sid
		administrator.Sid = &sid
	} else {
		administrator.Sid = nil
	}

	// TenantId
	if source.TenantId != nil {
		tenantId := *source.TenantId
		administrator.TenantId = &tenantId
	} else {
		administrator.TenantId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedInstanceExternalAdministrator populates the provided destination ManagedInstanceExternalAdministrator from our ManagedInstanceExternalAdministrator
func (administrator *ManagedInstanceExternalAdministrator) AssignProperties_To_ManagedInstanceExternalAdministrator(destination *v20211101s.ManagedInstanceExternalAdministrator) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorType
	if administrator.AdministratorType != nil {
		administratorType := string(*administrator.AdministratorType)
		destination.AdministratorType = &administratorType
	} else {
		destination.AdministratorType = nil
	}

	// AzureADOnlyAuthentication
	if administrator.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *administrator.AzureADOnlyAuthentication
		destination.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	} else {
		destination.AzureADOnlyAuthentication = nil
	}

	// Login
	destination.Login = genruntime.ClonePointerToString(administrator.Login)

	// PrincipalType
	if administrator.PrincipalType != nil {
		principalType := string(*administrator.PrincipalType)
		destination.PrincipalType = &principalType
	} else {
		destination.PrincipalType = nil
	}

	// Sid
	if administrator.Sid != nil {
		sid := *administrator.Sid
		destination.Sid = &sid
	} else {
		destination.Sid = nil
	}

	// TenantId
	if administrator.TenantId != nil {
		tenantId := *administrator.TenantId
		destination.TenantId = &tenantId
	} else {
		destination.TenantId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of a active directory administrator.
type ManagedInstanceExternalAdministrator_STATUS struct {
	// AdministratorType: Type of the sever administrator.
	AdministratorType *ManagedInstanceExternalAdministrator_AdministratorType_STATUS `json:"administratorType,omitempty"`

	// AzureADOnlyAuthentication: Azure Active Directory only Authentication enabled.
	AzureADOnlyAuthentication *bool `json:"azureADOnlyAuthentication,omitempty"`

	// Login: Login name of the server administrator.
	Login *string `json:"login,omitempty"`

	// PrincipalType: Principal Type of the sever administrator.
	PrincipalType *ManagedInstanceExternalAdministrator_PrincipalType_STATUS `json:"principalType,omitempty"`

	// Sid: SID (object ID) of the server administrator.
	Sid *string `json:"sid,omitempty"`

	// TenantId: Tenant ID of the administrator.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedInstanceExternalAdministrator_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (administrator *ManagedInstanceExternalAdministrator_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstanceExternalAdministrator_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (administrator *ManagedInstanceExternalAdministrator_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstanceExternalAdministrator_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstanceExternalAdministrator_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AdministratorType’:
	if typedInput.AdministratorType != nil {
		administratorType := *typedInput.AdministratorType
		administrator.AdministratorType = &administratorType
	}

	// Set property ‘AzureADOnlyAuthentication’:
	if typedInput.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *typedInput.AzureADOnlyAuthentication
		administrator.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	}

	// Set property ‘Login’:
	if typedInput.Login != nil {
		login := *typedInput.Login
		administrator.Login = &login
	}

	// Set property ‘PrincipalType’:
	if typedInput.PrincipalType != nil {
		principalType := *typedInput.PrincipalType
		administrator.PrincipalType = &principalType
	}

	// Set property ‘Sid’:
	if typedInput.Sid != nil {
		sid := *typedInput.Sid
		administrator.Sid = &sid
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		administrator.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS populates our ManagedInstanceExternalAdministrator_STATUS from the provided source ManagedInstanceExternalAdministrator_STATUS
func (administrator *ManagedInstanceExternalAdministrator_STATUS) AssignProperties_From_ManagedInstanceExternalAdministrator_STATUS(source *v20211101s.ManagedInstanceExternalAdministrator_STATUS) error {

	// AdministratorType
	if source.AdministratorType != nil {
		administratorType := ManagedInstanceExternalAdministrator_AdministratorType_STATUS(*source.AdministratorType)
		administrator.AdministratorType = &administratorType
	} else {
		administrator.AdministratorType = nil
	}

	// AzureADOnlyAuthentication
	if source.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *source.AzureADOnlyAuthentication
		administrator.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	} else {
		administrator.AzureADOnlyAuthentication = nil
	}

	// Login
	administrator.Login = genruntime.ClonePointerToString(source.Login)

	// PrincipalType
	if source.PrincipalType != nil {
		principalType := ManagedInstanceExternalAdministrator_PrincipalType_STATUS(*source.PrincipalType)
		administrator.PrincipalType = &principalType
	} else {
		administrator.PrincipalType = nil
	}

	// Sid
	administrator.Sid = genruntime.ClonePointerToString(source.Sid)

	// TenantId
	administrator.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS populates the provided destination ManagedInstanceExternalAdministrator_STATUS from our ManagedInstanceExternalAdministrator_STATUS
func (administrator *ManagedInstanceExternalAdministrator_STATUS) AssignProperties_To_ManagedInstanceExternalAdministrator_STATUS(destination *v20211101s.ManagedInstanceExternalAdministrator_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorType
	if administrator.AdministratorType != nil {
		administratorType := string(*administrator.AdministratorType)
		destination.AdministratorType = &administratorType
	} else {
		destination.AdministratorType = nil
	}

	// AzureADOnlyAuthentication
	if administrator.AzureADOnlyAuthentication != nil {
		azureADOnlyAuthentication := *administrator.AzureADOnlyAuthentication
		destination.AzureADOnlyAuthentication = &azureADOnlyAuthentication
	} else {
		destination.AzureADOnlyAuthentication = nil
	}

	// Login
	destination.Login = genruntime.ClonePointerToString(administrator.Login)

	// PrincipalType
	if administrator.PrincipalType != nil {
		principalType := string(*administrator.PrincipalType)
		destination.PrincipalType = &principalType
	} else {
		destination.PrincipalType = nil
	}

	// Sid
	destination.Sid = genruntime.ClonePointerToString(administrator.Sid)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(administrator.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A private endpoint connection under a managed instance
type ManagedInstancePecProperty_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Properties: Private endpoint connection properties
	Properties *ManagedInstancePrivateEndpointConnectionProperties_STATUS `json:"properties,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedInstancePecProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *ManagedInstancePecProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstancePecProperty_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *ManagedInstancePecProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstancePecProperty_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstancePecProperty_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		property.Id = &id
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 ManagedInstancePrivateEndpointConnectionProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		property.Properties = &properties
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstancePecProperty_STATUS populates our ManagedInstancePecProperty_STATUS from the provided source ManagedInstancePecProperty_STATUS
func (property *ManagedInstancePecProperty_STATUS) AssignProperties_From_ManagedInstancePecProperty_STATUS(source *v20211101s.ManagedInstancePecProperty_STATUS) error {

	// Id
	property.Id = genruntime.ClonePointerToString(source.Id)

	// Properties
	if source.Properties != nil {
		var propertyLocal ManagedInstancePrivateEndpointConnectionProperties_STATUS
		err := propertyLocal.AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		property.Properties = &propertyLocal
	} else {
		property.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedInstancePecProperty_STATUS populates the provided destination ManagedInstancePecProperty_STATUS from our ManagedInstancePecProperty_STATUS
func (property *ManagedInstancePecProperty_STATUS) AssignProperties_To_ManagedInstancePecProperty_STATUS(destination *v20211101s.ManagedInstancePecProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(property.Id)

	// Properties
	if property.Properties != nil {
		var propertyLocal v20211101s.ManagedInstancePrivateEndpointConnectionProperties_STATUS
		err := property.Properties.AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS(&propertyLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &propertyLocal
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS string

const (
	ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Geo     = ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS("Geo")
	ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_GeoZone = ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS("GeoZone")
	ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Local   = ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS("Local")
	ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS_Zone    = ManagedInstanceProperties_CurrentBackupStorageRedundancy_STATUS("Zone")
)

// +kubebuilder:validation:Enum={"BasePrice","LicenseIncluded"}
type ManagedInstanceProperties_LicenseType string

const (
	ManagedInstanceProperties_LicenseType_BasePrice       = ManagedInstanceProperties_LicenseType("BasePrice")
	ManagedInstanceProperties_LicenseType_LicenseIncluded = ManagedInstanceProperties_LicenseType("LicenseIncluded")
)

type ManagedInstanceProperties_LicenseType_STATUS string

const (
	ManagedInstanceProperties_LicenseType_STATUS_BasePrice       = ManagedInstanceProperties_LicenseType_STATUS("BasePrice")
	ManagedInstanceProperties_LicenseType_STATUS_LicenseIncluded = ManagedInstanceProperties_LicenseType_STATUS("LicenseIncluded")
)

// +kubebuilder:validation:Enum={"Default","PointInTimeRestore"}
type ManagedInstanceProperties_ManagedInstanceCreateMode string

const (
	ManagedInstanceProperties_ManagedInstanceCreateMode_Default            = ManagedInstanceProperties_ManagedInstanceCreateMode("Default")
	ManagedInstanceProperties_ManagedInstanceCreateMode_PointInTimeRestore = ManagedInstanceProperties_ManagedInstanceCreateMode("PointInTimeRestore")
)

type ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS string

const (
	ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS_Default            = ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS("Default")
	ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS_PointInTimeRestore = ManagedInstanceProperties_ManagedInstanceCreateMode_STATUS("PointInTimeRestore")
)

type ManagedInstanceProperties_ProvisioningState_STATUS string

const (
	ManagedInstanceProperties_ProvisioningState_STATUS_Accepted     = ManagedInstanceProperties_ProvisioningState_STATUS("Accepted")
	ManagedInstanceProperties_ProvisioningState_STATUS_Canceled     = ManagedInstanceProperties_ProvisioningState_STATUS("Canceled")
	ManagedInstanceProperties_ProvisioningState_STATUS_Created      = ManagedInstanceProperties_ProvisioningState_STATUS("Created")
	ManagedInstanceProperties_ProvisioningState_STATUS_Creating     = ManagedInstanceProperties_ProvisioningState_STATUS("Creating")
	ManagedInstanceProperties_ProvisioningState_STATUS_Deleted      = ManagedInstanceProperties_ProvisioningState_STATUS("Deleted")
	ManagedInstanceProperties_ProvisioningState_STATUS_Deleting     = ManagedInstanceProperties_ProvisioningState_STATUS("Deleting")
	ManagedInstanceProperties_ProvisioningState_STATUS_Failed       = ManagedInstanceProperties_ProvisioningState_STATUS("Failed")
	ManagedInstanceProperties_ProvisioningState_STATUS_NotSpecified = ManagedInstanceProperties_ProvisioningState_STATUS("NotSpecified")
	ManagedInstanceProperties_ProvisioningState_STATUS_Registering  = ManagedInstanceProperties_ProvisioningState_STATUS("Registering")
	ManagedInstanceProperties_ProvisioningState_STATUS_Running      = ManagedInstanceProperties_ProvisioningState_STATUS("Running")
	ManagedInstanceProperties_ProvisioningState_STATUS_Succeeded    = ManagedInstanceProperties_ProvisioningState_STATUS("Succeeded")
	ManagedInstanceProperties_ProvisioningState_STATUS_TimedOut     = ManagedInstanceProperties_ProvisioningState_STATUS("TimedOut")
	ManagedInstanceProperties_ProvisioningState_STATUS_Unknown      = ManagedInstanceProperties_ProvisioningState_STATUS("Unknown")
	ManagedInstanceProperties_ProvisioningState_STATUS_Unrecognized = ManagedInstanceProperties_ProvisioningState_STATUS("Unrecognized")
	ManagedInstanceProperties_ProvisioningState_STATUS_Updating     = ManagedInstanceProperties_ProvisioningState_STATUS("Updating")
)

// +kubebuilder:validation:Enum={"Default","Proxy","Redirect"}
type ManagedInstanceProperties_ProxyOverride string

const (
	ManagedInstanceProperties_ProxyOverride_Default  = ManagedInstanceProperties_ProxyOverride("Default")
	ManagedInstanceProperties_ProxyOverride_Proxy    = ManagedInstanceProperties_ProxyOverride("Proxy")
	ManagedInstanceProperties_ProxyOverride_Redirect = ManagedInstanceProperties_ProxyOverride("Redirect")
)

type ManagedInstanceProperties_ProxyOverride_STATUS string

const (
	ManagedInstanceProperties_ProxyOverride_STATUS_Default  = ManagedInstanceProperties_ProxyOverride_STATUS("Default")
	ManagedInstanceProperties_ProxyOverride_STATUS_Proxy    = ManagedInstanceProperties_ProxyOverride_STATUS("Proxy")
	ManagedInstanceProperties_ProxyOverride_STATUS_Redirect = ManagedInstanceProperties_ProxyOverride_STATUS("Redirect")
)

// +kubebuilder:validation:Enum={"Geo","GeoZone","Local","Zone"}
type ManagedInstanceProperties_RequestedBackupStorageRedundancy string

const (
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_Geo     = ManagedInstanceProperties_RequestedBackupStorageRedundancy("Geo")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_GeoZone = ManagedInstanceProperties_RequestedBackupStorageRedundancy("GeoZone")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_Local   = ManagedInstanceProperties_RequestedBackupStorageRedundancy("Local")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_Zone    = ManagedInstanceProperties_RequestedBackupStorageRedundancy("Zone")
)

type ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS string

const (
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Geo     = ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS("Geo")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_GeoZone = ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS("GeoZone")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Local   = ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS("Local")
	ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS_Zone    = ManagedInstanceProperties_RequestedBackupStorageRedundancy_STATUS("Zone")
)

// Azure Active Directory identity configuration for a resource.
type ResourceIdentity struct {
	// Type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active
	// Directory principal for the resource.
	Type *ResourceIdentity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ResourceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ResourceIdentity_ARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ResourceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceIdentity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ResourceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceIdentity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceIdentity_ARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceIdentity populates our ResourceIdentity from the provided source ResourceIdentity
func (identity *ResourceIdentity) AssignProperties_From_ResourceIdentity(source *v20211101s.ResourceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ResourceIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceIdentity populates the provided destination ResourceIdentity from our ResourceIdentity
func (identity *ResourceIdentity) AssignProperties_To_ResourceIdentity(destination *v20211101s.ResourceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Active Directory identity configuration for a resource.
type ResourceIdentity_STATUS struct {
	// PrincipalId: The Azure Active Directory principal id.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The Azure Active Directory tenant id.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active
	// Directory principal for the resource.
	Type *ResourceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The resource ids of the user assigned identities to use
	UserAssignedIdentities map[string]UserIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ResourceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ResourceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceIdentity_STATUS populates our ResourceIdentity_STATUS from the provided source ResourceIdentity_STATUS
func (identity *ResourceIdentity_STATUS) AssignProperties_From_ResourceIdentity_STATUS(source *v20211101s.ResourceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ResourceIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceIdentity_STATUS populates the provided destination ResourceIdentity_STATUS from our ResourceIdentity_STATUS
func (identity *ResourceIdentity_STATUS) AssignProperties_To_ResourceIdentity_STATUS(destination *v20211101s.ResourceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20211101s.UserIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20211101s.UserIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The managed instance's service principal configuration for a resource.
type ServicePrincipal struct {
	// Type: Service principal type.
	Type *ServicePrincipal_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ServicePrincipal{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (principal *ServicePrincipal) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if principal == nil {
		return nil, nil
	}
	result := &ServicePrincipal_ARM{}

	// Set property ‘Type’:
	if principal.Type != nil {
		typeVar := *principal.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principal *ServicePrincipal) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServicePrincipal_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principal *ServicePrincipal) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServicePrincipal_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServicePrincipal_ARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		principal.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipal populates our ServicePrincipal from the provided source ServicePrincipal
func (principal *ServicePrincipal) AssignProperties_From_ServicePrincipal(source *v20211101s.ServicePrincipal) error {

	// Type
	if source.Type != nil {
		typeVar := ServicePrincipal_Type(*source.Type)
		principal.Type = &typeVar
	} else {
		principal.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipal populates the provided destination ServicePrincipal from our ServicePrincipal
func (principal *ServicePrincipal) AssignProperties_To_ServicePrincipal(destination *v20211101s.ServicePrincipal) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if principal.Type != nil {
		typeVar := string(*principal.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The managed instance's service principal configuration for a resource.
type ServicePrincipal_STATUS struct {
	// ClientId: The Azure Active Directory application client id.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The Azure Active Directory application object id.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The Azure Active Directory tenant id.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Service principal type.
	Type *ServicePrincipal_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ServicePrincipal_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principal *ServicePrincipal_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServicePrincipal_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principal *ServicePrincipal_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServicePrincipal_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServicePrincipal_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		principal.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		principal.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		principal.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		principal.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipal_STATUS populates our ServicePrincipal_STATUS from the provided source ServicePrincipal_STATUS
func (principal *ServicePrincipal_STATUS) AssignProperties_From_ServicePrincipal_STATUS(source *v20211101s.ServicePrincipal_STATUS) error {

	// ClientId
	principal.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	principal.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	principal.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ServicePrincipal_Type_STATUS(*source.Type)
		principal.Type = &typeVar
	} else {
		principal.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipal_STATUS populates the provided destination ServicePrincipal_STATUS from our ServicePrincipal_STATUS
func (principal *ServicePrincipal_STATUS) AssignProperties_To_ServicePrincipal_STATUS(destination *v20211101s.ServicePrincipal_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(principal.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(principal.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(principal.TenantId)

	// Type
	if principal.Type != nil {
		typeVar := string(*principal.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An ARM Resource SKU.
type Sku struct {
	// Capacity: Capacity of the particular SKU.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the SKU, typically, a letter + Number code, e.g. P3.
	Name *string `json:"name,omitempty"`

	// Size: Size of the particular SKU
	Size *string `json:"size,omitempty"`

	// Tier: The tier or edition of the particular SKU, e.g. Basic, Premium.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &Sku_ARM{}

	// Set property ‘Capacity’:
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property ‘Family’:
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property ‘Size’:
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property ‘Tier’:
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_ARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Family’:
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Size’:
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v20211101s.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v20211101s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An ARM Resource SKU.
type Sku_STATUS struct {
	// Capacity: Capacity of the particular SKU.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// Name: The name of the SKU, typically, a letter + Number code, e.g. P3.
	Name *string `json:"name,omitempty"`

	// Size: Size of the particular SKU
	Size *string `json:"size,omitempty"`

	// Tier: The tier or edition of the particular SKU, e.g. Basic, Premium.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Family’:
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Size’:
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v20211101s.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v20211101s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ActiveDirectory"}
type ManagedInstanceExternalAdministrator_AdministratorType string

const ManagedInstanceExternalAdministrator_AdministratorType_ActiveDirectory = ManagedInstanceExternalAdministrator_AdministratorType("ActiveDirectory")

type ManagedInstanceExternalAdministrator_AdministratorType_STATUS string

const ManagedInstanceExternalAdministrator_AdministratorType_STATUS_ActiveDirectory = ManagedInstanceExternalAdministrator_AdministratorType_STATUS("ActiveDirectory")

// +kubebuilder:validation:Enum={"Application","Group","User"}
type ManagedInstanceExternalAdministrator_PrincipalType string

const (
	ManagedInstanceExternalAdministrator_PrincipalType_Application = ManagedInstanceExternalAdministrator_PrincipalType("Application")
	ManagedInstanceExternalAdministrator_PrincipalType_Group       = ManagedInstanceExternalAdministrator_PrincipalType("Group")
	ManagedInstanceExternalAdministrator_PrincipalType_User        = ManagedInstanceExternalAdministrator_PrincipalType("User")
)

type ManagedInstanceExternalAdministrator_PrincipalType_STATUS string

const (
	ManagedInstanceExternalAdministrator_PrincipalType_STATUS_Application = ManagedInstanceExternalAdministrator_PrincipalType_STATUS("Application")
	ManagedInstanceExternalAdministrator_PrincipalType_STATUS_Group       = ManagedInstanceExternalAdministrator_PrincipalType_STATUS("Group")
	ManagedInstanceExternalAdministrator_PrincipalType_STATUS_User        = ManagedInstanceExternalAdministrator_PrincipalType_STATUS("User")
)

// Properties of a private endpoint connection.
type ManagedInstancePrivateEndpointConnectionProperties_STATUS struct {
	// PrivateEndpoint: Private endpoint which the connection belongs to.
	PrivateEndpoint *ManagedInstancePrivateEndpointProperty_STATUS `json:"privateEndpoint,omitempty"`

	// PrivateLinkServiceConnectionState: Connection State of the Private Endpoint Connection.
	PrivateLinkServiceConnectionState *ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS `json:"privateLinkServiceConnectionState,omitempty"`

	// ProvisioningState: State of the Private Endpoint Connection.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedInstancePrivateEndpointConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ManagedInstancePrivateEndpointConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstancePrivateEndpointConnectionProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ManagedInstancePrivateEndpointConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstancePrivateEndpointConnectionProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstancePrivateEndpointConnectionProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘PrivateEndpoint’:
	if typedInput.PrivateEndpoint != nil {
		var privateEndpoint1 ManagedInstancePrivateEndpointProperty_STATUS
		err := privateEndpoint1.PopulateFromARM(owner, *typedInput.PrivateEndpoint)
		if err != nil {
			return err
		}
		privateEndpoint := privateEndpoint1
		properties.PrivateEndpoint = &privateEndpoint
	}

	// Set property ‘PrivateLinkServiceConnectionState’:
	if typedInput.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState1 ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState1.PopulateFromARM(owner, *typedInput.PrivateLinkServiceConnectionState)
		if err != nil {
			return err
		}
		privateLinkServiceConnectionState := privateLinkServiceConnectionState1
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		properties.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS populates our ManagedInstancePrivateEndpointConnectionProperties_STATUS from the provided source ManagedInstancePrivateEndpointConnectionProperties_STATUS
func (properties *ManagedInstancePrivateEndpointConnectionProperties_STATUS) AssignProperties_From_ManagedInstancePrivateEndpointConnectionProperties_STATUS(source *v20211101s.ManagedInstancePrivateEndpointConnectionProperties_STATUS) error {

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint ManagedInstancePrivateEndpointProperty_STATUS
		err := privateEndpoint.AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		properties.PrivateEndpoint = &privateEndpoint
	} else {
		properties.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if source.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState.AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(source.PrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		properties.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	properties.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// No error
	return nil
}

// AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS populates the provided destination ManagedInstancePrivateEndpointConnectionProperties_STATUS from our ManagedInstancePrivateEndpointConnectionProperties_STATUS
func (properties *ManagedInstancePrivateEndpointConnectionProperties_STATUS) AssignProperties_To_ManagedInstancePrivateEndpointConnectionProperties_STATUS(destination *v20211101s.ManagedInstancePrivateEndpointConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateEndpoint
	if properties.PrivateEndpoint != nil {
		var privateEndpoint v20211101s.ManagedInstancePrivateEndpointProperty_STATUS
		err := properties.PrivateEndpoint.AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if properties.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState v20211101s.ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
		err := properties.PrivateLinkServiceConnectionState.AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(&privateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		destination.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		destination.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(properties.ProvisioningState)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned"}
type ServicePrincipal_Type string

const (
	ServicePrincipal_Type_None           = ServicePrincipal_Type("None")
	ServicePrincipal_Type_SystemAssigned = ServicePrincipal_Type("SystemAssigned")
)

type ServicePrincipal_Type_STATUS string

const (
	ServicePrincipal_Type_STATUS_None           = ServicePrincipal_Type_STATUS("None")
	ServicePrincipal_Type_STATUS_SystemAssigned = ServicePrincipal_Type_STATUS("SystemAssigned")
)

// Azure Active Directory identity configuration for a resource.
type UserIdentity_STATUS struct {
	// ClientId: The Azure Active Directory client id.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The Azure Active Directory principal id.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserIdentity_STATUS populates our UserIdentity_STATUS from the provided source UserIdentity_STATUS
func (identity *UserIdentity_STATUS) AssignProperties_From_UserIdentity_STATUS(source *v20211101s.UserIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserIdentity_STATUS populates the provided destination UserIdentity_STATUS from our UserIdentity_STATUS
func (identity *UserIdentity_STATUS) AssignProperties_To_UserIdentity_STATUS(destination *v20211101s.UserIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedInstancePrivateEndpointProperty_STATUS struct {
	// Id: Resource id of the private endpoint.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedInstancePrivateEndpointProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *ManagedInstancePrivateEndpointProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstancePrivateEndpointProperty_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *ManagedInstancePrivateEndpointProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstancePrivateEndpointProperty_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstancePrivateEndpointProperty_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		property.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS populates our ManagedInstancePrivateEndpointProperty_STATUS from the provided source ManagedInstancePrivateEndpointProperty_STATUS
func (property *ManagedInstancePrivateEndpointProperty_STATUS) AssignProperties_From_ManagedInstancePrivateEndpointProperty_STATUS(source *v20211101s.ManagedInstancePrivateEndpointProperty_STATUS) error {

	// Id
	property.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS populates the provided destination ManagedInstancePrivateEndpointProperty_STATUS from our ManagedInstancePrivateEndpointProperty_STATUS
func (property *ManagedInstancePrivateEndpointProperty_STATUS) AssignProperties_To_ManagedInstancePrivateEndpointProperty_STATUS(destination *v20211101s.ManagedInstancePrivateEndpointProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(property.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS struct {
	// ActionsRequired: The private link service connection description.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description: The private link service connection description.
	Description *string `json:"description,omitempty"`

	// Status: The private link service connection status.
	Status *string `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘ActionsRequired’:
	if typedInput.ActionsRequired != nil {
		actionsRequired := *typedInput.ActionsRequired
		property.ActionsRequired = &actionsRequired
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		property.Description = &description
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		property.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS populates our ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS from the provided source ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
func (property *ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) AssignProperties_From_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(source *v20211101s.ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) error {

	// ActionsRequired
	property.ActionsRequired = genruntime.ClonePointerToString(source.ActionsRequired)

	// Description
	property.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	property.Status = genruntime.ClonePointerToString(source.Status)

	// No error
	return nil
}

// AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS populates the provided destination ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS from our ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS
func (property *ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) AssignProperties_To_ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS(destination *v20211101s.ManagedInstancePrivateLinkServiceConnectionStateProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionsRequired
	destination.ActionsRequired = genruntime.ClonePointerToString(property.ActionsRequired)

	// Description
	destination.Description = genruntime.ClonePointerToString(property.Description)

	// Status
	destination.Status = genruntime.ClonePointerToString(property.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedInstance{}, &ManagedInstanceList{})
}
